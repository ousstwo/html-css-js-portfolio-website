import { a as mf, b as Ne, c as I } from "./chunk-ELYU6EKT.mjs"; var Ct = {}; mf(Ct, { Children: () => qn, Component: () => Re, Fragment: () => gr, Profiler: () => UT, PureComponent: () => GT, StrictMode: () => qT, Suspense: () => ms, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => XT, cloneElement: () => vr, createContext: () => ke, createElement: () => ml, createFactory: () => YT, createRef: () => oo, default: () => x, forwardRef: () => Oe, isValidElement: () => Ht, lazy: () => KT, memo: () => QT, startTransition: () => yr, unstable_act: () => ZT, useCallback: () => se, useContext: () => V, useDebugValue: () => JT, useDeferredValue: () => eE, useEffect: () => z, useId: () => Ti, useImperativeHandle: () => tE, useInsertionEffect: () => st, useLayoutEffect: () => tt, useMemo: () => ae, useReducer: () => nE, useRef: () => D, useState: () => Ye, useSyncExternalStore: () => jg, useTransition: () => rE, version: () => iE }); var x = {}, ps = Symbol.for("react.element"), FT = Symbol.for("react.portal"), IT = Symbol.for("react.fragment"), LT = Symbol.for("react.strict_mode"), MT = Symbol.for("react.profiler"), OT = Symbol.for("react.provider"), DT = Symbol.for("react.context"), AT = Symbol.for("react.forward_ref"), VT = Symbol.for("react.suspense"), BT = Symbol.for("react.memo"), zT = Symbol.for("react.lazy"), Mg = Symbol.iterator; function $T(e) { return e === null || typeof e != "object" ? null : (e = Mg && e[Mg] || e["@@iterator"], typeof e == "function" ? e : null) } var Ag = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Vg = Object.assign, Bg = {}; function io(e, t, n) { this.props = e, this.context = t, this.refs = Bg, this.updater = n || Ag } io.prototype.isReactComponent = {}; io.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; io.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function zg() { } zg.prototype = io.prototype; function vf(e, t, n) { this.props = e, this.context = t, this.refs = Bg, this.updater = n || Ag } var yf = vf.prototype = new zg; yf.constructor = vf; Vg(yf, io.prototype); yf.isPureReactComponent = !0; var Og = Array.isArray, $g = Object.prototype.hasOwnProperty, bf = { current: null }, Ng = { key: !0, ref: !0, __self: !0, __source: !0 }; function Hg(e, t, n) { var r, i = {}, o = null, s = null; if (t != null) for (r in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (o = "" + t.key), t) $g.call(t, r) && !Ng.hasOwnProperty(r) && (i[r] = t[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; i.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: ps, type: e, key: o, ref: s, props: i, _owner: bf.current } } function NT(e, t) { return { $$typeof: ps, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function xf(e) { return typeof e == "object" && e !== null && e.$$typeof === ps } function HT(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var Dg = /\/+/g; function gf(e, t) { return typeof e == "object" && e !== null && e.key != null ? HT("" + e.key) : t.toString(36) } function hl(e, t, n, r, i) { var o = typeof e; o !== "undefined" && o !== "boolean" || (e = null); var s = !1; if (e === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case ps: case FT: s = !0 } }if (s) return s = e, i = i(s), e = r === "" ? "." + gf(s, 0) : r, Og(i) ? (n = "", e != null && (n = e.replace(Dg, "$&/") + "/"), hl(i, t, n, "", function (c) { return c })) : i != null && (xf(i) && (i = NT(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(Dg, "$&/") + "/") + e)), t.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", Og(e)) for (var a = 0; a < e.length; a++) { o = e[a]; var l = r + gf(o, a); s += hl(o, t, n, l, i) } else if (l = $T(e), typeof l == "function") for (e = l.call(e), a = 0; !(o = e.next()).done;)o = o.value, l = r + gf(o, a++), s += hl(o, t, n, l, i); else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function dl(e, t, n) { if (e == null) return e; var r = [], i = 0; return hl(e, r, "", "", function (o) { return t.call(n, o, i++) }), r } function jT(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { e._status !== 0 && e._status !== -1 || (e._status = 1, e._result = n) }, function (n) { e._status !== 0 && e._status !== -1 || (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var Ot = { current: null }, pl = { transition: null }, WT = { ReactCurrentDispatcher: Ot, ReactCurrentBatchConfig: pl, ReactCurrentOwner: bf }; x.Children = { map: dl, forEach: function (e, t, n) { dl(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return dl(e, function () { t++ }), t }, toArray: function (e) { return dl(e, function (t) { return t }) || [] }, only: function (e) { if (!xf(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; x.Component = io; x.Fragment = IT; x.Profiler = MT; x.PureComponent = vf; x.StrictMode = LT; x.Suspense = VT; x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = WT; x.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = Vg({}, e.props), i = e.key, o = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (o = t.ref, s = bf.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) $g.call(t, l) && !Ng.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; r.children = a } return { $$typeof: ps, type: e.type, key: i, ref: o, props: r, _owner: s } }; x.createContext = function (e) { return e = { $$typeof: DT, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: OT, _context: e }, e.Consumer = e }; x.createElement = Hg; x.createFactory = function (e) { var t = Hg.bind(null, e); return t.type = e, t }; x.createRef = function () { return { current: null } }; x.forwardRef = function (e) { return { $$typeof: AT, render: e } }; x.isValidElement = xf; x.lazy = function (e) { return { $$typeof: zT, _payload: { _status: -1, _result: e }, _init: jT } }; x.memo = function (e, t) { return { $$typeof: BT, type: e, compare: t === void 0 ? null : t } }; x.startTransition = function (e) { var t = pl.transition; pl.transition = {}; try { e() } finally { pl.transition = t } }; x.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; x.useCallback = function (e, t) { return Ot.current.useCallback(e, t) }; x.useContext = function (e) { return Ot.current.useContext(e) }; x.useDebugValue = function () { }; x.useDeferredValue = function (e) { return Ot.current.useDeferredValue(e) }; x.useEffect = function (e, t) { return Ot.current.useEffect(e, t) }; x.useId = function () { return Ot.current.useId() }; x.useImperativeHandle = function (e, t, n) { return Ot.current.useImperativeHandle(e, t, n) }; x.useInsertionEffect = function (e, t) { return Ot.current.useInsertionEffect(e, t) }; x.useLayoutEffect = function (e, t) { return Ot.current.useLayoutEffect(e, t) }; x.useMemo = function (e, t) { return Ot.current.useMemo(e, t) }; x.useReducer = function (e, t, n) { return Ot.current.useReducer(e, t, n) }; x.useRef = function (e) { return Ot.current.useRef(e) }; x.useState = function (e) { return Ot.current.useState(e) }; x.useSyncExternalStore = function (e, t, n) { return Ot.current.useSyncExternalStore(e, t, n) }; x.useTransition = function () { return Ot.current.useTransition() }; x.version = "18.2.0"; var qn = x.Children, Re = x.Component, gr = x.Fragment, UT = x.Profiler, GT = x.PureComponent, qT = x.StrictMode, ms = x.Suspense, XT = x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, vr = x.cloneElement, ke = x.createContext, ml = x.createElement, YT = x.createFactory, oo = x.createRef, Oe = x.forwardRef, Ht = x.isValidElement, KT = x.lazy, QT = x.memo, yr = x.startTransition, ZT = x.unstable_act, se = x.useCallback, V = x.useContext, JT = x.useDebugValue, eE = x.useDeferredValue, z = x.useEffect, Ti = x.useId, tE = x.useImperativeHandle, st = x.useInsertionEffect, tt = x.useLayoutEffect, ae = x.useMemo, nE = x.useReducer, D = x.useRef, Ye = x.useState, jg = x.useSyncExternalStore, rE = x.useTransition, iE = x.version; var oE = "default" in Ct ? x : Ct, so = {}, sE = oE, aE = Symbol.for("react.element"), lE = Symbol.for("react.fragment"), cE = Object.prototype.hasOwnProperty, uE = sE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, fE = { key: !0, ref: !0, __self: !0, __source: !0 }; function Wg(e, t, n) { var r, i = {}, o = null, s = null; n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (s = t.ref); for (r in t) cE.call(t, r) && !fE.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: aE, type: e, key: o, ref: s, props: i, _owner: uE.current } } so.Fragment = lE; so.jsx = Wg; so.jsxs = Wg; var He = so.Fragment, k = so.jsx, ue = so.jsxs; var dE = Object.create, Zf = Object.defineProperty, hE = Object.getOwnPropertyDescriptor, gy = Object.getOwnPropertyNames, pE = Object.getPrototypeOf, mE = Object.prototype.hasOwnProperty, gE = (e, t, n) => t in e ? Zf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, gn = (e, t) => function () { return t || (0, e[gy(e)[0]])((t = { exports: {} }).exports, t), t.exports }, vE = (e, t, n, r) => { if (t && typeof t == "object" || typeof t == "function") for (let i of gy(t)) !mE.call(e, i) && i !== n && Zf(e, i, { get: () => t[i], enumerable: !(r = hE(t, i)) || r.enumerable }); return e }, Jn = (e, t, n) => (n = e != null ? dE(pE(e)) : {}, vE(t || !e || !e.__esModule ? Zf(n, "default", { value: e, enumerable: !0 }) : n, e)), T = (e, t, n) => (gE(e, typeof t != "symbol" ? t + "" : t, n), n), Jf = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, fe = (e, t, n) => (Jf(e, t, "read from private field"), n ? n.call(e) : t.get(e)), tn = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, ed = (e, t, n, r) => (Jf(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), Wt = (e, t, n) => (Jf(e, t, "access private method"), n), yE = gn({ "../../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); function t(n) { var r = {}; return function (i) { return r[i] === void 0 && (r[i] = n(i)), r[i] } } e.default = t } }), bE = gn({ "../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); function t(o) { return o && typeof o == "object" && "default" in o ? o.default : o } var n = t(yE()), r = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, i = n(function (o) { return r.test(o) || o.charCodeAt(0) === 111 && o.charCodeAt(1) === 110 && o.charCodeAt(2) < 91 }); e.default = i } }), Zn = ke({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }), Is = ke({}), go = ke(null), Il = typeof I < "u", Ur = Il ? tt : z, Ll = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), xE = "framerAppearId", Ml = "data-" + Ll(xE), Ol = { skipAnimations: !1, useManualTiming: !1 }, Dl = ke({}), Rs = ke({}), gt = e => e, vo = gt, en = gt, vy = ke({ strict: !1 }); function wE(e) { let t = new Set, n = new Set, r = !1, i = !1, o = new WeakSet, s = { delta: 0, timestamp: 0, isProcessing: !1 }; function a(c) { o.has(c) && (l.schedule(c), e()), c(s) } let l = { schedule: (c, u = !1, f = !1) => { let p = f && r ? t : n; return u && o.add(c), p.has(c) || p.add(c), c }, cancel: c => { n.delete(c), o.delete(c) }, process: c => { if (s = c, r) { i = !0; return } r = !0, [t, n] = [n, t], n.clear(), t.forEach(a), r = !1, i && (i = !1, l.process(c)) } }; return l } var ys = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], SE = 40; function yy(e, t) { let n = !1, r = !0, i = { delta: 0, timestamp: 0, isProcessing: !1 }, o = () => n = !0, s = ys.reduce((h, m) => (h[m] = wE(o), h), {}), { read: a, resolveKeyframes: l, update: c, preRender: u, render: f, postRender: d } = s, p = () => { let h = Ol.useManualTiming ? i.timestamp : performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(h - i.timestamp, SE), 1), i.timestamp = h, i.isProcessing = !0, a.process(i), l.process(i), c.process(i), u.process(i), f.process(i), d.process(i), i.isProcessing = !1, n && t && (r = !1, e(p)) }, y = () => { n = !0, r = !0, i.isProcessing || e(p) }; return { schedule: ys.reduce((h, m) => { let v = s[m]; return h[m] = (w, C = !1, S = !1) => (n || y(), v.schedule(w, C, S)), h }, {}), cancel: h => { for (let m = 0; m < ys.length; m++)s[ys[m]].cancel(h) }, state: i, steps: s } } var { schedule: td, cancel: Q$ } = yy(queueMicrotask, !1); function ao(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } var Ug = !1; function kE(e, t, n, r, i) { var o; let { visualElement: s } = V(Is), a = V(vy), l = V(go), c = V(Zn).reducedMotion, u = D(); r = r || a.renderer, !u.current && r && (u.current = r(e, { visualState: t, parent: s, props: n, presenceContext: l, blockInitialAnimation: l ? l.initial === !1 : !1, reducedMotionConfig: c })); let f = u.current, d = V(Dl); f && !f.projection && i && (f.type === "html" || f.type === "svg") && TE(u.current, n, i, d), st(() => { f && f.update(n, l) }); let p = n[Ml], y = D(!!p && !I.MotionHandoffIsComplete && ((o = I.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(I, p))); return Ur(() => { f && (f.updateFeatures(), td.render(f.render), y.current && f.animationState && f.animationState.animateChanges()) }), z(() => { f && (!y.current && f.animationState && f.animationState.animateChanges(), y.current = !1, Ug || (Ug = !0, queueMicrotask(CE))) }), f } function CE() { I.MotionHandoffIsComplete = !0 } function TE(e, t, n, r) { let { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: c } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : by(e.parent)), e.projection.setOptions({ layoutId: i, layout: o, alwaysMeasureLayout: !!s || a && ao(a), visualElement: e, animationType: typeof o == "string" ? o : "both", initialPromotionConfig: r, layoutScroll: l, layoutRoot: c }) } function by(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : by(e.parent) } function EE(e, t, n) { return se(r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : ao(n) && (n.current = r)) }, [t]) } function Ps(e) { return typeof e == "string" || Array.isArray(e) } function _s(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } var nd = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], rd = ["initial", ...nd]; function Al(e) { return _s(e.animate) || rd.some(t => Ps(e[t])) } function xy(e) { return !!(Al(e) || e.variants) } function RE(e, t) { if (Al(e)) { let { initial: n, animate: r } = e; return { initial: n === !1 || Ps(n) ? n : void 0, animate: Ps(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function PE(e) { let { initial: t, animate: n } = RE(e, V(Is)); return ae(() => ({ initial: t, animate: n }), [Gg(t), Gg(n)]) } function Gg(e) { return Array.isArray(e) ? e.join(" ") : e } var qg = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ho = {}; for (let e in qg) ho[e] = { isEnabled: t => qg[e].some(n => !!t[n]) }; function _E(e) { for (let t in e) ho[t] = { ...ho[t], ...e[t] } } var id = Symbol.for("motionComponentSymbol"); function wy({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) { e && _E(e); function o(a, l) { let c, u = { ...V(Zn), ...a, layoutId: FE(a) }, { isStatic: f } = u, d = PE(a), p = r(a, f); if (!f && Il) { IE(u, e); let y = LE(u); c = y.MeasureLayout, d.visualElement = kE(i, p, u, t, y.ProjectionNode) } return ue(Is.Provider, { value: d, children: [c && d.visualElement ? k(c, { visualElement: d.visualElement, ...u }) : null, n(i, a, EE(p, d.visualElement, l), p, f, d.visualElement)] }) } let s = Oe(o); return s[id] = i, s } function FE({ layoutId: e }) { let t = V(Rs).id; return t && e !== void 0 ? t + "-" + e : e } function IE(e, t) { let n = V(vy).strict } function LE(e) { let { drag: t, layout: n } = ho; if (!t && !n) return {}; let r = { ...t, ...n }; return { MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } var Cl = {}; function od(e) { Object.assign(Cl, e) } var De = e => !!(e && e.getVelocity), wr = (e, t, n) => n > t ? t : n < e ? e : n, ws = e => Math.round(e * 1e5) / 1e5, sd = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, ME = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, OE = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function Ls(e) { return typeof e == "string" } function DE(e) { return e == null } var Ms = e => ({ test: t => Ls(t) && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), Hr = Ms("deg"), Xn = Ms("%"), X = Ms("px"), AE = Ms("vh"), VE = Ms("vw"), Xg = { ...Xn, parse: e => Xn.parse(e) / 100, transform: e => Xn.transform(e * 100) }, Os = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Gr = new Set(Os), Sy = (e, t) => t && typeof e == "number" ? t.transform(e) : e, yo = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Ss = { ...yo, transform: e => wr(0, 1, e) }, gl = { ...yo, default: 1 }, Yg = { ...yo, transform: Math.round }, ad = { borderWidth: X, borderTopWidth: X, borderRightWidth: X, borderBottomWidth: X, borderLeftWidth: X, borderRadius: X, radius: X, borderTopLeftRadius: X, borderTopRightRadius: X, borderBottomRightRadius: X, borderBottomLeftRadius: X, width: X, maxWidth: X, height: X, maxHeight: X, size: X, top: X, right: X, bottom: X, left: X, padding: X, paddingTop: X, paddingRight: X, paddingBottom: X, paddingLeft: X, margin: X, marginTop: X, marginRight: X, marginBottom: X, marginLeft: X, rotate: Hr, rotateX: Hr, rotateY: Hr, rotateZ: Hr, scale: gl, scaleX: gl, scaleY: gl, scaleZ: gl, skew: Hr, skewX: Hr, skewY: Hr, distance: X, translateX: X, translateY: X, translateZ: X, x: X, y: X, z: X, perspective: X, transformPerspective: X, opacity: Ss, originX: Xg, originY: Xg, originZ: X, zIndex: Yg, backgroundPositionX: X, backgroundPositionY: X, fillOpacity: Ss, strokeOpacity: Ss, numOctaves: Yg }, BE = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, zE = Os.length; function ky(e, t, n) { let r = "", i = !0; for (let o = 0; o < zE; o++) { let s = Os[o], a = e[s]; if (a === void 0) continue; let l = !0; if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) { let c = Sy(a, ad[s]); if (!l) { i = !1; let u = BE[s] || s; r += `${u}(${c}) ` } n && (t[s] = c) } } return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r } var $E = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function po(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || $E.has(e) } var Cy = e => !po(e); function Ty(e) { e && (Cy = t => t.startsWith("on") ? !po(t) : e(t)) } try { Ty(bE().default) } catch { } function Ey(e, t, n) { let r = {}; for (let i in e) i === "values" && typeof e.values == "object" || (Cy(i) || n === !0 && po(i) || !t && !po(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r } var Mf = e => Array.isArray(e), NE = e => !!(e && typeof e == "object" && e.mix && e.toValue), HE = e => Mf(e) ? e[e.length - 1] || 0 : e; function Tt(e) { let t = De(e) ? e.get() : e; return NE(t) ? t.toValue() : t } function Kg(e) { let t = [{}, {}]; return e?.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function ld(e, t, n, r) { if (typeof t == "function") { let [i, o] = Kg(r); t = t(n !== void 0 ? n : e.custom, i, o) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { let [i, o] = Kg(r); t = t(n !== void 0 ? n : e.custom, i, o) } return t } function er(e) { let t = D(null); return t.current === null && (t.current = e()), t.current } var Ry = new Set(["opacity", "clipPath", "filter", "transform"]); function Py(e) { if (Gr.has(e)) return "transform"; if (Ry.has(e)) return Ll(e) } function Vl(e, t) { e.indexOf(t) === -1 && e.push(t) } function Ds(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } function jE([...e], t, n) { let r = t < 0 ? e.length + t : t; if (r >= 0 && r < e.length) { let i = n < 0 ? e.length + n : n, [o] = e.splice(t, 1); e.splice(i, 0, o) } return e } function WE({ applyWillChange: e = !1, scrapeMotionValuesFromProps: t, createRenderState: n, onMount: r }, i, o, s, a) { let l = { latestValues: GE(i, o, s, a ? !1 : e, t), renderState: n() }; return r && (l.mount = c => r(i, c, l)), l } var Bl = e => (t, n) => { let r = V(Is), i = V(go), o = () => WE(e, t, r, i, n); return n ? o() : er(o) }; function UE(e, t) { let n = Py(t); n && Vl(e, n) } function Qg(e, t, n) { let r = Array.isArray(t) ? t : [t]; for (let i = 0; i < r.length; i++) { let o = ld(e, r[i]); if (o) { let { transitionEnd: s, transition: a, ...l } = o; n(l, s) } } } function GE(e, t, n, r, i) { var o; let s = {}, a = [], l = r && ((o = e.style) === null || o === void 0 ? void 0 : o.willChange) === void 0, c = i(e, {}); for (let b in c) s[b] = Tt(c[b]); let { initial: u, animate: f } = e, d = Al(e), p = xy(e); t && p && !d && e.inherit !== !1 && (u === void 0 && (u = t.initial), f === void 0 && (f = t.animate)); let y = n ? n.initial === !1 : !1; y = y || u === !1; let g = y ? f : u; return g && typeof g != "boolean" && !_s(g) && Qg(e, g, (b, h) => { for (let m in b) { let v = b[m]; if (Array.isArray(v)) { let w = y ? v.length - 1 : 0; v = v[w] } v !== null && (s[m] = v) } for (let m in h) s[m] = h[m] }), l && (f && u !== !1 && !_s(f) && Qg(e, f, b => { for (let h in b) UE(a, h) }), a.length && (s.willChange = a.join(","))), s } var { schedule: Y, cancel: Dt, state: We, steps: bl } = yy(typeof requestAnimationFrame < "u" ? requestAnimationFrame : gt, !0), _y = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1; function zl(e, t = "page") { return { point: { x: e[`${t}X`], y: e[`${t}Y`] } } } var Fy = e => t => _y(t) && e(t, zl(t)); function br(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } function Yn(e, t, n, r) { return br(e, t, Fy(n), r) } var qE = (e, t) => n => t(e(n)), Kn = (...e) => e.reduce(qE); function Iy(e) { let t = null; return () => { let n = () => { t = null }; return t === null ? (t = e, n) : !1 } } var Zg = Iy("dragHorizontal"), Jg = Iy("dragVertical"); function Ly(e) { let t = !1; if (e === "y") t = Jg(); else if (e === "x") t = Zg(); else { let n = Zg(), r = Jg(); n && r ? t = () => { n(), r() } : (n && n(), r && r()) } return t } function cd() { let e = Ly(!0); return e ? (e(), !1) : !0 } var ud = (e, t) => n => !!(Ls(n) && OE.test(n) && n.startsWith(e) || t && !DE(n) && Object.prototype.hasOwnProperty.call(n, t)), My = (e, t, n) => r => { if (!Ls(r)) return r; let [i, o, s, a] = r.match(sd); return { [e]: parseFloat(i), [t]: parseFloat(o), [n]: parseFloat(s), alpha: a !== void 0 ? parseFloat(a) : 1 } }, XE = e => wr(0, 255, e), wf = { ...yo, transform: e => Math.round(XE(e)) }, _i = { test: ud("rgb", "red"), parse: My("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + wf.transform(e) + ", " + wf.transform(t) + ", " + wf.transform(n) + ", " + ws(Ss.transform(r)) + ")" }; function YE(e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } var Of = { test: ud("#"), parse: YE, transform: _i.transform }, lo = { test: ud("hsl", "hue"), parse: My("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Xn.transform(ws(t)) + ", " + Xn.transform(ws(n)) + ", " + ws(Ss.transform(r)) + ")" }, mt = { test: e => _i.test(e) || Of.test(e) || lo.test(e), parse: e => _i.test(e) ? _i.parse(e) : lo.test(e) ? lo.parse(e) : Of.parse(e), transform: e => Ls(e) ? e : e.hasOwnProperty("red") ? _i.transform(e) : lo.transform(e) }; function KE(e) { var t, n; return isNaN(e) && Ls(e) && (((t = e.match(sd)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(ME)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } var Oy = "number", Dy = "color", QE = "var", ZE = "var(", ev = "${}", JE = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Fs(e) { let t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = [], o = 0, a = t.replace(JE, l => (mt.test(l) ? (r.color.push(o), i.push(Dy), n.push(mt.parse(l))) : l.startsWith(ZE) ? (r.var.push(o), i.push(QE), n.push(l)) : (r.number.push(o), i.push(Oy), n.push(parseFloat(l))), ++o, ev)).split(ev); return { values: n, split: a, indexes: r, types: i } } function Ay(e) { return Fs(e).values } function Vy(e) { let { split: t, types: n } = Fs(e), r = t.length; return i => { let o = ""; for (let s = 0; s < r; s++)if (o += t[s], i[s] !== void 0) { let a = n[s]; a === Oy ? o += ws(i[s]) : a === Dy ? o += mt.transform(i[s]) : o += i[s] } return o } } var eR = e => typeof e == "number" ? 0 : e; function tR(e) { let t = Ay(e); return Vy(e)(t.map(eR)) } var Sr = { test: KE, parse: Ay, createTransformer: Vy, getAnimatableNone: tR }, Fn = e => e * 1e3, Qn = e => e / 1e3; function fd(e, t) { return t ? e * (1e3 / t) : 0 } var nR = 5; function By(e, t, n) { let r = Math.max(t - nR, 0); return fd(n - e(r), t - r) } var Sf = .001, rR = .01, tv = 10, iR = .05, oR = 1; function sR({ duration: e = 800, bounce: t = .25, velocity: n = 0, mass: r = 1 }) { let i, o; vo(e <= Fn(tv), "Spring duration must be 10 seconds or less"); let s = 1 - t; s = wr(iR, oR, s), e = wr(rR, tv, Qn(e)), s < 1 ? (i = c => { let u = c * s, f = u * e, d = u - n, p = Df(c, s), y = Math.exp(-f); return Sf - d / p * y }, o = c => { let f = c * s * e, d = f * n + n, p = Math.pow(s, 2) * Math.pow(c, 2) * e, y = Math.exp(-f), g = Df(Math.pow(c, 2), s); return (-i(c) + Sf > 0 ? -1 : 1) * ((d - p) * y) / g }) : (i = c => { let u = Math.exp(-c * e), f = (c - n) * e + 1; return -Sf + u * f }, o = c => { let u = Math.exp(-c * e), f = (n - c) * (e * e); return u * f }); let a = 5 / e, l = lR(i, o, a); if (e = Fn(e), isNaN(l)) return { stiffness: 100, damping: 10, duration: e }; { let c = Math.pow(l, 2) * r; return { stiffness: c, damping: s * 2 * Math.sqrt(r * c), duration: e } } } var aR = 12; function lR(e, t, n) { let r = n; for (let i = 1; i < aR; i++)r = r - e(r) / t(r); return r } function Df(e, t) { return e * Math.sqrt(1 - t * t) } var cR = ["duration", "bounce"], uR = ["stiffness", "damping", "mass"]; function nv(e, t) { return t.some(n => e[n] !== void 0) } function fR(e) { let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }; if (!nv(e, uR) && nv(e, cR)) { let n = sR(e); t = { ...t, ...n, mass: 1 }, t.isResolvedFromDuration = !0 } return t } function As({ keyframes: e, restDelta: t, restSpeed: n, ...r }) { let i = e[0], o = e[e.length - 1], s = { done: !1, value: i }, { stiffness: a, damping: l, mass: c, duration: u, velocity: f, isResolvedFromDuration: d } = fR({ ...r, velocity: -Qn(r.velocity || 0) }), p = f || 0, y = l / (2 * Math.sqrt(a * c)), g = o - i, b = Qn(Math.sqrt(a / c)), h = Math.abs(g) < 5; n || (n = h ? .01 : 2), t || (t = h ? .005 : .5); let m; if (y < 1) { let v = Df(b, y); m = w => { let C = Math.exp(-y * b * w); return o - C * ((p + y * b * g) / v * Math.sin(v * w) + g * Math.cos(v * w)) } } else if (y === 1) m = v => o - Math.exp(-b * v) * (g + (p + b * g) * v); else { let v = b * Math.sqrt(y * y - 1); m = w => { let C = Math.exp(-y * b * w), S = Math.min(v * w, 300); return o - C * ((p + y * b * g) * Math.sinh(S) + v * g * Math.cosh(S)) / v } } return { calculatedDuration: d && u || null, next: v => { let w = m(v); if (d) s.done = v >= u; else { let C = 0; y < 1 && (C = v === 0 ? Fn(p) : By(m, v, w)); let S = Math.abs(C) <= n, R = Math.abs(o - w) <= t; s.done = S && R } return s.value = s.done ? o : w, s } } } var zy = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, dR = 1e-7, hR = 12; function pR(e, t, n, r, i) { let o, s, a = 0; do s = t + (n - t) / 2, o = zy(s, r, i) - e, o > 0 ? n = s : t = s; while (Math.abs(o) > dR && ++a < hR); return s } function bo(e, t, n, r) { if (e === t && n === r) return gt; let i = o => pR(o, 0, 1, e, n); return o => o === 0 || o === 1 ? o : zy(i(o), t, r) } var $y = bo(.42, 0, 1, 1), Ny = bo(0, 0, .58, 1), dd = bo(.42, 0, .58, 1), hd = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, pd = e => t => 1 - e(1 - t), $l = e => 1 - Math.sin(Math.acos(e)), md = pd($l), Hy = hd($l), gd = bo(.33, 1.53, .69, .99), Nl = pd(gd), jy = hd(Nl), Wy = e => (e *= 2) < 1 ? .5 * Nl(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), Wr = (e, t, n) => { let r = t - e; return r === 0 ? 1 : (n - e) / r }, Ie = (e, t, n) => e + (t - e) * n; function kf(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function mR({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let i = 0, o = 0, s = 0; if (!t) i = o = s = n; else { let a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; i = kf(l, a, e + 1 / 3), o = kf(l, a, e), s = kf(l, a, e - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(o * 255), blue: Math.round(s * 255), alpha: r } } function Tl(e, t) { return n => n > 0 ? t : e } var Cf = (e, t, n) => { let r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, gR = [Of, _i, lo], vR = e => gR.find(t => t.test(e)); function rv(e) { let t = vR(e); if (vo(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t) return !1; let n = t.parse(e); return t === lo && (n = mR(n)), n } var iv = (e, t) => { let n = rv(e), r = rv(t); if (!n || !r) return Tl(e, t); let i = { ...n }; return o => (i.red = Cf(n.red, r.red, o), i.green = Cf(n.green, r.green, o), i.blue = Cf(n.blue, r.blue, o), i.alpha = Ie(n.alpha, r.alpha, o), _i.transform(i)) }, Uy = e => t => typeof t == "string" && t.startsWith(e), Gy = Uy("--"), yR = Uy("var(--"), vd = e => yR(e) ? bR.test(e.split("/*")[0].trim()) : !1, bR = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Af = new Set(["none", "hidden"]); function xR(e, t) { return Af.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function wR(e, t) { return n => Ie(e, t, n) } function yd(e) { return typeof e == "number" ? wR : typeof e == "string" ? vd(e) ? Tl : mt.test(e) ? iv : CR : Array.isArray(e) ? qy : typeof e == "object" ? mt.test(e) ? iv : SR : Tl } function qy(e, t) { let n = [...e], r = n.length, i = e.map((o, s) => yd(o)(o, t[s])); return o => { for (let s = 0; s < r; s++)n[s] = i[s](o); return n } } function SR(e, t) { let n = { ...e, ...t }, r = {}; for (let i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = yd(e[i])(e[i], t[i])); return i => { for (let o in r) n[o] = r[o](i); return n } } function kR(e, t) { var n; let r = [], i = { color: 0, var: 0, number: 0 }; for (let o = 0; o < t.values.length; o++) { let s = t.types[o], a = e.indexes[s][i[s]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0; r[o] = l, i[s]++ } return r } var CR = (e, t) => { let n = Sr.createTransformer(t), r = Fs(e), i = Fs(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Af.has(e) && !i.values.length || Af.has(t) && !r.values.length ? xR(e, t) : Kn(qy(kR(r, i), i.values), n) : (vo(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Tl(e, t)) }; function bd(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Ie(e, t, n) : yd(e)(e, t) } function TR(e, t, n) { let r = [], i = n || bd, o = e.length - 1; for (let s = 0; s < o; s++) { let a = i(e[s], e[s + 1]); if (t) { let l = Array.isArray(t) ? t[s] || gt : t; a = Kn(l, a) } r.push(a) } return r } function xo(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) { let o = e.length; if (en(o === t.length, "Both input and output ranges must be the same length"), o === 1) return () => t[0]; if (o === 2 && e[0] === e[1]) return () => t[1]; e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse()); let s = TR(t, r, i), a = s.length, l = c => { let u = 0; if (a > 1) for (; u < e.length - 2 && !(c < e[u + 1]); u++); let f = Wr(e[u], e[u + 1], c); return s[u](f) }; return n ? c => l(wr(e[0], e[o - 1], c)) : l } var ER = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), ov = e => e === yo || e === X, sv = (e, t) => parseFloat(e.split(", ")[t]), av = (e, t) => (n, { transform: r }) => { if (r === "none" || !r) return 0; let i = r.match(/^matrix3d\((.+)\)$/u); if (i) return sv(i[1], t); { let o = r.match(/^matrix\((.+)\)$/u); return o ? sv(o[1], e) : 0 } }, RR = new Set(["x", "y", "z"]), PR = Os.filter(e => !RR.has(e)); function _R(e) { let t = []; return PR.forEach(n => { let r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } var mo = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: av(4, 13), y: av(5, 14) }; mo.translateX = mo.x; mo.translateY = mo.y; var Fi = new Set, Vf = !1, Bf = !1; function Xy() { if (Bf) { let e = Array.from(Fi).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { let i = _R(r); i.length && (n.set(r, i), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); let i = n.get(r); i && i.forEach(([o, s]) => { var a; (a = r.getValue(o)) === null || a === void 0 || a.set(s) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && I.scrollTo(0, r.suspendedScrollY) }) } Bf = !1, Vf = !1, Fi.forEach(e => e.complete()), Fi.clear() } function Yy() { Fi.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Bf = !0) }) } function FR() { Yy(), Xy() } var xd = class { constructor(e, t, n, r, i, o = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = n, this.motionValue = r, this.element = i, this.isAsync = o } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (Fi.add(this), Vf || (Vf = !0, Y.read(Yy), Y.resolveKeyframes(Xy))) : (this.readKeyframes(), this.complete()) } readKeyframes() { let { unresolvedKeyframes: e, name: t, element: n, motionValue: r } = this; for (let i = 0; i < e.length; i++)if (e[i] === null) if (i === 0) { let o = r?.get(), s = e[e.length - 1]; if (o !== void 0) e[0] = o; else if (n && t) { let a = n.readValue(t, s); a != null && (e[0] = a) } e[0] === void 0 && (e[0] = s), r && o === void 0 && r.set(e[0]) } else e[i] = e[i - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Fi.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, Fi.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } }; function lv({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: c = .5, restSpeed: u }) { let f = e[0], d = { done: !1, value: f }, p = E => a !== void 0 && E < a || l !== void 0 && E > l, y = E => a === void 0 ? l : l === void 0 || Math.abs(a - E) < Math.abs(l - E) ? a : l, g = n * t, b = f + g, h = s === void 0 ? b : s(b); h !== b && (g = h - f); let m = E => -g * Math.exp(-E / r), v = E => h + m(E), w = E => { let L = m(E), F = v(E); d.done = Math.abs(L) <= c, d.value = d.done ? h : F }, C, S, R = E => { p(d.value) && (C = E, S = As({ keyframes: [d.value, y(d.value)], velocity: By(v, E, d.value), damping: i, stiffness: o, restDelta: c, restSpeed: u })) }; return R(0), { calculatedDuration: null, next: E => { let L = !1; return !S && C === void 0 && (L = !0, w(E), R(E)), C !== void 0 && E >= C ? S.next(E - C) : (!L && w(E), d) } } } var Ky = e => Array.isArray(e) && typeof e[0] != "number", cv = { linear: gt, easeIn: $y, easeInOut: dd, easeOut: Ny, circIn: $l, circInOut: Hy, circOut: md, backIn: Nl, backInOut: jy, backOut: gd, anticipate: Wy }, zf = e => { if (Array.isArray(e)) { en(e.length === 4, "Cubic bezier arrays must contain four numerical values."); let [t, n, r, i] = e; return bo(t, n, r, i) } else if (typeof e == "string") return en(cv[e] !== void 0, `Invalid easing type '${e}'`), cv[e]; return e }; function Qy(e, t) { let n = e[e.length - 1]; for (let r = 1; r <= t; r++) { let i = Wr(0, t, r); e.push(Ie(n, 1, i)) } } function wd(e) { let t = [0]; return Qy(t, e.length - 1), t } function IR(e, t) { return e.map(n => n * t) } function LR(e, t) { return e.map(() => t || dd).splice(0, e.length - 1) } function El({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { let i = Ky(r) ? r.map(zf) : zf(r), o = { done: !1, value: t[0] }, s = IR(n && n.length === t.length ? n : wd(t), e), a = xo(s, t, { ease: Array.isArray(i) ? i : LR(t, i) }); return { calculatedDuration: e, next: l => (o.value = a(l), o.done = l >= e, o) } } var xl; function MR() { xl = void 0 } var xr = { now: () => (xl === void 0 && xr.set(We.isProcessing || Ol.useManualTiming ? We.timestamp : performance.now()), xl), set: e => { xl = e, queueMicrotask(MR) } }, Rl = { current: !1 }, uv = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (Sr.test(e) || e === "0") && !e.startsWith("url(")); function OR(e) { let t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function DR(e, t, n, r) { let i = e[0]; if (i === null) return !1; if (t === "display" || t === "visibility") return !0; let o = e[e.length - 1], s = uv(i, t), a = uv(o, t); return vo(s === a, `You are trying to animate ${t} from "${i}" to "${o}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${o} via the \`style\` property.`), !s || !a ? !1 : OR(e) || n === "spring" && r } var AR = e => e !== null; function Hl(e, { repeat: t, repeatType: n = "loop" }, r) { let i = e.filter(AR), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !o || r === void 0 ? i[o] : r } var VR = 40, Zy = class { constructor({ autoplay: e = !0, delay: t = 0, type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o = "loop", ...s }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = xr.now(), this.options = { autoplay: e, delay: t, type: n, repeat: r, repeatDelay: i, repeatType: o, ...s }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > VR ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && FR(), this._resolved } onKeyframesResolved(e, t) { this.resolvedAt = xr.now(), this.hasAttemptedResolve = !0; let { name: n, type: r, velocity: i, delay: o, onComplete: s, onUpdate: a, isGenerator: l } = this.options; if (!l && !DR(e, n, r, i)) if (Rl.current || !o) { a?.(Hl(e, this.options, t)), s?.(), this.resolveFinishedPromise(); return } else this.options.duration = 0; let c = this.initPlayback(e, t); c !== !1 && (this._resolved = { keyframes: e, finalKeyframe: t, ...c }, this.onPostResolved()) } onPostResolved() { } then(e, t) { return this.currentFinishedPromise.then(e, t) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(e => { this.resolveFinishedPromise = e }) } }, $f = 2e4; function Jy(e) { let t = 0, n = 50, r = e.next(t); for (; !r.done && t < $f;)t += n, r = e.next(t); return t >= $f ? 1 / 0 : t } var BR = e => { let t = ({ timestamp: n }) => e(n); return { start: () => Y.update(t, !0), stop: () => Dt(t), now: () => We.isProcessing ? We.timestamp : xr.now() } }, zR = { decay: lv, inertia: lv, tween: El, keyframes: El, spring: As }, $R = e => e / 100, jl = class extends Zy { constructor(e) { super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); let { onStop: a } = this.options; a && a() }; let { name: t, motionValue: n, element: r, keyframes: i } = this.options, o = r?.KeyframeResolver || xd, s = (a, l) => this.onKeyframesResolved(a, l); this.resolver = new o(i, s, t, n, r), this.resolver.scheduleResolve() } initPlayback(e) { let { type: t = "keyframes", repeat: n = 0, repeatDelay: r = 0, repeatType: i, velocity: o = 0 } = this.options, s = zR[t] || El, a, l; s !== El && typeof e[0] != "number" && (a = Kn($R, bd(e[0], e[1])), e = [0, 100]); let c = s({ ...this.options, keyframes: e }); i === "mirror" && (l = s({ ...this.options, keyframes: [...e].reverse(), velocity: -o })), c.calculatedDuration === null && (c.calculatedDuration = Jy(c)); let { calculatedDuration: u } = c, f = u + r, d = f * (n + 1) - r; return { generator: c, mirroredGenerator: l, mapPercentToKeyframes: a, calculatedDuration: u, resolvedDuration: f, totalDuration: d } } onPostResolved() { let { autoplay: e = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState } tick(e, t = !1) { let { resolved: n } = this; if (!n) { let { keyframes: R } = this.options; return { done: !0, value: R[R.length - 1] } } let { finalKeyframe: r, generator: i, mirroredGenerator: o, mapPercentToKeyframes: s, keyframes: a, calculatedDuration: l, totalDuration: c, resolvedDuration: u } = n; if (this.startTime === null) return i.next(0); let { delay: f, repeat: d, repeatType: p, repeatDelay: y, onUpdate: g } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - c / this.speed, this.startTime)), t ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; let b = this.currentTime - f * (this.speed >= 0 ? 1 : -1), h = this.speed >= 0 ? b < 0 : b > c; this.currentTime = Math.max(b, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c); let m = this.currentTime, v = i; if (d) { let R = Math.min(this.currentTime, c) / u, E = Math.floor(R), L = R % 1; !L && R >= 1 && (L = 1), L === 1 && E--, E = Math.min(E, d + 1), !!(E % 2) && (p === "reverse" ? (L = 1 - L, y && (L -= y / u)) : p === "mirror" && (v = o)), m = wr(0, 1, L) * u } let w = h ? { done: !1, value: a[0] } : v.next(m); s && (w.value = s(w.value)); let { done: C } = w; !h && l !== null && (C = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); let S = this.holdTime === null && (this.state === "finished" || this.state === "running" && C); return S && r !== void 0 && (w.value = Hl(a, this.options, r)), g && g(w.value), S && this.finish(), w } get duration() { let { resolved: e } = this; return e ? Qn(e.calculatedDuration) : 0 } get time() { return Qn(this.currentTime) } set time(e) { e = Fn(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { let t = this.playbackSpeed !== e; this.playbackSpeed = e, t && (this.time = Qn(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; let { driver: e = BR, onPlay: t, startTime: n } = this.options; this.driver || (this.driver = e(i => this.tick(i))), t && t(); let r = this.driver.now(); this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = r) : this.startTime = n ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; let { onComplete: e } = this.options; e && e() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } }; function Sd(e) { return new jl(e) } var e0 = e => /^0[^.\s]+$/u.test(e); function NR(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || e0(e) : !0 } var t0 = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), HR = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function jR(e) { let t = HR.exec(e); if (!t) return [,]; let [, n, r, i] = t; return [`--${n ?? r}`, i] } var WR = 4; function n0(e, t, n = 1) { en(n <= WR, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`); let [r, i] = jR(e); if (!r) return; let o = I.getComputedStyle(t).getPropertyValue(r); if (o) { let s = o.trim(); return t0(s) ? parseFloat(s) : s } return vd(i) ? n0(i, t, n + 1) : i } var r0 = e => t => t.test(e), UR = { test: e => e === "auto", parse: e => e }, i0 = [yo, X, Xn, Hr, VE, AE, UR], fv = e => i0.find(r0(e)), GR = new Set(["brightness", "contrast", "saturate", "opacity"]); function qR(e) { let [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; let [r] = n.match(sd) || []; if (!r) return e; let i = n.replace(r, ""), o = GR.has(t) ? 1 : 0; return r !== n && (o *= 100), t + "(" + o + i + ")" } var XR = /\b([a-z-]*)\(.*?\)/gu, Nf = { ...Sr, getAnimatableNone: e => { let t = e.match(XR); return t ? t.map(qR).join(" ") : e } }, YR = { ...ad, color: mt, backgroundColor: mt, outlineColor: mt, fill: mt, stroke: mt, borderColor: mt, borderTopColor: mt, borderRightColor: mt, borderBottomColor: mt, borderLeftColor: mt, filter: Nf, WebkitFilter: Nf }, kd = e => YR[e]; function o0(e, t) { let n = kd(e); return n !== Nf && (n = Sr), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } var KR = new Set(["auto", "none", "0"]); function QR(e, t, n) { let r = 0, i; for (; r < e.length && !i;) { let o = e[r]; typeof o == "string" && !KR.has(o) && Fs(o).values.length && (i = e[r]), r++ } if (i && n) for (let o of t) e[o] = o0(n, i) } var s0 = class extends xd { constructor(e, t, n, r, i) { super(e, t, n, r, i, !0) } readKeyframes() { let { unresolvedKeyframes: e, element: t, name: n } = this; if (!t || !t.current) return; super.readKeyframes(); for (let a = 0; a < e.length; a++) { let l = e[a]; if (typeof l == "string" && (l = l.trim(), vd(l))) { let c = n0(l, t.current); c !== void 0 && (e[a] = c), a === e.length - 1 && (this.finalKeyframe = l) } } if (this.resolveNoneKeyframes(), !ER.has(n) || e.length !== 2) return; let [r, i] = e, o = fv(r), s = fv(i); if (o !== s) if (ov(o) && ov(s)) for (let a = 0; a < e.length; a++) { let l = e[a]; typeof l == "string" && (e[a] = parseFloat(l)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { let { unresolvedKeyframes: e, name: t } = this, n = []; for (let r = 0; r < e.length; r++)NR(e[r]) && n.push(r); n.length && QR(e, n, t) } measureInitialState() { let { element: e, unresolvedKeyframes: t, name: n } = this; if (!e || !e.current) return; n === "height" && (this.suspendedScrollY = I.pageYOffset), this.measuredOrigin = mo[n](e.measureViewportBox(), I.getComputedStyle(e.current)), t[0] = this.measuredOrigin; let r = t[t.length - 1]; r !== void 0 && e.getValue(n, r).jump(r, !1) } measureEndState() { var e; let { element: t, name: n, unresolvedKeyframes: r } = this; if (!t || !t.current) return; let i = t.getValue(n); i && i.jump(this.measuredOrigin, !1); let o = r.length - 1, s = r[o]; r[o] = mo[n](t.measureViewportBox(), I.getComputedStyle(t.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([a, l]) => { t.getValue(a).set(l) }), this.resolveNoneKeyframes() } }; function a0(e) { let t; return () => (t === void 0 && (t = e()), t) } var l0 = e => Array.isArray(e) && typeof e[0] == "number"; function c0(e) { return !!(!e || typeof e == "string" && e in Cd || l0(e) || Array.isArray(e) && e.every(c0)) } var bs = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, Cd = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: bs([0, .65, .55, 1]), circOut: bs([.55, 0, 1, .45]), backIn: bs([.31, .01, .66, -.59]), backOut: bs([.33, 1.53, .69, .99]) }; function ZR(e) { return u0(e) || Cd.easeOut } function u0(e) { if (e) return l0(e) ? bs(e) : Array.isArray(e) ? e.map(ZR) : Cd[e] } function JR(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a, times: l } = {}) { let c = { [t]: n }; l && (c.offset = l); let u = u0(a); return Array.isArray(u) && (c.easing = u), e.animate(c, { delay: r, duration: i, easing: Array.isArray(u) ? "linear" : u, fill: "both", iterations: o + 1, direction: s === "reverse" ? "alternate" : "normal" }) } var eP = a0(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Pl = 10, tP = 2e4; function nP(e) { return e.type === "spring" || !c0(e.ease) } function rP(e, t) { let n = new jl({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }), r = { done: !1, value: e[0] }, i = [], o = 0; for (; !r.done && o < tP;)r = n.sample(o), i.push(r.value), o += Pl; return { times: void 0, keyframes: i, duration: o - Pl, ease: "linear" } } var Hf = class extends Zy { constructor(e) { super(e); let { name: t, motionValue: n, element: r, keyframes: i } = this.options; this.resolver = new s0(i, (o, s) => this.onKeyframesResolved(o, s), t, n, r), this.resolver.scheduleResolve() } initPlayback(e, t) { var n; let { duration: r = 300, times: i, ease: o, type: s, motionValue: a, name: l, startTime: c } = this.options; if (!(!((n = a.owner) === null || n === void 0) && n.current)) return !1; if (nP(this.options)) { let { onComplete: f, onUpdate: d, motionValue: p, element: y, ...g } = this.options, b = rP(e, g); e = b.keyframes, e.length === 1 && (e[1] = e[0]), r = b.duration, i = b.times, o = b.ease, s = "keyframes" } let u = JR(a.owner.current, l, e, { ...this.options, duration: r, times: i, ease: o }); return u.startTime = c ?? this.calcStartTime(), this.pendingTimeline ? (u.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : u.onfinish = () => { let { onComplete: f } = this.options; a.set(Hl(e, this.options, t)), f && f(), this.cancel(), this.resolveFinishedPromise() }, { animation: u, duration: r, times: i, type: s, ease: o, keyframes: e } } get duration() { let { resolved: e } = this; if (!e) return 0; let { duration: t } = e; return Qn(t) } get time() { let { resolved: e } = this; if (!e) return 0; let { animation: t } = e; return Qn(t.currentTime || 0) } set time(e) { let { resolved: t } = this; if (!t) return; let { animation: n } = t; n.currentTime = Fn(e) } get speed() { let { resolved: e } = this; if (!e) return 1; let { animation: t } = e; return t.playbackRate } set speed(e) { let { resolved: t } = this; if (!t) return; let { animation: n } = t; n.playbackRate = e } get state() { let { resolved: e } = this; if (!e) return "idle"; let { animation: t } = e; return t.playState } get startTime() { let { resolved: e } = this; if (!e) return null; let { animation: t } = e; return t.startTime } attachTimeline(e) { if (!this._resolved) this.pendingTimeline = e; else { let { resolved: t } = this; if (!t) return gt; let { animation: n } = t; n.timeline = e, n.onfinish = null } return gt } play() { if (this.isStopped) return; let { resolved: e } = this; if (!e) return; let { animation: t } = e; t.playState === "finished" && this.updateFinishedPromise(), t.play() } pause() { let { resolved: e } = this; if (!e) return; let { animation: t } = e; t.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); let { resolved: e } = this; if (!e) return; let { animation: t, keyframes: n, duration: r, type: i, ease: o, times: s } = e; if (t.playState === "idle" || t.playState === "finished") return; if (this.time) { let { motionValue: l, onUpdate: c, onComplete: u, element: f, ...d } = this.options, p = new jl({ ...d, keyframes: n, duration: r, type: i, ease: o, times: s, isGenerator: !0 }), y = Fn(this.time); l.setWithVelocity(p.sample(y - Pl).value, p.sample(y).value, Pl) } let { onStop: a } = this.options; a && a(), this.cancel() } complete() { let { resolved: e } = this; e && e.animation.finish() } cancel() { let { resolved: e } = this; e && e.animation.cancel() } static supports(e) { let { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e; return eP() && n && Ry.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && i !== "mirror" && o !== 0 && s !== "inertia" } }, Td = class { constructor() { this.subscriptions = [] } add(e) { return Vl(this.subscriptions, e), () => Ds(this.subscriptions, e) } notify(e, t, n) { let r = this.subscriptions.length; if (r) if (r === 1) this.subscriptions[0](e, t, n); else for (let i = 0; i < r; i++) { let o = this.subscriptions[i]; o && o(e, t, n) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } }, dv = 30, iP = e => !isNaN(parseFloat(e)), ks = { current: void 0 }, Vs = class { constructor(e, t = {}) { this.version = "11.3.29", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, r = !0) => { let i = xr.now(); this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), r && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = t.owner } setCurrent(e) { this.current = e, this.updatedAt = xr.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = iP(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new Td); let n = this.events[e].add(t); return e === "change" ? () => { n(), Y.read(() => { this.events.change.getSize() || this.stop() }) } : n } clearListeners() { for (let e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e, t = !0) { !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, t, n) { this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n } jump(e, t = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return ks.current && ks.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { let e = xr.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > dv) return 0; let t = Math.min(this.updatedAt - this.prevUpdatedAt, dv); return fd(parseFloat(this.current) - parseFloat(this.prevFrameValue), t) } start(e) { return this.stop(), new Promise(t => { this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } }; function Ue(e, t) { return new Vs(e, t) } function Wl(e, t, n) { let r = e.getProps(); return ld(r, t, n !== void 0 ? n : r.custom, e) } var oP = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, sP = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), aP = { type: "keyframes", duration: .8 }, lP = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, cP = (e, { keyframes: t }) => t.length > 2 ? aP : Gr.has(e) ? e.startsWith("scale") ? sP(t[1]) : oP : lP; function uP({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: c, ...u }) { return !!Object.keys(u).length } function Ed(e, t) { return e[t] || e.default || e } function fP(e, t) { let n, r = () => { let { currentTime: i } = t, s = (i === null ? 0 : i.value) / 100; n !== s && e(s), n = s }; return Y.update(r, !0), () => Dt(r) } var dP = a0(() => I.ScrollTimeline !== void 0), Rd = class { constructor(e) { this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean) } then(e, t) { return Promise.all(this.animations).then(e).catch(t) } getAll(e) { return this.animations[0][e] } setAll(e, t) { for (let n = 0; n < this.animations.length; n++)this.animations[n][e] = t } attachTimeline(e) { let t = this.animations.map(n => { if (dP() && n.attachTimeline) n.attachTimeline(e); else return n.pause(), fP(r => { n.time = n.duration * r }, e) }); return () => { t.forEach((n, r) => { n && n(), this.animations[r].stop() }) } } get time() { return this.getAll("time") } set time(e) { this.setAll("time", e) } get speed() { return this.getAll("speed") } set speed(e) { this.setAll("speed", e) } get startTime() { return this.getAll("startTime") } get duration() { let e = 0; for (let t = 0; t < this.animations.length; t++)e = Math.max(e, this.animations[t].duration); return e } runAll(e) { this.animations.forEach(t => t[e]()) } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } }, Pd = (e, t, n, r = {}, i, o, s) => a => { let l = Ed(r, e) || {}, c = l.delay || r.delay || 0, { elapsed: u = 0 } = r; u = u - Fn(c); let f = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...l, delay: -u, onUpdate: p => { t.set(p), l.onUpdate && l.onUpdate(p) }, onComplete: () => { a(), l.onComplete && l.onComplete(), s && s() }, onStop: s, name: e, motionValue: t, element: o ? void 0 : i }; uP(l) || (f = { ...f, ...cP(e, f) }), f.duration && (f.duration = Fn(f.duration)), f.repeatDelay && (f.repeatDelay = Fn(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from); let d = !1; if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (f.duration = 0, f.delay === 0 && (d = !0)), (Rl.current || Ol.skipAnimations) && (d = !0, f.duration = 0, f.delay = 0), d && !o && t.get() !== void 0) { let p = Hl(f.keyframes, l); if (p !== void 0) return Y.update(() => { f.onUpdate(p), f.onComplete() }), new Rd([]) } return !o && Hf.supports(f) ? new Hf(f) : new jl(f) }; function hP(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ue(n)) } function _d(e, t) { let n = Wl(e, t), { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}; o = { ...o, ...r }; for (let s in o) { let a = HE(o[s]); hP(e, s, a) } } function f0(e) { return e.getProps()[Ml] } var pP = class extends Vs { constructor() { super(...arguments), this.output = [], this.counts = new Map } add(e) { let t = Py(e); if (!t) return; let n = this.counts.get(t) || 0; this.counts.set(t, n + 1), n === 0 && (this.output.push(t), this.update()); let r = !1; return () => { if (r) return; r = !0; let i = this.counts.get(t) - 1; this.counts.set(t, i), i === 0 && (Ds(this.output, t), this.update()) } } update() { this.set(this.output.length ? this.output.join(", ") : "auto") } }; function mP(e) { return !!(De(e) && e.add) } function jf(e, t) { var n; if (!e.applyWillChange) return; let r = e.getValue("willChange"); if (!r && !(!((n = e.props.style) === null || n === void 0) && n.willChange) && (r = new pP("auto"), e.addValue("willChange", r)), mP(r)) return r.add(t) } function gP({ protectedKeys: e, needsAnimating: t }, n) { let r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function Fd(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) { var o; let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t; r && (s = r); let c = [], u = i && e.animationState && e.animationState.getState()[i]; for (let f in l) { let d = e.getValue(f, (o = e.latestValues[f]) !== null && o !== void 0 ? o : null), p = l[f]; if (p === void 0 || u && gP(u, f)) continue; let y = { delay: n, ...Ed(s || {}, f) }, g = !1; if (I.MotionHandoffAnimation) { let h = f0(e); if (h) { let m = I.MotionHandoffAnimation(h, f, Y); m !== null && (y.startTime = m, g = !0) } } d.start(Pd(f, d, p, e.shouldReduceMotion && Gr.has(f) ? { type: !1 } : y, e, g, jf(e, f))); let b = d.animation; b && c.push(b) } return a && Promise.all(c).then(() => { Y.update(() => { a && _d(e, a) }) }), c } function Wf(e, t, n = {}) { var r; let i = Wl(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0), { transition: o = e.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (o = n.transitionOverride); let s = i ? () => Promise.all(Fd(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (c = 0) => { let { delayChildren: u = 0, staggerChildren: f, staggerDirection: d } = o; return vP(e, t, u + c, f, d, n) } : () => Promise.resolve(), { when: l } = o; if (l) { let [c, u] = l === "beforeChildren" ? [s, a] : [a, s]; return c().then(() => u()) } else return Promise.all([s(), a(n.delay)]) } function vP(e, t, n = 0, r = 0, i = 1, o) { let s = [], a = (e.variantChildren.size - 1) * r, l = i === 1 ? (c = 0) => c * r : (c = 0) => a - c * r; return Array.from(e.variantChildren).sort(yP).forEach((c, u) => { c.notify("AnimationStart", t), s.push(Wf(c, t, { ...o, delay: n + l(u) }).then(() => c.notify("AnimationComplete", t))) }), Promise.all(s) } function yP(e, t) { return e.sortNodePosition(t) } function Id(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { let i = t.map(o => Wf(e, o, n)); r = Promise.all(i) } else if (typeof t == "string") r = Wf(e, t, n); else { let i = typeof t == "function" ? Wl(e, t, n.custom) : t; r = Promise.all(Fd(e, i, n)) } return r.then(() => { e.notify("AnimationComplete", t) }) } function d0(e, t) { if (!Array.isArray(t)) return !1; let n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } var bP = [...nd].reverse(), xP = nd.length; function wP(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => Id(e, n, r))) } function SP(e) { let t = wP(e), n = hv(), r = !0, i = l => (c, u) => { var f; let d = Wl(e, u, l === "exit" ? (f = e.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0); if (d) { let { transition: p, transitionEnd: y, ...g } = d; c = { ...c, ...g, ...y } } return c }; function o(l) { t = l(e) } function s(l) { let c = e.getProps(), u = e.getVariantContext(!0) || {}, f = [], d = new Set, p = {}, y = 1 / 0; for (let b = 0; b < xP; b++) { let h = bP[b], m = n[h], v = c[h] !== void 0 ? c[h] : u[h], w = Ps(v), C = h === l ? m.isActive : null; C === !1 && (y = b); let S = v === u[h] && v !== c[h] && w; if (S && r && e.manuallyAnimateOnMount && (S = !1), m.protectedKeys = { ...p }, !m.isActive && C === null || !v && !m.prevProp || _s(v) || typeof v == "boolean") continue; let E = kP(m.prevProp, v) || h === l && m.isActive && !S && w || b > y && w, L = !1, F = Array.isArray(v) ? v : [v], N = F.reduce(i(h), {}); C === !1 && (N = {}); let { prevResolvedValues: A = {} } = m, K = { ...A, ...N }, U = H => { E = !0, d.has(H) && (L = !0, d.delete(H)), m.needsAnimating[H] = !0; let W = e.getValue(H); W && (W.liveStyle = !1) }; for (let H in K) { let W = N[H], ee = A[H]; if (p.hasOwnProperty(H)) continue; let te = !1; Mf(W) && Mf(ee) ? te = !d0(W, ee) : te = W !== ee, te ? W != null ? U(H) : d.add(H) : W !== void 0 && d.has(H) ? U(H) : m.protectedKeys[H] = !0 } m.prevProp = v, m.prevResolvedValues = N, m.isActive && (p = { ...p, ...N }), r && e.blockInitialAnimation && (E = !1), E && (!S || L) && f.push(...F.map(H => ({ animation: H, options: { type: h } }))) } if (d.size) { let b = {}; d.forEach(h => { let m = e.getBaseTarget(h), v = e.getValue(h); v && (v.liveStyle = !0), b[h] = m ?? null }), f.push({ animation: b }) } let g = !!f.length; return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1), r = !1, g ? t(f) : Promise.resolve() } function a(l, c) { var u; if (n[l].isActive === c) return Promise.resolve(); (u = e.variantChildren) === null || u === void 0 || u.forEach(d => { var p; return (p = d.animationState) === null || p === void 0 ? void 0 : p.setActive(l, c) }), n[l].isActive = c; let f = s(l); for (let d in n) n[d].protectedKeys = {}; return f } return { animateChanges: s, setActive: a, setAnimateFunction: o, getState: () => n, reset: () => { n = hv(), r = !0 } } } function kP(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !d0(t, e) : !1 } function Ei(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function hv() { return { animate: Ei(!0), whileInView: Ei(), whileHover: Ei(), whileTap: Ei(), whileDrag: Ei(), whileFocus: Ei(), exit: Ei() } } var qr = class { constructor(e) { this.isMounted = !1, this.node = e } update() { } }, CP = class extends qr { constructor(e) { super(e), e.animationState || (e.animationState = SP(e)) } updateAnimationControlsSubscription() { let { animate: e } = this.node.getProps(); _s(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { let { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { var e; this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this) } }, TP = 0, EP = class extends qr { constructor() { super(...arguments), this.id = TP++ } update() { if (!this.node.presenceContext) return; let { isPresent: e, onExitComplete: t } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === n) return; let r = this.node.animationState.setActive("exit", !e); t && !e && r.then(() => t(this.id)) } mount() { let { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } }, Ul = { animation: { Feature: CP }, exit: { Feature: EP } }, Uf = (e, t) => Math.abs(e - t); function h0(e, t) { let n = Uf(e.x, t.x), r = Uf(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } var p0 = 1e-4, RP = 1 - p0, PP = 1 + p0, m0 = .01, _P = 0 - m0, FP = 0 + m0; function jt(e) { return e.max - e.min } function IP(e, t, n) { return Math.abs(e - t) <= n } function pv(e, t, n, r = .5) { e.origin = r, e.originPoint = Ie(t.min, t.max, e.origin), e.scale = jt(n) / jt(t), e.translate = Ie(n.min, n.max, e.origin) - e.originPoint, (e.scale >= RP && e.scale <= PP || isNaN(e.scale)) && (e.scale = 1), (e.translate >= _P && e.translate <= FP || isNaN(e.translate)) && (e.translate = 0) } function Cs(e, t, n, r) { pv(e.x, t.x, n.x, r ? r.originX : void 0), pv(e.y, t.y, n.y, r ? r.originY : void 0) } function mv(e, t, n) { e.min = n.min + t.min, e.max = e.min + jt(t) } function LP(e, t, n) { mv(e.x, t.x, n.x), mv(e.y, t.y, n.y) } function gv(e, t, n) { e.min = t.min - n.min, e.max = e.min + jt(t) } function Ts(e, t, n) { gv(e.x, t.x, n.x), gv(e.y, t.y, n.y) } var vv = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), co = () => ({ x: vv(), y: vv() }), yv = () => ({ min: 0, max: 0 }), je = () => ({ x: yv(), y: yv() }); function Ld() { let e = V(go); if (e === null) return [!0, null]; let { isPresent: t, onExitComplete: n, register: r } = e, i = Ti(); z(() => r(i), []); let o = se(() => n && n(i), [i, n]); return !t && n ? [!1, o] : [!0] } var MP = (e, t) => e.depth - t.depth, g0 = class { constructor() { this.children = [], this.isDirty = !1 } add(e) { Vl(this.children, e), this.isDirty = !0 } remove(e) { Ds(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(MP), this.isDirty = !1, this.children.forEach(e) } }; function v0(e, t) { let n = xr.now(), r = ({ timestamp: i }) => { let o = i - n; o >= t && (Dt(r), e(o - t)) }; return Y.read(r, !0), () => Dt(r) } var kr = new WeakMap, _l = { current: null }, Md = { current: !1 }; function y0() { if (Md.current = !0, !!Il) if (I.matchMedia) { let e = I.matchMedia("(prefers-reduced-motion)"), t = () => _l.current = e.matches; e.addListener(t), t() } else _l.current = !1 } function OP(e, t, n) { for (let r in t) { let i = t[r], o = n[r]; if (De(i)) e.addValue(r, i); else if (De(o)) e.addValue(r, Ue(i, { owner: e })); else if (o !== i) if (e.hasValue(r)) { let s = e.getValue(r); s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i) } else { let s = e.getStaticValue(r); e.addValue(r, Ue(s !== void 0 ? s : i, { owner: e })) } } for (let r in n) t[r] === void 0 && e.removeValue(r); return t } var DP = [...i0, mt, Sr], AP = e => DP.find(r0(e)), bv = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], VP = rd.length, b0 = class { scrapeMotionValuesFromProps(e, t, n) { return {} } constructor({ parent: e, props: t, presenceContext: n, reducedMotionConfig: r, blockInitialAnimation: i, visualState: o }, s = {}) { this.applyWillChange = !1, this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = xd, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.isRenderScheduled = !1, this.scheduleRender = () => { this.isRenderScheduled || (this.isRenderScheduled = !0, Y.render(this.render, !1, !0)) }; let { latestValues: a, renderState: l } = o; this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = t.initial ? { ...a } : {}, this.renderState = l, this.parent = e, this.props = t, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = s, this.blockInitialAnimation = !!i, this.isControllingVariants = Al(t), this.isVariantNode = xy(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); let { willChange: c, ...u } = this.scrapeMotionValuesFromProps(t, {}, this); for (let f in u) { let d = u[f]; a[f] !== void 0 && De(d) && d.set(a[f], !1) } } mount(e) { this.current = e, kr.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, n) => this.bindToMotionValue(n, t)), Md.current || y0(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : _l.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { kr.delete(this.current), this.projection && this.projection.unmount(), Dt(this.notifyUpdate), Dt(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (let e in this.events) this.events[e].clear(); for (let e in this.features) { let t = this.features[e]; t && (t.unmount(), t.isMounted = !1) } this.current = null } bindToMotionValue(e, t) { let n = Gr.has(e), r = t.on("change", o => { this.latestValues[e] = o, this.props.onUpdate && Y.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0) }), i = t.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, () => { r(), i(), t.owner && t.stop() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } updateFeatures() { let e = "animation"; for (e in ho) { let t = ho[e]; if (!t) continue; let { isEnabled: n, Feature: r } = t; if (!this.features[e] && r && n(this.props) && (this.features[e] = new r(this)), this.features[e]) { let i = this.features[e]; i.isMounted ? i.update() : (i.mount(), i.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : je() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let n = 0; n < bv.length; n++) { let r = bv[n]; this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]); let i = "on" + r, o = e[i]; o && (this.propEventSubscriptions[r] = this.on(r, o)) } this.prevMotionValues = OP(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(e = !1) { if (e) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { let n = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (n.initial = this.props.initial), n } let t = {}; for (let n = 0; n < VP; n++) { let r = rd[n], i = this.props[r]; (Ps(i) || i === !1) && (t[r] = i) } return t } addVariantChild(e) { let t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { let n = this.values.get(e); t !== n && (n && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get()) } removeValue(e) { this.values.delete(e); let t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let n = this.values.get(e); return n === void 0 && t !== void 0 && (n = Ue(t === null ? void 0 : t, { owner: this }), this.addValue(e, n)), n } readValue(e, t) { var n; let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options); return r != null && (typeof r == "string" && (t0(r) || e0(r)) ? r = parseFloat(r) : !AP(r) && Sr.test(t) && (r = o0(e, t)), this.setBaseTarget(e, De(r) ? r.get() : r)), De(r) ? r.get() : r } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; let { initial: n } = this.props, r; if (typeof n == "string" || typeof n == "object") { let o = ld(this.props, n, (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom); o && (r = o[e]) } if (n && r !== void 0) return r; let i = this.getBaseTargetFromProps(this.props, e); return i !== void 0 && !De(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, t) { return this.events[e] || (this.events[e] = new Td), this.events[e].add(t) } notify(e, ...t) { this.events[e] && this.events[e].notify(...t) } }; function x0(e) { function t(r, i = {}) { return wy(e(r, i)) } if (typeof Proxy > "u") return t; let n = new Map; return new Proxy(t, { get: (r, i) => (n.has(i) || n.set(i, t(i)), n.get(i)) }) } var BP = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Od(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(BP.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function w0(e, { layout: t, layoutId: n }) { return Gr.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Cl[e] || e === "opacity") } function Dd(e, t, n) { let { style: r, vars: i, transformOrigin: o } = e, s = !1, a = !1; for (let l in t) { let c = t[l]; if (Gr.has(l)) { s = !0; continue } else if (Gy(l)) { i[l] = c; continue } else { let u = Sy(c, ad[l]); l.startsWith("origin") ? (a = !0, o[l] = u) : r[l] = u } } if (t.transform || (s || n ? r.transform = ky(t, e.transform, n) : r.transform && (r.transform = "none")), a) { let { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = o; r.transformOrigin = `${l} ${c} ${u}` } } var Ad = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function S0(e, t, n) { for (let r in t) !De(t[r]) && !w0(r, n) && (e[r] = t[r]) } function zP({ transformTemplate: e }, t) { return ae(() => { let n = Ad(); return Dd(n, t, e), Object.assign({}, n.vars, n.style) }, [t]) } function $P(e, t) { let n = e.style || {}, r = {}; return S0(r, n, e), Object.assign(r, zP(e, t)), r } function NP(e, t) { let n = {}, r = $P(e, t); return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } function xv(e, t, n) { return typeof e == "string" ? e : X.transform(t + n * e) } function HP(e, t, n) { let r = xv(t, e.x, e.width), i = xv(n, e.y, e.height); return `${r} ${i}` } var jP = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, WP = { offset: "strokeDashoffset", array: "strokeDasharray" }; function UP(e, t, n = 1, r = 0, i = !0) { e.pathLength = 1; let o = i ? jP : WP; e[o.offset] = X.transform(-r); let s = X.transform(t), a = X.transform(n); e[o.array] = `${s} ${a}` } function Vd(e, { attrX: t, attrY: n, attrScale: r, originX: i, originY: o, pathLength: s, pathSpacing: a = 1, pathOffset: l = 0, ...c }, u, f) { if (Dd(e, c, f), u) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; let { attrs: d, style: p, dimensions: y } = e; d.transform && (y && (p.transform = d.transform), delete d.transform), y && (i !== void 0 || o !== void 0 || p.transform) && (p.transformOrigin = HP(y, i !== void 0 ? i : .5, o !== void 0 ? o : .5)), t !== void 0 && (d.x = t), n !== void 0 && (d.y = n), r !== void 0 && (d.scale = r), s !== void 0 && UP(d, s, a, l, !1) } var k0 = () => ({ ...Ad(), attrs: {} }), Bd = e => typeof e == "string" && e.toLowerCase() === "svg"; function GP(e, t, n, r) { let i = ae(() => { let o = k0(); return Vd(o, t, Bd(r), e.transformTemplate), { ...o.attrs, style: { ...o.style } } }, [t]); if (e.style) { let o = {}; S0(o, e.style, e), i.style = { ...o, ...i.style } } return i } function qP(e = !1) { return (n, r, i, { latestValues: o }, s) => { let l = (Od(n) ? GP : NP)(r, o, s, n), c = Ey(r, typeof n == "string", e), u = n !== gr ? { ...c, ...l, ref: i } : {}, { children: f } = r, d = ae(() => De(f) ? f.get() : f, [f]); return ml(n, { ...u, children: d }) } } function C0(e, { style: t, vars: n }, r, i) { Object.assign(e.style, t, i && i.getProjectionStyles(r)); for (let o in n) e.style.setProperty(o, n[o]) } var T0 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function E0(e, t, n, r) { C0(e, t, void 0, r); for (let i in t.attrs) e.setAttribute(T0.has(i) ? i : Ll(i), t.attrs[i]) } function zd(e, t, n) { var r; let { style: i } = e, o = {}; for (let s in i) (De(i[s]) || t.style && De(t.style[s]) || w0(s, e) || ((r = n?.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]); return n && i && typeof i.willChange == "string" && (n.applyWillChange = !1), o } function R0(e, t, n) { let r = zd(e, t, n); for (let i in e) if (De(e[i]) || De(t[i])) { let o = Os.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[o] = e[i] } return r } var XP = { useVisualState: Bl({ scrapeMotionValuesFromProps: R0, createRenderState: k0, onMount: (e, t, { renderState: n, latestValues: r }) => { Y.read(() => { try { n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), Y.render(() => { Vd(n, r, Bd(t.tagName), e.transformTemplate), E0(t, n) }) } }) }, YP = { useVisualState: Bl({ applyWillChange: !0, scrapeMotionValuesFromProps: zd, createRenderState: Ad }) }; function P0(e, { forwardMotionProps: t = !1 }, n, r) { return { ...Od(e) ? XP : YP, preloadedFeatures: n, useRender: qP(t), createVisualElement: r, Component: e } } function wv(e, t) { let n = t ? "pointerenter" : "pointerleave", r = t ? "onHoverStart" : "onHoverEnd", i = (o, s) => { if (o.pointerType === "touch" || cd()) return; let a = e.getProps(); e.animationState && a.whileHover && e.animationState.setActive("whileHover", t); let l = a[r]; l && Y.postRender(() => l(o, s)) }; return Yn(e.current, n, i, { passive: !e.getProps()[r] }) } var KP = class extends qr { mount() { this.unmount = Kn(wv(this.node, !0), wv(this.node, !1)) } unmount() { } }, QP = class extends qr { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Kn(br(this.node.current, "focus", () => this.onFocus()), br(this.node.current, "blur", () => this.onBlur())) } unmount() { } }, _0 = (e, t) => t ? e === t ? !0 : _0(e, t.parentElement) : !1; function Tf(e, t) { if (!t) return; let n = new PointerEvent("pointer" + e); t(n, zl(n)) } var ZP = class extends qr { constructor() { super(...arguments), this.removeStartListeners = gt, this.removeEndListeners = gt, this.removeAccessibleListeners = gt, this.startPointerPress = (e, t) => { if (this.isPressing) return; this.removeEndListeners(); let n = this.node.getProps(), i = Yn(I, "pointerup", (s, a) => { if (!this.checkPressEnd()) return; let { onTap: l, onTapCancel: c, globalTapTarget: u } = this.node.getProps(), f = !u && !_0(this.node.current, s.target) ? c : l; f && Y.update(() => f(s, a)) }, { passive: !(n.onTap || n.onPointerUp) }), o = Yn(I, "pointercancel", (s, a) => this.cancelPress(s, a), { passive: !(n.onTapCancel || n.onPointerCancel) }); this.removeEndListeners = Kn(i, o), this.startPress(e, t) }, this.startAccessiblePress = () => { let e = i => { if (i.key !== "Enter" || this.isPressing) return; let o = s => { s.key !== "Enter" || !this.checkPressEnd() || Tf("up", (a, l) => { let { onTap: c } = this.node.getProps(); c && Y.postRender(() => c(a, l)) }) }; this.removeEndListeners(), this.removeEndListeners = br(this.node.current, "keyup", o), Tf("down", (s, a) => { this.startPress(s, a) }) }, t = br(this.node.current, "keydown", e), n = () => { this.isPressing && Tf("cancel", (i, o) => this.cancelPress(i, o)) }, r = br(this.node.current, "blur", n); this.removeAccessibleListeners = Kn(t, r) } } startPress(e, t) { this.isPressing = !0; let { onTapStart: n, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Y.postRender(() => n(e, t)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !cd() } cancelPress(e, t) { if (!this.checkPressEnd()) return; let { onTapCancel: n } = this.node.getProps(); n && Y.postRender(() => n(e, t)) } mount() { let e = this.node.getProps(), t = Yn(e.globalTapTarget ? I : this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), n = br(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = Kn(t, n) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } }, Gf = new WeakMap, Ef = new WeakMap, JP = e => { let t = Gf.get(e.target); t && t(e) }, e_ = e => { e.forEach(JP) }; function t_({ root: e, ...t }) { let n = e || document; Ef.has(n) || Ef.set(n, {}); let r = Ef.get(n), i = JSON.stringify(t); return r[i] || (r[i] = new IntersectionObserver(e_, { root: e, ...t })), r[i] } function n_(e, t, n) { let r = t_(t); return Gf.set(e, n), r.observe(e), () => { Gf.delete(e), r.unobserve(e) } } var r_ = { some: 0, all: 1 }, i_ = class extends qr { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); let { viewport: e = {} } = this.node.getProps(), { root: t, margin: n, amount: r = "some", once: i } = e, o = { root: t ? t.current : void 0, rootMargin: n, threshold: typeof r == "number" ? r : r_[r] }, s = a => { let { isIntersecting: l } = a; if (this.isInView === l || (this.isInView = l, i && !l && this.hasEnteredView)) return; l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l); let { onViewportEnter: c, onViewportLeave: u } = this.node.getProps(), f = l ? c : u; f && f(a) }; return n_(this.node.current, o, s) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; let { props: e, prevProps: t } = this.node;["amount", "margin", "root"].some(o_(e, t)) && this.startObserver() } unmount() { } }; function o_({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } var F0 = { inView: { Feature: i_ }, tap: { Feature: ZP }, focus: { Feature: QP }, hover: { Feature: KP } }, I0 = class { constructor(e, t, { transformPagePoint: n, contextWindow: r, dragSnapToOrigin: i = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = I, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; let u = Pf(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, d = h0(u.offset, { x: 0, y: 0 }) >= 3; if (!f && !d) return; let { point: p } = u, { timestamp: y } = We; this.history.push({ ...p, timestamp: y }); let { onStart: g, onMove: b } = this.handlers; f || (g && g(this.lastMoveEvent, u), this.startEvent = this.lastMoveEvent), b && b(this.lastMoveEvent, u) }, this.handlePointerMove = (u, f) => { this.lastMoveEvent = u, this.lastMoveEventInfo = Rf(f, this.transformPagePoint), Y.update(this.updatePoint, !0) }, this.handlePointerUp = (u, f) => { this.end(); let { onEnd: d, onSessionEnd: p, resumeAnimation: y } = this.handlers; if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; let g = Pf(u.type === "pointercancel" ? this.lastMoveEventInfo : Rf(f, this.transformPagePoint), this.history); this.startEvent && d && d(u, g), p && p(u, g) }, !_y(e)) return; this.dragSnapToOrigin = i, this.handlers = t, this.transformPagePoint = n, this.contextWindow = r || I; let o = zl(e), s = Rf(o, this.transformPagePoint), { point: a } = s, { timestamp: l } = We; this.history = [{ ...a, timestamp: l }]; let { onSessionStart: c } = t; c && c(e, Pf(s, this.history)), this.removeListeners = Kn(Yn(this.contextWindow, "pointermove", this.handlePointerMove), Yn(this.contextWindow, "pointerup", this.handlePointerUp), Yn(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), Dt(this.updatePoint) } }; function Rf(e, t) { return t ? { point: t(e.point) } : e } function Sv(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function Pf({ point: e }, t) { return { point: e, delta: Sv(e, L0(t)), offset: Sv(e, s_(t)), velocity: a_(t, .1) } } function s_(e) { return e[0] } function L0(e) { return e[e.length - 1] } function a_(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null, i = L0(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Fn(t)));)n--; if (!r) return { x: 0, y: 0 }; let o = Qn(i.timestamp - r.timestamp); if (o === 0) return { x: 0, y: 0 }; let s = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function l_(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? Ie(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Ie(n, e, r.max) : Math.min(e, n)), e } function kv(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function c_(e, { top: t, left: n, bottom: r, right: i }) { return { x: kv(e.x, n, i), y: kv(e.y, t, r) } } function Cv(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function u_(e, t) { return { x: Cv(e.x, t.x), y: Cv(e.y, t.y) } } function f_(e, t) { let n = .5, r = jt(e), i = jt(t); return i > r ? n = Wr(t.min, t.max - r, e.min) : r > i && (n = Wr(e.min, e.max - i, t.min)), wr(0, 1, n) } function d_(e, t) { let n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } var qf = .35; function h_(e = qf) { return e === !1 ? e = 0 : e === !0 && (e = qf), { x: Tv(e, "left", "right"), y: Tv(e, "top", "bottom") } } function Tv(e, t, n) { return { min: Ev(e, t), max: Ev(e, n) } } function Ev(e, t) { return typeof e == "number" ? e : e[t] || 0 } function mn(e) { return [e("x"), e("y")] } function M0({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function p_({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function m_(e, t) { if (!t) return e; let n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function _f(e) { return e === void 0 || e === 1 } function Xf({ scale: e, scaleX: t, scaleY: n }) { return !_f(e) || !_f(t) || !_f(n) } function Ri(e) { return Xf(e) || O0(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function O0(e) { return Rv(e.x) || Rv(e.y) } function Rv(e) { return e && e !== "0%" } function Fl(e, t, n) { let r = e - n, i = t * r; return n + i } function Pv(e, t, n, r, i) { return i !== void 0 && (e = Fl(e, i, r)), Fl(e, n, r) + t } function Yf(e, t = 0, n = 1, r, i) { e.min = Pv(e.min, t, n, r, i), e.max = Pv(e.max, t, n, r, i) } function D0(e, { x: t, y: n }) { Yf(e.x, t.translate, t.scale, t.originPoint), Yf(e.y, n.translate, n.scale, n.originPoint) } var _v = .999999999999, Fv = 1.0000000000001; function g_(e, t, n, r = !1) { let i = n.length; if (!i) return; t.x = t.y = 1; let o, s; for (let a = 0; a < i; a++) { o = n[a], s = o.projectionDelta; let { visualElement: l } = o.options; l && l.props.style && l.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && fo(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }), s && (t.x *= s.x.scale, t.y *= s.y.scale, D0(e, s)), r && Ri(o.latestValues) && fo(e, o.latestValues)) } t.x < Fv && t.x > _v && (t.x = 1), t.y < Fv && t.y > _v && (t.y = 1) } function uo(e, t) { e.min = e.min + t, e.max = e.max + t } function Iv(e, t, n, r, i = .5) { let o = Ie(e.min, e.max, i); Yf(e, t, n, o, r) } function fo(e, t) { Iv(e.x, t.x, t.scaleX, t.scale, t.originX), Iv(e.y, t.y, t.scaleY, t.scale, t.originY) } function A0(e, t) { return M0(m_(e.getBoundingClientRect(), t)) } function v_(e, t, n) { let r = A0(e, n), { scroll: i } = t; return i && (uo(r.x, i.offset.x), uo(r.y, i.offset.y)), r } var V0 = ({ current: e }) => e ? e.ownerDocument.defaultView : null, y_ = new WeakMap, b_ = class { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = je(), this.visualElement = e } start(e, { snapToCursor: t = !1 } = {}) { let { presenceContext: n } = this.visualElement; if (n && n.isPresent === !1) return; let r = c => { let { dragSnapToOrigin: u } = this.getProps(); u ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(zl(c, "page").point) }, i = (c, u) => { var f; let { drag: d, dragPropagation: p, onDragStart: y } = this.getProps(); if (d && !p && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Ly(d), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), mn(b => { let h = this.getAxisMotionValue(b).get() || 0; if (Xn.test(h)) { let { projection: m } = this.visualElement; if (m && m.layout) { let v = m.layout.layoutBox[b]; v && (h = jt(v) * (parseFloat(h) / 100)) } } this.originPoint[b] = h }), y && Y.postRender(() => y(c, u)), (f = this.removeWillChange) === null || f === void 0 || f.call(this), this.removeWillChange = jf(this.visualElement, "transform"); let { animationState: g } = this.visualElement; g && g.setActive("whileDrag", !0) }, o = (c, u) => { let { dragPropagation: f, dragDirectionLock: d, onDirectionLock: p, onDrag: y } = this.getProps(); if (!f && !this.openGlobalLock) return; let { offset: g } = u; if (d && this.currentDirection === null) { this.currentDirection = x_(g), this.currentDirection !== null && p && p(this.currentDirection); return } this.updateAxis("x", u.point, g), this.updateAxis("y", u.point, g), this.visualElement.render(), y && y(c, u) }, s = (c, u) => this.stop(c, u), a = () => mn(c => { var u; return this.getAnimationState(c) === "paused" && ((u = this.getAxisMotionValue(c).animation) === null || u === void 0 ? void 0 : u.play()) }), { dragSnapToOrigin: l } = this.getProps(); this.panSession = new I0(e, { onSessionStart: r, onStart: i, onMove: o, onSessionEnd: s, resumeAnimation: a }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: l, contextWindow: V0(this.visualElement) }) } stop(e, t) { var n; (n = this.removeWillChange) === null || n === void 0 || n.call(this); let r = this.isDragging; if (this.cancel(), !r) return; let { velocity: i } = t; this.startAnimation(i); let { onDragEnd: o } = this.getProps(); o && Y.postRender(() => o(e, t)) } cancel() { this.isDragging = !1; let { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; let { dragPropagation: n } = this.getProps(); !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, n) { let { drag: r } = this.getProps(); if (!n || !vl(e, r, this.currentDirection)) return; let i = this.getAxisMotionValue(e), o = this.originPoint[e] + n[e]; this.constraints && this.constraints[e] && (o = l_(o, this.constraints[e], this.elastic[e])), i.set(o) } resolveConstraints() { var e; let { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, i = this.constraints; t && ao(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = c_(r.layoutBox, t) : this.constraints = !1, this.elastic = h_(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && mn(o => { this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = d_(r.layoutBox[o], this.constraints[o])) }) } resolveRefConstraints() { let { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps(); if (!e || !ao(e)) return !1; let n = e.current; en(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."); let { projection: r } = this.visualElement; if (!r || !r.layout) return !1; let i = v_(n, r.root, this.visualElement.getTransformPagePoint()), o = u_(r.layout.layoutBox, i); if (t) { let s = t(p_(o)); this.hasMutatedConstraints = !!s, s && (o = M0(s)) } return o } startAnimation(e) { let { drag: t, dragMomentum: n, dragElastic: r, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: s } = this.getProps(), a = this.constraints || {}, l = mn(c => { if (!vl(c, t, this.currentDirection)) return; let u = a && a[c] || {}; o && (u = { min: 0, max: 0 }); let f = r ? 200 : 1e6, d = r ? 40 : 1e7, p = { type: "inertia", velocity: n ? e[c] : 0, bounceStiffness: f, bounceDamping: d, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...u }; return this.startAxisValueAnimation(c, p) }); return Promise.all(l).then(s) } startAxisValueAnimation(e, t) { let n = this.getAxisMotionValue(e); return n.start(Pd(e, n, 0, t, this.visualElement, !1, jf(this.visualElement, e))) } stopAnimation() { mn(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { mn(e => { var t; return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.pause() }) } getAnimationState(e) { var t; return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.state } getAxisMotionValue(e) { let t = `_drag${e.toUpperCase()}`, n = this.visualElement.getProps(), r = n[t]; return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0) } snapToCursor(e) { mn(t => { let { drag: n } = this.getProps(); if (!vl(t, n, this.currentDirection)) return; let { projection: r } = this.visualElement, i = this.getAxisMotionValue(t); if (r && r.layout) { let { min: o, max: s } = r.layout.layoutBox[t]; i.set(e[t] - Ie(o, s, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; let { drag: e, dragConstraints: t } = this.getProps(), { projection: n } = this.visualElement; if (!ao(t) || !n || !this.constraints) return; this.stopAnimation(); let r = { x: 0, y: 0 }; mn(o => { let s = this.getAxisMotionValue(o); if (s && this.constraints !== !1) { let a = s.get(); r[o] = f_({ min: a, max: a }, this.constraints[o]) } }); let { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), mn(o => { if (!vl(o, e, null)) return; let s = this.getAxisMotionValue(o), { min: a, max: l } = this.constraints[o]; s.set(Ie(a, l, r[o])) }) } addListeners() { if (!this.visualElement.current) return; y_.set(this.visualElement, this); let e = this.visualElement.current, t = Yn(e, "pointerdown", a => { let { drag: l, dragListener: c = !0 } = this.getProps(); l && c && this.start(a) }), n = () => { let { dragConstraints: a } = this.getProps(); ao(a) && a.current && (this.constraints = this.resolveRefConstraints()) }, { projection: r } = this.visualElement, i = r.addEventListener("measure", n); r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), Y.read(n); let o = br(I, "resize", () => this.scalePositionWithinConstraints()), s = r.addEventListener("didUpdate", ({ delta: a, hasLayoutChanged: l }) => { this.isDragging && l && (mn(c => { let u = this.getAxisMotionValue(c); u && (this.originPoint[c] += a[c].translate, u.set(u.get() + a[c].translate)) }), this.visualElement.render()) }); return () => { o(), t(), i(), s && s() } } getProps() { let e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: n = !1, dragPropagation: r = !1, dragConstraints: i = !1, dragElastic: o = qf, dragMomentum: s = !0 } = e; return { ...e, drag: t, dragDirectionLock: n, dragPropagation: r, dragConstraints: i, dragElastic: o, dragMomentum: s } } }; function vl(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function x_(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } var w_ = class extends qr { constructor(e) { super(e), this.removeGroupControls = gt, this.removeListeners = gt, this.controls = new b_(e) } mount() { let { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || gt } unmount() { this.removeGroupControls(), this.removeListeners() } }, Lv = e => (t, n) => { e && Y.postRender(() => e(t, n)) }, S_ = class extends qr { constructor() { super(...arguments), this.removePointerDownListener = gt } onPointerDown(e) { this.session = new I0(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: V0(this.node) }) } createPanHandlers() { let { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps(); return { onSessionStart: Lv(e), onStart: Lv(t), onMove: n, onEnd: (i, o) => { delete this.session, r && Y.postRender(() => r(i, o)) } } } mount() { this.removePointerDownListener = Yn(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } }, wl = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Mv(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } var gs = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (X.test(e)) e = parseFloat(e); else return e; let n = Mv(e, t.target.x), r = Mv(e, t.target.y); return `${n}% ${r}%` } }, k_ = { correct: (e, { treeScale: t, projectionDelta: n }) => { let r = e, i = Sr.parse(e); if (i.length > 5) return r; let o = Sr.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; i[0 + s] /= a, i[1 + s] /= l; let c = Ie(a, l, .5); return typeof i[2 + s] == "number" && (i[2 + s] /= c), typeof i[3 + s] == "number" && (i[3 + s] /= c), o(i) } }, C_ = class extends Re { componentDidMount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props, { projection: i } = e; od(T_), i && (t.group && t.group.add(i), n && n.register && r && n.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => { this.safeToRemove() }), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), wl.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { let { layoutDependency: t, visualElement: n, drag: r, isPresent: i } = this.props, o = n.projection; return o && (o.isPresent = i, r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? o.promote() : o.relegate() || Y.postRender(() => { let s = o.getStack(); (!s || !s.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { let { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), td.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), n && n.deregister && n.deregister(r)) } safeToRemove() { let { safeToRemove: e } = this.props; e && e() } render() { return null } }; function B0(e) { let [t, n] = Ld(), r = V(Rs); return k(C_, { ...e, layoutGroup: r, switchLayoutGroup: V(Dl), isPresent: t, safeToRemove: n }) } var T_ = { borderRadius: { ...gs, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: gs, borderTopRightRadius: gs, borderBottomLeftRadius: gs, borderBottomRightRadius: gs, boxShadow: k_ }, z0 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], E_ = z0.length, Ov = e => typeof e == "string" ? parseFloat(e) : e, Dv = e => typeof e == "number" || X.test(e); function R_(e, t, n, r, i, o) { i ? (e.opacity = Ie(0, n.opacity !== void 0 ? n.opacity : 1, P_(r)), e.opacityExit = Ie(t.opacity !== void 0 ? t.opacity : 1, 0, __(r))) : o && (e.opacity = Ie(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let s = 0; s < E_; s++) { let a = `border${z0[s]}Radius`, l = Av(t, a), c = Av(n, a); if (l === void 0 && c === void 0) continue; l || (l = 0), c || (c = 0), l === 0 || c === 0 || Dv(l) === Dv(c) ? (e[a] = Math.max(Ie(Ov(l), Ov(c), r), 0), (Xn.test(c) || Xn.test(l)) && (e[a] += "%")) : e[a] = c } (t.rotate || n.rotate) && (e.rotate = Ie(t.rotate || 0, n.rotate || 0, r)) } function Av(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } var P_ = $0(0, .5, md), __ = $0(.5, .95, gt); function $0(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(Wr(e, t, r)) } function Vv(e, t) { e.min = t.min, e.max = t.max } function pn(e, t) { Vv(e.x, t.x), Vv(e.y, t.y) } function Bv(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function zv(e, t, n, r, i) { return e -= t, e = Fl(e, 1 / n, r), i !== void 0 && (e = Fl(e, 1 / i, r)), e } function F_(e, t = 0, n = 1, r = .5, i, o = e, s = e) { if (Xn.test(t) && (t = parseFloat(t), t = Ie(s.min, s.max, t / 100) - s.min), typeof t != "number") return; let a = Ie(o.min, o.max, r); e === o && (a -= t), e.min = zv(e.min, t, n, a, i), e.max = zv(e.max, t, n, a, i) } function $v(e, t, [n, r, i], o, s) { F_(e, t[n], t[r], t[i], t.scale, o, s) } var I_ = ["x", "scaleX", "originX"], L_ = ["y", "scaleY", "originY"]; function Nv(e, t, n, r) { $v(e.x, t, I_, n ? n.x : void 0, r ? r.x : void 0), $v(e.y, t, L_, n ? n.y : void 0, r ? r.y : void 0) } function Hv(e) { return e.translate === 0 && e.scale === 1 } function N0(e) { return Hv(e.x) && Hv(e.y) } function jv(e, t) { return e.min === t.min && e.max === t.max } function M_(e, t) { return jv(e.x, t.x) && jv(e.y, t.y) } function Wv(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function H0(e, t) { return Wv(e.x, t.x) && Wv(e.y, t.y) } function Uv(e) { return jt(e.x) / jt(e.y) } function Gv(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } var O_ = class { constructor() { this.members = [] } add(e) { Vl(this.members, e), e.scheduleRender() } remove(e) { if (Ds(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { let t = this.members[this.members.length - 1]; t && this.promote(t) } } relegate(e) { let t = this.members.findIndex(r => e === r); if (t === 0) return !1; let n; for (let r = t; r >= 0; r--) { let i = this.members[r]; if (i.isPresent !== !1) { n = i; break } } return n ? (this.promote(n), !0) : !1 } promote(e, t) { let n = this.lead; if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) { n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, t && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); let { crossfade: r } = e.options; r === !1 && n.hide() } } exitAnimationComplete() { this.members.forEach(e => { let { options: t, resumingFrom: n } = e; t.onExitComplete && t.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } }; function D_(e, t, n) { let r = "", i = e.x.translate / t.x, o = e.y.translate / t.y, s = n?.z || 0; if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { let { transformPerspective: c, rotate: u, rotateX: f, rotateY: d, skewX: p, skewY: y } = n; c && (r = `perspective(${c}px) ${r}`), u && (r += `rotate(${u}deg) `), f && (r += `rotateX(${f}deg) `), d && (r += `rotateY(${d}deg) `), p && (r += `skewX(${p}deg) `), y && (r += `skewY(${y}deg) `) } let a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } function j0(e) { return e instanceof SVGElement && e.tagName !== "svg" } function $d(e, t, n) { let r = De(e) ? e : Ue(e); return r.start(Pd("", r, t, n)), r.animation } var Pi = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, xs = typeof I < "u" && I.MotionDebug !== void 0, Ff = ["", "X", "Y", "Z"], A_ = { visibility: "hidden" }, qv = 1e3, V_ = 0; function If(e, t, n, r) { let { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function W0(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; let { visualElement: t } = e.options; if (!t) return; let n = f0(t); I.MotionHasOptimisedTransformAnimation(n) && I.MotionCancelOptimisedTransform(n); let { parent: r } = e; r && !r.hasCheckedOptimisedAppear && W0(r) } function U0({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(s = {}, a = t?.()) { this.id = V_++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, xs && (Pi.totalNodes = Pi.resolvedTargetDeltas = Pi.recalculatedProjection = 0), this.nodes.forEach($_), this.nodes.forEach(U_), this.nodes.forEach(G_), this.nodes.forEach(N_), xs && I.MotionDebug.record(Pi) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new g0) } addEventListener(s, a) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new Td), this.eventHandlers.get(s).add(a) } notifyListeners(s, ...a) { let l = this.eventHandlers.get(s); l && l.notify(...a) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s, a = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = j0(s), this.instance = s; let { layoutId: l, layout: c, visualElement: u } = this.options; if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), e) { let f, d = () => this.root.updateBlockedByResize = !1; e(s, () => { this.root.updateBlockedByResize = !0, f && f(), f = v0(d, 250), wl.hasAnimatedSinceResize && (wl.hasAnimatedSinceResize = !1, this.nodes.forEach(Yv)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: d, hasRelativeTargetChanged: p, layout: y }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } let g = this.options.transition || u.getDefaultTransition() || Q_, { onLayoutAnimationStart: b, onLayoutAnimationComplete: h } = u.getProps(), m = !this.targetLayout || !H0(this.targetLayout, y) || p, v = !d && p; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || v || d && (m || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, v); let w = { ...Ed(g, "layout"), onPlay: b, onComplete: h }; (u.shouldReduceMotion || this.options.layoutRoot) && (w.delay = 0, w.type = !1), this.startAnimation(w) } else d || Yv(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = y }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); let s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Dt(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(q_), this.animationId++) } getTransformTemplate() { let { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (I.MotionCancelOptimisedTransform && !this.hasCheckedOptimisedAppear && W0(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let u = 0; u < this.path.length; u++) { let f = this.path[u]; f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1) } let { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; let c = this.getTransformTemplate(); this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Xv); return } this.isUpdating || this.nodes.forEach(j_), this.isUpdating = !1, this.nodes.forEach(W_), this.nodes.forEach(B_), this.nodes.forEach(z_), this.clearAllSnapshots(); let a = xr.now(); We.delta = wr(0, 1e3 / 60, a - We.timestamp), We.timestamp = a, We.isProcessing = !0, bl.update.process(We), bl.preRender.process(We), bl.render.process(We), We.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, td.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(H_), this.sharedNodes.forEach(X_) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Y.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Y.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); let s = this.layout; this.layout = this.measure(!1), this.layoutCorrected = je(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); let { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let a = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a) { let l = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: s, isRoot: l, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!i) return; let s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !N0(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue; s && (a || Ri(this.latestValues) || u) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { let a = this.measurePageBox(), l = this.removeElementScroll(a); return s && (l = this.removeTransform(l)), Z_(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var s; let { visualElement: a } = this.options; if (!a) return je(); let l = a.measureViewportBox(); if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(J_))) { let { scroll: u } = this.root; u && (uo(l.x, u.offset.x), uo(l.y, u.offset.y)) } return l } removeElementScroll(s) { var a; let l = je(); if (pn(l, s), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return l; for (let c = 0; c < this.path.length; c++) { let u = this.path[c], { scroll: f, options: d } = u; u !== this.root && f && d.layoutScroll && (f.wasRoot && pn(l, s), uo(l.x, f.offset.x), uo(l.y, f.offset.y)) } return l } applyTransform(s, a = !1) { let l = je(); pn(l, s); for (let c = 0; c < this.path.length; c++) { let u = this.path[c]; !a && u.options.layoutScroll && u.scroll && u !== u.root && fo(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }), Ri(u.latestValues) && fo(l, u.latestValues) } return Ri(this.latestValues) && fo(l, this.latestValues), l } removeTransform(s) { let a = je(); pn(a, s); for (let l = 0; l < this.path.length; l++) { let c = this.path[l]; if (!c.instance || !Ri(c.latestValues)) continue; Xf(c.latestValues) && c.updateSnapshot(); let u = je(), f = c.measurePageBox(); pn(u, f), Nv(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u) } return Ri(this.latestValues) && Nv(a, this.latestValues), a } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== We.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { var a; let l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); let c = !!this.resumingFrom || this !== l; if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; let { layout: f, layoutId: d } = this.options; if (!(!this.layout || !(f || d))) { if (this.resolvedRelativeTargetAt = We.timestamp, !this.targetDelta && !this.relativeTarget) { let p = this.getClosestProjectingParent(); p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = je(), this.relativeTargetOrigin = je(), Ts(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), pn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = je(), this.targetWithTransforms = je()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), LP(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : pn(this.target, this.layout.layoutBox), D0(this.target, this.targetDelta)) : pn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; let p = this.getClosestProjectingParent(); p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = je(), this.relativeTargetOrigin = je(), Ts(this.relativeTargetOrigin, this.target, p.target), pn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } xs && Pi.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || Xf(this.parent.latestValues) || O0(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var s; let a = this.getLead(), l = !!this.resumingFrom || this !== a, c = !0; if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === We.timestamp && (c = !1), c) return; let { layout: u, layoutId: f } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f)) return; pn(this.layoutCorrected, this.layout.layoutBox); let d = this.treeScale.x, p = this.treeScale.y; g_(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = je()); let { target: y } = a; if (!y) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Bv(this.prevProjectionDelta.x, this.projectionDelta.x), Bv(this.prevProjectionDelta.y, this.projectionDelta.y)), Cs(this.projectionDelta, this.layoutCorrected, y, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== p || !Gv(this.projectionDelta.x, this.prevProjectionDelta.x) || !Gv(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", y)), xs && Pi.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { var a; if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), s) { let l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = co(), this.projectionDelta = co(), this.projectionDeltaWithTransform = co() } setAnimationOrigin(s, a = !1) { let l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, f = co(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; let d = je(), p = l ? l.source : void 0, y = this.layout ? this.layout.source : void 0, g = p !== y, b = this.getStack(), h = !b || b.members.length <= 1, m = !!(g && !h && this.options.crossfade === !0 && !this.path.some(K_)); this.animationProgress = 0; let v; this.mixTargetDelta = w => { let C = w / 1e3; Kv(f.x, s.x, C), Kv(f.y, s.y, C), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Ts(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Y_(this.relativeTarget, this.relativeTargetOrigin, d, C), v && M_(this.relativeTarget, v) && (this.isProjectionDirty = !1), v || (v = je()), pn(v, this.relativeTarget)), g && (this.animationValues = u, R_(u, c, this.latestValues, C, m, h)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Dt(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Y.update(() => { wl.hasAnimatedSinceResize = !0, this.currentAnimation = $d(0, qv, { ...s, onUpdate: a => { this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a) }, onComplete: () => { s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); let s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(qv), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { let s = this.getLead(), { targetWithTransforms: a, target: l, layout: c, latestValues: u } = s; if (!(!a || !l || !c)) { if (this !== s && this.layout && c && G0(this.options.animationType, this.layout.layoutBox, c.layoutBox)) { l = this.target || je(); let f = jt(this.layout.layoutBox.x); l.x.min = s.target.x.min, l.x.max = l.x.min + f; let d = jt(this.layout.layoutBox.y); l.y.min = s.target.y.min, l.y.max = l.y.min + d } pn(a, l), fo(a, u), Cs(this.projectionDeltaWithTransform, this.layoutCorrected, a, u) } } registerSharedNode(s, a) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new O_), this.sharedNodes.get(s).add(a); let c = a.options.initialPromotionConfig; a.promote({ transition: c ? c.transition : void 0, preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { let s = this.getStack(); return s ? s.lead === this : !0 } getLead() { var s; let { layoutId: a } = this.options; return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this } getPrevLead() { var s; let { layoutId: a } = this.options; return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0 } getStack() { let { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) { let c = this.getStack(); c && c.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { let s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { let { visualElement: s } = this.options; if (!s) return; let a = !1, { latestValues: l } = s; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; let c = {}; l.z && If("z", s, c, this.animationValues); for (let u = 0; u < Ff.length; u++)If(`rotate${Ff[u]}`, s, c, this.animationValues), If(`skew${Ff[u]}`, s, c, this.animationValues); s.render(); for (let u in c) s.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]); s.scheduleRender() } getProjectionStyles(s) { var a, l; if (!this.instance || this.isSVG) return; if (!this.isVisible) return A_; let c = { visibility: "" }, u = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = Tt(s?.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c; let f = this.getLead(); if (!this.projectionDelta || !this.layout || !f.target) { let g = {}; return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, g.pointerEvents = Tt(s?.pointerEvents) || ""), this.hasProjected && !Ri(this.latestValues) && (g.transform = u ? u({}, "") : "none", this.hasProjected = !1), g } let d = f.animationValues || f.latestValues; this.applyTransformsToTarget(), c.transform = D_(this.projectionDeltaWithTransform, this.treeScale, d), u && (c.transform = u(d, c.transform)); let { x: p, y } = this.projectionDelta; c.transformOrigin = `${p.origin * 100}% ${y.origin * 100}% 0`, f.animationValues ? c.opacity = f === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0; for (let g in Cl) { if (d[g] === void 0) continue; let { correct: b, applyTo: h } = Cl[g], m = c.transform === "none" ? d[g] : b(d[g], f); if (h) { let v = h.length; for (let w = 0; w < v; w++)c[h[w]] = m } else c[g] = m } return this.options.layoutId && (c.pointerEvents = f === this ? Tt(s?.pointerEvents) || "" : "none"), c } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => { var a; return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(Xv), this.root.sharedNodes.clear() } } } function B_(e) { e.updateLayout() } function z_(e) { var t; let n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { let { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = n.source !== e.layout.source; o === "size" ? mn(f => { let d = s ? n.measuredBox[f] : n.layoutBox[f], p = jt(d); d.min = r[f].min, d.max = d.min + p }) : G0(o, n.layoutBox, r) && mn(f => { let d = s ? n.measuredBox[f] : n.layoutBox[f], p = jt(r[f]); d.max = d.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + p) }); let a = co(); Cs(a, r, n.layoutBox); let l = co(); s ? Cs(l, e.applyTransform(i, !0), n.measuredBox) : Cs(l, r, n.layoutBox); let c = !N0(a), u = !1; if (!e.resumeFrom) { let f = e.getClosestProjectingParent(); if (f && !f.resumeFrom) { let { snapshot: d, layout: p } = f; if (d && p) { let y = je(); Ts(y, n.layoutBox, d.layoutBox); let g = je(); Ts(g, r, p.layoutBox), H0(y, g) || (u = !0), f.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = y, e.relativeParent = f) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: l, layoutDelta: a, hasLayoutChanged: c, hasRelativeTargetChanged: u }) } else if (e.isLead()) { let { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function $_(e) { xs && Pi.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function N_(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function H_(e) { e.clearSnapshot() } function Xv(e) { e.clearMeasurements() } function j_(e) { e.isLayoutDirty = !1 } function W_(e) { let { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function Yv(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function U_(e) { e.resolveTargetDelta() } function G_(e) { e.calcProjection() } function q_(e) { e.resetSkewAndRotation() } function X_(e) { e.removeLeadSnapshot() } function Kv(e, t, n) { e.translate = Ie(t.translate, 0, n), e.scale = Ie(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function Qv(e, t, n, r) { e.min = Ie(t.min, n.min, r), e.max = Ie(t.max, n.max, r) } function Y_(e, t, n, r) { Qv(e.x, t.x, n.x, r), Qv(e.y, t.y, n.y, r) } function K_(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } var Q_ = { duration: .45, ease: [.4, 0, .1, 1] }, Zv = e => typeof Ne < "u" && Ne.userAgent && Ne.userAgent.toLowerCase().includes(e), Jv = Zv("applewebkit/") && !Zv("chrome/") ? Math.round : gt; function ey(e) { e.min = Jv(e.min), e.max = Jv(e.max) } function Z_(e) { ey(e.x), ey(e.y) } function G0(e, t, n) { return e === "position" || e === "preserve-aspect" && !IP(Uv(t), Uv(n), .2) } function J_(e) { var t; return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot) } var eF = U0({ attachResizeListener: (e, t) => br(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Ii = { current: void 0 }, q0 = U0({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Ii.current) { let e = new eF({}); e.mount(I), e.setOptions({ layoutScroll: !0 }), Ii.current = e } return Ii.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => I.getComputedStyle(e).position === "fixed" }), X0 = { pan: { Feature: S_ }, drag: { Feature: w_, ProjectionNode: q0, MeasureLayout: B0 } }, Y0 = class extends b0 { constructor() { super(...arguments), this.KeyframeResolver = s0 } sortInstanceNodePosition(e, t) { return e.compareDocumentPosition(t) & 2 ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, { vars: t, style: n }) { delete t[e], delete n[e] } }; function tF(e) { return I.getComputedStyle(e) } var K0 = class extends Y0 { constructor() { super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = C0 } readValueFromInstance(e, t) { if (Gr.has(t)) { let n = kd(t); return n && n.default || 0 } else { let n = tF(e), r = (Gy(t) ? n.getPropertyValue(t) : n[t]) || 0; return typeof r == "string" ? r.trim() : r } } measureInstanceViewportBox(e, { transformPagePoint: t }) { return A0(e, t) } build(e, t, n) { Dd(e, t, n.transformTemplate) } scrapeMotionValuesFromProps(e, t, n) { return zd(e, t, n) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); let { children: e } = this.props; De(e) && (this.childSubscription = e.on("change", t => { this.current && (this.current.textContent = `${t}`) })) } }, Q0 = class extends Y0 { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = je } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (Gr.has(t)) { let n = kd(t); return n && n.default || 0 } return t = T0.has(t) ? t : Ll(t), e.getAttribute(t) } scrapeMotionValuesFromProps(e, t, n) { return R0(e, t, n) } build(e, t, n) { Vd(e, t, this.isSVGTag, n.transformTemplate) } renderInstance(e, t, n, r) { E0(e, t, n, r) } mount(e) { this.isSVGTag = Bd(e.tagName), super.mount(e) } }, Nd = (e, t) => Od(e) ? new Q0(t) : new K0(t, { allowProjection: e !== gr }), Z0 = { layout: { ProjectionNode: q0, MeasureLayout: B0 } }, nF = { ...Ul, ...F0, ...X0, ...Z0 }, vn = x0((e, t) => P0(e, t, nF, Nd)); var rF = x0(P0), iF = class extends Re { getSnapshotBeforeUpdate(e) { let t = this.props.childRef.current; if (t && e.isPresent && !this.props.isPresent) { let n = this.props.sizeRef.current; n.height = t.offsetHeight || 0, n.width = t.offsetWidth || 0, n.top = t.offsetTop, n.left = t.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } }; function oF({ children: e, isPresent: t }) {
    let n = Ti(), r = D(null), i = D({ width: 0, height: 0, top: 0, left: 0 }), { nonce: o } = V(Zn); return st(() => {
        let { width: s, height: a, top: l, left: c } = i.current; if (t || !r.current || !s || !a) return; r.current.dataset.motionPopId = n; let u = document.createElement("style"); return o && (u.nonce = o), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => { document.head.removeChild(u) }
    }, [t]), k(iF, { isPresent: t, childRef: r, sizeRef: i, children: vr(e, { ref: r }) })
} var sF = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => { let a = er(aF), l = Ti(), c = ae(() => ({ id: l, initial: t, isPresent: n, custom: i, onExitComplete: u => { a.set(u, !0); for (let f of a.values()) if (!f) return; r && r() }, register: u => (a.set(u, !1), () => a.delete(u)) }), o ? [Math.random()] : [n]); return ae(() => { a.forEach((u, f) => a.set(f, !1)) }, [n]), z(() => { !n && !a.size && r && r() }, [n]), s === "popLayout" && (e = k(oF, { isPresent: n, children: e })), k(go.Provider, { value: c, children: e }) }; function aF() { return new Map } var yl = e => e.key || ""; function ty(e) { let t = []; return qn.forEach(e, n => { Ht(n) && t.push(n) }), t } var Hd = ({ children: e, exitBeforeEnter: t, custom: n, initial: r = !0, onExitComplete: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => { en(!t, "Replace exitBeforeEnter with mode='wait'"); let a = ae(() => ty(e), [e]), l = a.map(yl), c = D(!0), u = D(a), f = er(() => new Map), [d, p] = Ye(a), [y, g] = Ye(a); Ur(() => { c.current = !1, u.current = a; for (let m = 0; m < y.length; m++) { let v = yl(y[m]); l.includes(v) ? f.delete(v) : f.get(v) !== !0 && f.set(v, !1) } }, [y, l.length, l.join("-")]); let b = []; if (a !== d) { let m = [...a]; for (let v = 0; v < y.length; v++) { let w = y[v], C = yl(w); l.includes(C) || (m.splice(v, 0, w), b.push(w)) } s === "wait" && b.length && (m = b), g(ty(m)), p(a); return } let { forceRender: h } = V(Rs); return k(He, { children: y.map(m => { let v = yl(m), w = a === y || l.includes(v), C = () => { if (f.has(v)) f.set(v, !0); else return; let S = !0; f.forEach(R => { R || (S = !1) }), S && (h?.(), g(u.current), i && i()) }; return k(sF, { isPresent: w, initial: !c.current || r ? void 0 : !1, custom: w ? void 0 : n, presenceAffectsLayout: o, mode: s, onExitComplete: w ? void 0 : C, children: m }, v) }) }) }; function J0({ children: e, isValidProp: t, ...n }) { t && Ty(t), n = { ...V(Zn), ...n }, n.isStatic = er(() => n.isStatic); let r = ae(() => n, [JSON.stringify(n.transition), n.transformPagePoint, n.reducedMotion]); return k(Zn.Provider, { value: r, children: e }) } var eb = ke(null); function lF() { let e = D(!1); return Ur(() => (e.current = !0, () => { e.current = !1 }), []), e } function jd() { let e = lF(), [t, n] = Ye(0), r = se(() => { e.current && n(t + 1) }, [t]); return [se(() => Y.postRender(r), [r]), t] } var cF = e => !e.isLayoutDirty && e.willUpdate(!1); function ny() { let e = new Set, t = new WeakMap, n = () => e.forEach(cF); return { add: r => { e.add(r), t.set(r, r.addEventListener("willUpdate", n)) }, remove: r => { e.delete(r); let i = t.get(r); i && (i(), t.delete(r)), n() }, dirty: n } } var tb = e => e === !0, uF = e => tb(e === !0) || e === "id", nb = ({ children: e, id: t, inherit: n = !0 }) => { let r = V(Rs), i = V(eb), [o, s] = jd(), a = D(null), l = r.id || i; a.current === null && (uF(n) && l && (t = t ? l + "-" + t : l), a.current = { id: t, group: tb(n) && r.group || ny() }); let c = ae(() => ({ ...a.current, forceRender: o }), [s]); return k(Rs.Provider, { value: c, children: e }) }; function tr(e) { let t = er(() => Ue(e)), { isStatic: n } = V(Zn); if (n) { let [, r] = Ye(e); z(() => t.on("change", r), []) } return t } var fF = e => e && typeof e == "object" && e.mix, dF = e => fF(e) ? e.mix : void 0; function Bs(...e) { let t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], a = xo(i, o, { mixer: dF(o[0]), ...s }); return t ? a(r) : a } function rb(e, t) { let n = tr(t()), r = () => n.set(t()); return r(), Ur(() => { let i = () => Y.preRender(r, !1, !0), o = e.map(s => s.on("change", i)); return () => { o.forEach(s => s()), Dt(r) } }), n } function hF(e) { ks.current = [], e(); let t = rb(ks.current, e); return ks.current = void 0, t } function At(e, t, n, r) { if (typeof e == "function") return hF(e); let i = typeof t == "function" ? t : Bs(t, n, r); return Array.isArray(e) ? ry(e, i) : ry([e], ([o]) => i(o)) } function ry(e, t) { let n = er(() => []); return rb(e, () => { n.length = 0; let r = e.length; for (let i = 0; i < r; i++)n[i] = e[i].get(); return t(n) }) } var ib = ke(null); function pF(e, t, n, r) { if (!r) return e; let i = e.findIndex(u => u.value === t); if (i === -1) return e; let o = r > 0 ? 1 : -1, s = e[i + o]; if (!s) return e; let a = e[i], l = s.layout, c = Ie(l.min, l.max, .5); return o === 1 && a.layout.max + n > c || o === -1 && a.layout.min + n < c ? jE(e, i, i + o) : e } function mF({ children: e, as: t = "ul", axis: n = "y", onReorder: r, values: i, ...o }, s) { let a = er(() => vn(t)), l = [], c = D(!1); en(!!i, "Reorder.Group must be provided a values prop"); let u = { axis: n, registerItem: (f, d) => { let p = l.findIndex(y => f === y.value); p !== -1 ? l[p].layout = d[n] : l.push({ value: f, layout: d[n] }), l.sort(vF) }, updateOrder: (f, d, p) => { if (c.current) return; let y = pF(l, f, d, p); l !== y && (c.current = !0, r(y.map(gF).filter(g => i.indexOf(g) !== -1))) } }; return z(() => { c.current = !1 }), k(a, { ...o, ref: s, ignoreStrict: !0, children: k(ib.Provider, { value: u, children: e }) }) } var FN = Oe(mF); function gF(e) { return e.value } function vF(e, t) { return e.layout.min - t.layout.min } function iy(e, t = 0) { return De(e) ? e : tr(t) } function yF({ children: e, style: t = {}, value: n, as: r = "li", onDrag: i, layout: o = !0, ...s }, a) { let l = er(() => vn(r)), c = V(ib), u = { x: iy(t.x), y: iy(t.y) }, f = At([u.x, u.y], ([g, b]) => g || b ? 1 : "unset"); en(!!c, "Reorder.Item must be a child of Reorder.Group"); let { axis: d, registerItem: p, updateOrder: y } = c; return k(l, { drag: d, ...s, dragSnapToOrigin: !0, style: { ...t, x: u.x, y: u.y, zIndex: f }, layout: o, onDrag: (g, b) => { let { velocity: h } = b; h[d] && y(n, u[d].get(), h[d]), i && i(g, b) }, onLayoutMeasure: g => p(n, g), ref: a, ignoreStrict: !0, children: e }) } var MN = Oe(yF); var bF = { renderer: Nd, ...Ul }, ob = { renderer: Nd, ...Ul, ...F0 }, xF = { ...ob, ...X0, ...Z0 }; function oy(e) { return typeof e == "number" ? e : parseFloat(e) } function Wd(e, t = {}) { let { isStatic: n } = V(Zn), r = D(null), i = tr(De(e) ? oy(e.get()) : e), o = D(i.get()), s = D(() => { }), a = () => { let c = r.current; c && c.time === 0 && c.sample(We.delta), l(), r.current = Sd({ keyframes: [i.get(), o.current], velocity: i.getVelocity(), type: "spring", restDelta: .001, restSpeed: .01, ...t, onUpdate: s.current }) }, l = () => { r.current && r.current.stop() }; return st(() => i.attach((c, u) => n ? u(c) : (o.current = c, s.current = u, Y.update(a), i.get()), l), [JSON.stringify(t)]), Ur(() => { if (De(e)) return e.on("change", c => i.set(oy(c))) }, [i]), i } function Gl(e, t, n) { var r; if (typeof e == "string") { let i = document; t && (en(!!t.current, "Scope provided, but no element detected."), i = t.current), n ? ((r = n[e]) !== null && r !== void 0 || (n[e] = i.querySelectorAll(e)), e = n[e]) : e = i.querySelectorAll(e) } else e instanceof Element && (e = [e]); return Array.from(e || []) } var Sl = new WeakMap, jr; function wF(e, t) { if (t) { let { inlineSize: n, blockSize: r } = t[0]; return { width: n, height: r } } else return e instanceof SVGElement && "getBBox" in e ? e.getBBox() : { width: e.offsetWidth, height: e.offsetHeight } } function SF({ target: e, contentRect: t, borderBoxSize: n }) { var r; (r = Sl.get(e)) === null || r === void 0 || r.forEach(i => { i({ target: e, contentSize: t, get size() { return wF(e, n) } }) }) } function kF(e) { e.forEach(SF) } function CF() { typeof ResizeObserver > "u" || (jr = new ResizeObserver(kF)) } function TF(e, t) { jr || CF(); let n = Gl(e); return n.forEach(r => { let i = Sl.get(r); i || (i = new Set, Sl.set(r, i)), i.add(t), jr?.observe(r) }), () => { n.forEach(r => { let i = Sl.get(r); i?.delete(t), i?.size || jr?.unobserve(r) }) } } var kl = new Set, Es; function EF() { Es = () => { let e = { width: I.innerWidth, height: I.innerHeight }, t = { target: I, size: e, contentSize: e }; kl.forEach(n => n(t)) }, I.addEventListener("resize", Es) } function RF(e) { return kl.add(e), Es || EF(), () => { kl.delete(e), !kl.size && Es && (Es = void 0) } } function PF(e, t) { return typeof e == "function" ? RF(e) : TF(e, t) } var _F = 50, sy = () => ({ current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 }), FF = () => ({ time: 0, x: sy(), y: sy() }), IF = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } }; function ay(e, t, n, r) { let i = n[t], { length: o, position: s } = IF[t], a = i.current, l = n.time; i.current = e[`scroll${s}`], i.scrollLength = e[`scroll${o}`] - e[`client${o}`], i.offset.length = 0, i.offset[0] = 0, i.offset[1] = i.scrollLength, i.progress = Wr(0, i.scrollLength, i.current); let c = r - l; i.velocity = c > _F ? 0 : fd(i.current - a, c) } function LF(e, t, n) { ay(e, "x", t, n), ay(e, "y", t, n), t.time = n } function MF(e, t) { let n = { x: 0, y: 0 }, r = e; for (; r && r !== t;)if (r instanceof HTMLElement) n.x += r.offsetLeft, n.y += r.offsetTop, r = r.offsetParent; else if (r.tagName === "svg") { let i = r.getBoundingClientRect(); r = r.parentElement; let o = r.getBoundingClientRect(); n.x += i.left - o.left, n.y += i.top - o.top } else if (r instanceof SVGGraphicsElement) { let { x: i, y: o } = r.getBBox(); n.x += i, n.y += o; let s = null, a = r.parentNode; for (; !s;)a.tagName === "svg" && (s = a), a = r.parentNode; r = s } else break; return n } var OF = { Enter: [[0, 1], [1, 1]], Exit: [[0, 0], [1, 0]], Any: [[1, 0], [0, 1]], All: [[0, 0], [1, 1]] }, Kf = { start: 0, center: .5, end: 1 }; function ly(e, t, n = 0) { let r = 0; if (e in Kf && (e = Kf[e]), typeof e == "string") { let i = parseFloat(e); e.endsWith("px") ? r = i : e.endsWith("%") ? e = i / 100 : e.endsWith("vw") ? r = i / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? r = i / 100 * document.documentElement.clientHeight : e = i } return typeof e == "number" && (r = t * e), n + r } var DF = [0, 0]; function AF(e, t, n, r) { let i = Array.isArray(e) ? e : DF, o = 0, s = 0; return typeof e == "number" ? i = [e, e] : typeof e == "string" && (e = e.trim(), e.includes(" ") ? i = e.split(" ") : i = [e, Kf[e] ? e : "0"]), o = ly(i[0], n, r), s = ly(i[1], t), o - s } var VF = { x: 0, y: 0 }; function BF(e) { return "getBBox" in e && e.tagName !== "svg" ? e.getBBox() : { width: e.clientWidth, height: e.clientHeight } } function zF(e, t, n) { let { offset: r = OF.All } = n, { target: i = e, axis: o = "y" } = n, s = o === "y" ? "height" : "width", a = i !== e ? MF(i, e) : VF, l = i === e ? { width: e.scrollWidth, height: e.scrollHeight } : BF(i), c = { width: e.clientWidth, height: e.clientHeight }; t[o].offset.length = 0; let u = !t[o].interpolate, f = r.length; for (let d = 0; d < f; d++) { let p = AF(r[d], c[s], l[s], a[o]); !u && p !== t[o].interpolatorOffsets[d] && (u = !0), t[o].offset[d] = p } u && (t[o].interpolate = xo(t[o].offset, wd(r)), t[o].interpolatorOffsets = [...t[o].offset]), t[o].progress = t[o].interpolate(t[o].current) } function $F(e, t = e, n) { if (n.x.targetOffset = 0, n.y.targetOffset = 0, t !== e) { let r = t; for (; r && r !== e;)n.x.targetOffset += r.offsetLeft, n.y.targetOffset += r.offsetTop, r = r.offsetParent } n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth, n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight, n.x.containerLength = e.clientWidth, n.y.containerLength = e.clientHeight } function NF(e, t, n, r = {}) { return { measure: () => $F(e, r.target, n), update: i => { LF(e, n, i), (r.offset || r.target) && zF(e, n, r) }, notify: () => t(n) } } var vs = new WeakMap, cy = new WeakMap, Lf = new WeakMap, uy = e => e === document.documentElement ? I : e; function wo(e, { container: t = document.documentElement, ...n } = {}) { let r = Lf.get(t); r || (r = new Set, Lf.set(t, r)); let i = FF(), o = NF(t, e, i, n); if (r.add(o), !vs.has(t)) { let a = () => { for (let d of r) d.measure() }, l = () => { for (let d of r) d.update(We.timestamp) }, c = () => { for (let d of r) d.notify() }, u = () => { Y.read(a, !1, !0), Y.read(l, !1, !0), Y.update(c, !1, !0) }; vs.set(t, u); let f = uy(t); I.addEventListener("resize", u, { passive: !0 }), t !== document.documentElement && cy.set(t, PF(t, u)), f.addEventListener("scroll", u, { passive: !0 }) } let s = vs.get(t); return Y.read(s, !1, !0), () => { var a; Dt(s); let l = Lf.get(t); if (!l || (l.delete(o), l.size)) return; let c = vs.get(t); vs.delete(t), c && (uy(t).removeEventListener("scroll", c), (a = cy.get(t)) === null || a === void 0 || a(), I.removeEventListener("resize", c)) } } function fy(e, t) { vo(!!(!t || t.current), `You have defined a ${e} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`) } var HF = () => ({ scrollX: Ue(0), scrollY: Ue(0), scrollXProgress: Ue(0), scrollYProgress: Ue(0) }); function sb({ container: e, target: t, layoutEffect: n = !0, ...r } = {}) { let i = er(HF); return (n ? Ur : z)(() => (fy("target", t), fy("container", e), wo(({ x: s, y: a }) => { i.scrollX.set(s.current), i.scrollXProgress.set(s.progress), i.scrollY.set(a.current), i.scrollYProgress.set(a.progress) }, { ...r, container: e?.current || void 0, target: t?.current || void 0 })), [e, t, JSON.stringify(r.offset)]), i } function jF(e) { let t = D(0), { isStatic: n } = V(Zn); z(() => { if (n) return; let r = ({ timestamp: i, delta: o }) => { t.current || (t.current = i), e(i - t.current, o) }; return Y.update(r, !0), () => Dt(r) }, [e]) } function ab() { !Md.current && y0(); let [e] = Ye(_l.current); return e } function Li() { let e = ab(), { reducedMotion: t } = V(Zn); return t === "never" ? !1 : t === "always" ? !0 : e } function WF(e) { e.values.forEach(t => t.stop()) } function Qf(e, t) { [...t].reverse().forEach(r => { let i = e.getVariant(r); i && _d(e, i), e.variantChildren && e.variantChildren.forEach(o => { Qf(o, t) }) }) } function UF(e, t) { if (Array.isArray(t)) return Qf(e, t); if (typeof t == "string") return Qf(e, [t]); _d(e, t) } function lb() { let e = !1, t = new Set, n = { subscribe(r) { return t.add(r), () => void t.delete(r) }, start(r, i) { en(e, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook."); let o = []; return t.forEach(s => { o.push(Id(s, r, { transitionOverride: i })) }), Promise.all(o) }, set(r) { return en(e, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."), t.forEach(i => { UF(i, r) }) }, stop() { t.forEach(r => { WF(r) }) }, mount() { return e = !0, () => { e = !1, n.stop() } } }; return n } var cb = (e, t, n) => { let r = t - e; return ((n - e) % r + r) % r + e }; function GF(e) { return typeof e == "object" && !Array.isArray(e) } function qF(e) { let t = { presenceContext: null, props: {}, visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} }, latestValues: {} } }, n = j0(e) ? new Q0(t) : new K0(t); n.mount(e), kr.set(e, n) } function XF(e, t = 100) { let n = As({ keyframes: [0, t], ...e }), r = Math.min(Jy(n), $f); return { type: "keyframes", ease: i => n.next(r * i).value / t, duration: Qn(r) } } function dy(e, t, n, r) { var i; return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : (i = r.get(t)) !== null && i !== void 0 ? i : e } function YF(e, t) { return Ky(e) ? e[cb(0, e.length, t)] : e } function KF(e, t, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; i.at > t && i.at < n && (Ds(e, i), r--) } } function QF(e, t, n, r, i, o) { KF(e, i, o); for (let s = 0; s < t.length; s++)e.push({ value: t[s], at: Ie(i, o, r[s]), easing: YF(n, s) }) } function ZF(e, t) { return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at } var JF = "easeInOut"; function eI(e, { defaultTransition: t = {}, ...n } = {}, r) { let i = t.duration || .3, o = new Map, s = new Map, a = {}, l = new Map, c = 0, u = 0, f = 0; for (let d = 0; d < e.length; d++) { let p = e[d]; if (typeof p == "string") { l.set(p, u); continue } else if (!Array.isArray(p)) { l.set(p.name, dy(u, p.at, c, l)); continue } let [y, g, b = {}] = p; b.at !== void 0 && (u = dy(u, b.at, c, l)); let h = 0, m = (v, w, C, S = 0, R = 0) => { let E = tI(v), { delay: L = 0, times: F = wd(E), type: N = "keyframes", ...A } = w, { ease: K = t.ease || "easeOut", duration: U } = w, H = typeof L == "function" ? L(S, R) : L, W = E.length; if (W <= 2 && N === "spring") { let ne = 100; if (W === 2 && iI(E)) { let pe = E[1] - E[0]; ne = Math.abs(pe) } let be = { ...A }; U !== void 0 && (be.duration = Fn(U)); let re = XF(be, ne); K = re.ease, U = re.duration } U ?? (U = i); let ee = u + H, te = ee + U; F.length === 1 && F[0] === 0 && (F[1] = 1); let q = F.length - E.length; q > 0 && Qy(F, q), E.length === 1 && E.unshift(null), QF(C, E, K, F, ee, te), h = Math.max(H + U, h), f = Math.max(te, f) }; if (De(y)) { let v = hy(y, s); m(g, b, py("default", v)) } else { let v = Gl(y, r, a), w = v.length; for (let C = 0; C < w; C++) { g = g, b = b; let S = v[C], R = hy(S, s); for (let E in g) m(g[E], nI(b, E), py(E, R), C, w) } } c = u, u += h } return s.forEach((d, p) => { for (let y in d) { let g = d[y]; g.sort(ZF); let b = [], h = [], m = []; for (let w = 0; w < g.length; w++) { let { at: C, value: S, easing: R } = g[w]; b.push(S), h.push(Wr(0, f, C)), m.push(R || "easeOut") } h[0] !== 0 && (h.unshift(0), b.unshift(b[0]), m.unshift(JF)), h[h.length - 1] !== 1 && (h.push(1), b.push(null)), o.has(p) || o.set(p, { keyframes: {}, transition: {} }); let v = o.get(p); v.keyframes[y] = b, v.transition[y] = { ...t, duration: f, ease: m, times: h, ...n } } }), o } function hy(e, t) { return !t.has(e) && t.set(e, {}), t.get(e) } function py(e, t) { return t[e] || (t[e] = []), t[e] } function tI(e) { return Array.isArray(e) ? e : [e] } function nI(e, t) { return e[t] ? { ...e, ...e[t] } : { ...e } } var rI = e => typeof e == "number", iI = e => e.every(rI); function ub(e, t, n, r) { let i = Gl(e, r), o = i.length; en(!!o, "No valid element provided."); let s = []; for (let a = 0; a < o; a++) { let l = i[a]; kr.has(l) || qF(l); let c = kr.get(l), u = { ...n }; typeof u.delay == "function" && (u.delay = u.delay(a, o)), s.push(...Fd(c, { ...t, transition: u }, {})) } return new Rd(s) } var oI = e => Array.isArray(e) && Array.isArray(e[0]); function sI(e, t, n) { let r = []; return eI(e, t, n).forEach(({ keyframes: o, transition: s }, a) => { let l; De(a) ? l = $d(a, o.default, s.default) : l = ub(a, o, s), r.push(l) }), new Rd(r) } var fb = e => { function t(n, r, i) { let o; return oI(n) ? o = sI(n, r, e) : GF(r) ? o = ub(n, r, i, e) : o = $d(n, r, i), e && e.animations.push(o), o } return t }, nr = fb(); function db() { let e = er(lb); return Ur(e.mount, []), e } var hb = db; var aI = { some: 0, all: 1 }; function ql(e, t, { root: n, margin: r, amount: i = "some" } = {}) { let o = Gl(e), s = new WeakMap, a = c => { c.forEach(u => { let f = s.get(u.target); if (u.isIntersecting !== !!f) if (u.isIntersecting) { let d = t(u); typeof d == "function" ? s.set(u.target, d) : l.unobserve(u.target) } else f && (f(u), s.delete(u.target)) }) }, l = new IntersectionObserver(a, { root: n, rootMargin: r, threshold: typeof i == "number" ? i : aI[i] }); return o.forEach(c => l.observe(c)), () => l.disconnect() } function lI(e, { root: t, margin: n, amount: r, once: i = !1 } = {}) { let [o, s] = Ye(!1); return z(() => { if (!e.current || i && o) return; let a = () => (s(!0), i ? void 0 : () => s(!1)), l = { root: t && t.current || void 0, margin: n, amount: r }; return ql(e.current, a, l) }, [t, e, n, i, r]), o } function Ud(e) { return e !== null && typeof e == "object" && id in e } function pb(e) { if (Ud(e)) return e[id] } function Gd() { return cI } function cI(e) { Ii.current && (Ii.current.isUpdating = !1, Ii.current.blockUpdate(), e && e()) } function mb() { let [e, t] = jd(), n = Gd(), r = D(); return z(() => { Y.postRender(() => Y.postRender(() => { t === r.current && (Rl.current = !1) })) }, [t]), i => { n(() => { Rl.current = !0, e(), i(), r.current = t + 1 }) } } function gb() { return se(() => { let t = Ii.current; t && t.resetTree() }, []) } var my = () => ({}); var qN = Bl({ scrapeMotionValuesFromProps: my, createRenderState: my }); function uI(e, t) { if (e === "first") return 0; { let n = t - 1; return e === "last" ? n : n / 2 } } function qd(e = .1, { startDelay: t = 0, from: n = 0, ease: r } = {}) { return (i, o) => { let s = typeof n == "number" ? n : uI(n, o), a = Math.abs(s - i), l = e * a; if (r) { let c = o * e; l = zf(r)(l / c) * c } return t + l } } var fI = ys.reduce((e, t) => (e[t] = n => Dt(n), e), {}); var GL = {}; mf(GL, { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => OL, createPortal: () => DL, createRoot: () => AL, default: () => M1, findDOMNode: () => VL, flushSync: () => BL, hydrate: () => zL, hydrateRoot: () => $L, render: () => NL, unmountComponentAtNode: () => HL, unstable_batchedUpdates: () => jL, unstable_renderSubtreeIntoContainer: () => WL, version: () => UL }); var Jl = {}; mf(Jl, { default: () => Q, unstable_IdlePriority: () => pI, unstable_ImmediatePriority: () => mI, unstable_LowPriority: () => gI, unstable_NormalPriority: () => vI, unstable_Profiling: () => yI, unstable_UserBlockingPriority: () => bI, unstable_cancelCallback: () => xI, unstable_continueExecution: () => wI, unstable_forceFrameRate: () => SI, unstable_getCurrentPriorityLevel: () => kI, unstable_getFirstCallbackNode: () => CI, unstable_next: () => TI, unstable_now: () => hI, unstable_pauseExecution: () => EI, unstable_requestPaint: () => RI, unstable_runWithPriority: () => PI, unstable_scheduleCallback: () => _I, unstable_shouldYield: () => FI, unstable_wrapCallback: () => II }); var Q = {}; function Qd(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < Xl(i, t))) break e; e[r] = t, e[n] = i, n = r } } function In(e) { return e.length === 0 ? null : e[0] } function Kl(e) { if (e.length === 0) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) { var s = 2 * (r + 1) - 1, a = e[s], l = s + 1, c = e[l]; if (0 > Xl(a, n)) l < i && 0 > Xl(c, a) ? (e[r] = c, e[l] = n, r = l) : (e[r] = a, e[s] = n, r = s); else { if (!(l < i && 0 > Xl(c, n))) break e; e[r] = c, e[l] = n, r = l } } } return t } function Xl(e, t) { var n = e.sortIndex - t.sortIndex; return n !== 0 ? n : e.id - t.id } typeof performance == "object" && typeof performance.now == "function" ? (vb = performance, Q.unstable_now = function () { return vb.now() }) : (Xd = Date, yb = Xd.now(), Q.unstable_now = function () { return Xd.now() - yb }); var vb, Xd, yb, rr = [], Xr = [], dI = 1, yn = null, Et = 3, Ql = !1, Mi = !1, $s = !1, wb = typeof setTimeout == "function" ? setTimeout : null, Sb = typeof clearTimeout == "function" ? clearTimeout : null, bb = typeof setImmediate < "u" ? setImmediate : null; typeof Ne < "u" && Ne.scheduling !== void 0 && Ne.scheduling.isInputPending !== void 0 && Ne.scheduling.isInputPending.bind(Ne.scheduling); function Zd(e) { for (var t = In(Xr); t !== null;) { if (t.callback === null) Kl(Xr); else { if (!(t.startTime <= e)) break; Kl(Xr), t.sortIndex = t.expirationTime, Qd(rr, t) } t = In(Xr) } } function Jd(e) { if ($s = !1, Zd(e), !Mi) if (In(rr) !== null) Mi = !0, th(eh); else { var t = In(Xr); t !== null && nh(Jd, t.startTime - e) } } function eh(e, t) { Mi = !1, $s && ($s = !1, Sb(Ns), Ns = -1), Ql = !0; var n = Et; try { for (Zd(t), yn = In(rr); yn !== null && (!(yn.expirationTime > t) || e && !Tb());) { var r = yn.callback; if (typeof r == "function") { yn.callback = null, Et = yn.priorityLevel; var i = r(yn.expirationTime <= t); t = Q.unstable_now(), typeof i == "function" ? yn.callback = i : yn === In(rr) && Kl(rr), Zd(t) } else Kl(rr); yn = In(rr) } if (yn !== null) var o = !0; else { var s = In(Xr); s !== null && nh(Jd, s.startTime - t), o = !1 } return o } finally { yn = null, Et = n, Ql = !1 } } var Zl = !1, Yl = null, Ns = -1, kb = 5, Cb = -1; function Tb() { return !(Q.unstable_now() - Cb < kb) } function Yd() { if (Yl !== null) { var e = Q.unstable_now(); Cb = e; var t = !0; try { t = Yl(!0, e) } finally { t ? zs() : (Zl = !1, Yl = null) } } else Zl = !1 } var zs; typeof bb == "function" ? zs = function () { bb(Yd) } : typeof MessageChannel < "u" ? (Kd = new MessageChannel, xb = Kd.port2, Kd.port1.onmessage = Yd, zs = function () { xb.postMessage(null) }) : zs = function () { wb(Yd, 0) }; var Kd, xb; function th(e) { Yl = e, Zl || (Zl = !0, zs()) } function nh(e, t) { Ns = wb(function () { e(Q.unstable_now()) }, t) } Q.unstable_IdlePriority = 5; Q.unstable_ImmediatePriority = 1; Q.unstable_LowPriority = 4; Q.unstable_NormalPriority = 3; Q.unstable_Profiling = null; Q.unstable_UserBlockingPriority = 2; Q.unstable_cancelCallback = function (e) { e.callback = null }; Q.unstable_continueExecution = function () { Mi || Ql || (Mi = !0, th(eh)) }; Q.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : kb = 0 < e ? Math.floor(1e3 / e) : 5 }; Q.unstable_getCurrentPriorityLevel = function () { return Et }; Q.unstable_getFirstCallbackNode = function () { return In(rr) }; Q.unstable_next = function (e) { switch (Et) { case 1: case 2: case 3: var t = 3; break; default: t = Et }var n = Et; Et = t; try { return e() } finally { Et = n } }; Q.unstable_pauseExecution = function () { }; Q.unstable_requestPaint = function () { }; Q.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = Et; Et = e; try { return t() } finally { Et = n } }; Q.unstable_scheduleCallback = function (e, t, n) { var r = Q.unstable_now(); switch (typeof n == "object" && n !== null ? (n = n.delay, n = typeof n == "number" && 0 < n ? r + n : r) : n = r, e) { case 1: var i = -1; break; case 2: i = 250; break; case 5: i = 1073741823; break; case 4: i = 1e4; break; default: i = 5e3 }return i = n + i, e = { id: dI++, callback: t, priorityLevel: e, startTime: n, expirationTime: i, sortIndex: -1 }, n > r ? (e.sortIndex = n, Qd(Xr, e), In(rr) === null && e === In(Xr) && ($s ? (Sb(Ns), Ns = -1) : $s = !0, nh(Jd, n - r))) : (e.sortIndex = i, Qd(rr, e), Mi || Ql || (Mi = !0, th(eh))), e }; Q.unstable_shouldYield = Tb; Q.unstable_wrapCallback = function (e) { var t = Et; return function () { var n = Et; Et = t; try { return e.apply(this, arguments) } finally { Et = n } } }; var hI = Q.unstable_now, pI = Q.unstable_IdlePriority, mI = Q.unstable_ImmediatePriority, gI = Q.unstable_LowPriority, vI = Q.unstable_NormalPriority, yI = Q.unstable_Profiling, bI = Q.unstable_UserBlockingPriority, xI = Q.unstable_cancelCallback, wI = Q.unstable_continueExecution, SI = Q.unstable_forceFrameRate, kI = Q.unstable_getCurrentPriorityLevel, CI = Q.unstable_getFirstCallbackNode, TI = Q.unstable_next, EI = Q.unstable_pauseExecution, RI = Q.unstable_requestPaint, PI = Q.unstable_runWithPriority, _I = Q.unstable_scheduleCallback, FI = Q.unstable_shouldYield, II = Q.unstable_wrapCallback; var LI = "default" in Ct ? x : Ct, MI = "default" in Jl ? Q : Jl, an = {}, Lx = LI, sn = MI; function M(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Mx = new Set, ca = {}; function Gi(e, t) { Ho(e, t), Ho(e + "Capture", t) } function Ho(e, t) { for (ca[e] = t, e = 0; e < t.length; e++)Mx.add(t[e]) } var _r = !(typeof I > "u" || typeof I.document > "u" || typeof I.document.createElement > "u"), Th = Object.prototype.hasOwnProperty, OI = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Eb = {}, Rb = {}; function DI(e) { return Th.call(Rb, e) ? !0 : Th.call(Eb, e) ? !1 : OI.test(e) ? Rb[e] = !0 : (Eb[e] = !0, !1) } function AI(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function VI(e, t, n, r) { if (t === null || typeof t > "u" || AI(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function zt(e, t, n, r, i, o, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s } var bt = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { bt[e] = new zt(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; bt[t] = new zt(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { bt[e] = new zt(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { bt[e] = new zt(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { bt[e] = new zt(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { bt[e] = new zt(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { bt[e] = new zt(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { bt[e] = new zt(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { bt[e] = new zt(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var gp = /[\-:]([a-z])/g; function vp(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(gp, vp); bt[t] = new zt(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(gp, vp); bt[t] = new zt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(gp, vp); bt[t] = new zt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { bt[e] = new zt(e, 1, !1, e.toLowerCase(), null, !1, !1) }); bt.xlinkHref = new zt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { bt[e] = new zt(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function yp(e, t, n, r) { var i = bt.hasOwnProperty(t) ? bt[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (VI(t, n, i, r) && (n = null), r || i === null ? DI(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type !== 3 && "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var Mr = Lx.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ec = Symbol.for("react.element"), Co = Symbol.for("react.portal"), To = Symbol.for("react.fragment"), bp = Symbol.for("react.strict_mode"), Eh = Symbol.for("react.profiler"), Ox = Symbol.for("react.provider"), Dx = Symbol.for("react.context"), xp = Symbol.for("react.forward_ref"), Rh = Symbol.for("react.suspense"), Ph = Symbol.for("react.suspense_list"), wp = Symbol.for("react.memo"), Kr = Symbol.for("react.lazy"); Symbol.for("react.scope"); Symbol.for("react.debug_trace_mode"); var Ax = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"); Symbol.for("react.cache"); Symbol.for("react.tracing_marker"); var Pb = Symbol.iterator; function Hs(e) { return e === null || typeof e != "object" ? null : (e = Pb && e[Pb] || e["@@iterator"], typeof e == "function" ? e : null) } var rh, $e = Object.assign; function Ks(e) {
    if (rh === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); rh = t && t[1] || "" } return `
`+ rh + e
} var ih = !1; function oh(e, t) {
    if (!e || ih) return ""; ih = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== o[a]) {
                if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== o[a]) {
                    var l = `
`+ i[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                } while (1 <= s && 0 <= a); break
            }
        }
    } finally { ih = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Ks(e) : ""
} function BI(e) { switch (e.tag) { case 5: return Ks(e.type); case 16: return Ks("Lazy"); case 13: return Ks("Suspense"); case 19: return Ks("SuspenseList"); case 0: case 2: case 15: return e = oh(e.type, !1), e; case 11: return e = oh(e.type.render, !1), e; case 1: return e = oh(e.type, !0), e; default: return "" } } function _h(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case To: return "Fragment"; case Co: return "Portal"; case Eh: return "Profiler"; case bp: return "StrictMode"; case Rh: return "Suspense"; case Ph: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Dx: return (e.displayName || "Context") + ".Consumer"; case Ox: return (e._context.displayName || "Context") + ".Provider"; case xp: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case wp: return t = e.displayName || null, t !== null ? t : _h(e.type) || "Memo"; case Kr: t = e._payload, e = e._init; try { return _h(e(t)) } catch { } }return null } function zI(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return _h(t); case 8: return t === bp ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function ui(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Vx(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function $I(e) { var t = Vx(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function tc(e) { e._valueTracker || (e._valueTracker = $I(e)) } function Bx(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = Vx(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n && (t.setValue(e), !0) } function _c(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Fh(e, t) { var n = t.checked; return $e({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function _b(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = ui(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function zx(e, t) { t = t.checked, t != null && yp(e, "checked", t, !1) } function Ih(e, t) { zx(e, t); var n = ui(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Lh(e, t.type, n) : t.hasOwnProperty("defaultValue") && Lh(e, t.type, ui(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function Fb(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Lh(e, t, n) { t === "number" && _c(e.ownerDocument) === e || (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Qs = Array.isArray; function Ao(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + ui(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Mh(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(M(91)); return $e({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Ib(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(M(92)); if (Qs(n)) { if (1 < n.length) throw Error(M(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: ui(n) } } function $x(e, t) { var n = ui(t.value), r = ui(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function Lb(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Nx(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Oh(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Nx(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var nc, Hx = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (nc = nc || document.createElement("div"), nc.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = nc.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function ua(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var ea = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, NI = ["Webkit", "ms", "Moz", "O"]; Object.keys(ea).forEach(function (e) { NI.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), ea[t] = ea[e] }) }); function jx(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || ea.hasOwnProperty(e) && ea[e] ? ("" + t).trim() : t + "px" } function Wx(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = jx(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var HI = $e({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Dh(e, t) { if (t) { if (HI[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(M(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(M(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(M(61)) } if (t.style != null && typeof t.style != "object") throw Error(M(62)) } } function Ah(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Vh = null; function Sp(e) { return e = e.target || e.srcElement || I, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Bh = null, Vo = null, Bo = null; function Mb(e) { if (e = Pa(e)) { if (typeof Bh != "function") throw Error(M(280)); var t = e.stateNode; t && (t = ru(t), Bh(e.stateNode, e.type, t)) } } function Ux(e) { Vo ? Bo ? Bo.push(e) : Bo = [e] : Vo = e } function Gx() { if (Vo) { var e = Vo, t = Bo; if (Bo = Vo = null, Mb(e), t) for (e = 0; e < t.length; e++)Mb(t[e]) } } function qx(e, t) { return e(t) } function Xx() { } var sh = !1; function Yx(e, t, n) { if (sh) return e(t, n); sh = !0; try { return qx(e, t, n) } finally { sh = !1, (Vo !== null || Bo !== null) && (Xx(), Gx()) } } function fa(e, t) { var n = e.stateNode; if (n === null) return null; var r = ru(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(M(231, t, typeof n)); return n } var zh = !1; if (_r) try { So = {}, Object.defineProperty(So, "passive", { get: function () { zh = !0 } }), I.addEventListener("test", So, So), I.removeEventListener("test", So, So) } catch { zh = !1 } var So; function jI(e, t, n, r, i, o, s, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var ta = !1, Fc = null, Ic = !1, $h = null, WI = { onError: function (e) { ta = !0, Fc = e } }; function UI(e, t, n, r, i, o, s, a, l) { ta = !1, Fc = null, jI.apply(WI, arguments) } function GI(e, t, n, r, i, o, s, a, l) { if (UI.apply(this, arguments), ta) { if (!ta) throw Error(M(198)); var c = Fc; ta = !1, Fc = null, Ic || (Ic = !0, $h = c) } } function qi(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, 4098 & t.flags && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Kx(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Ob(e) { if (qi(e) !== e) throw Error(M(188)) } function qI(e) { var t = e.alternate; if (!t) { if (t = qi(e), t === null) throw Error(M(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return Ob(i), e; if (o === r) return Ob(i), t; o = o.sibling } throw Error(M(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, a = i.child; a;) { if (a === n) { s = !0, n = i, r = o; break } if (a === r) { s = !0, r = i, n = o; break } a = a.sibling } if (!s) { for (a = o.child; a;) { if (a === n) { s = !0, n = o, r = i; break } if (a === r) { s = !0, r = o, n = i; break } a = a.sibling } if (!s) throw Error(M(189)) } } if (n.alternate !== r) throw Error(M(190)) } if (n.tag !== 3) throw Error(M(188)); return n.stateNode.current === n ? e : t } function Qx(e) { return e = qI(e), e !== null ? Zx(e) : null } function Zx(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Zx(e); if (t !== null) return t; e = e.sibling } return null } var Jx = sn.unstable_scheduleCallback, Db = sn.unstable_cancelCallback, XI = sn.unstable_shouldYield, YI = sn.unstable_requestPaint, Ke = sn.unstable_now, KI = sn.unstable_getCurrentPriorityLevel, kp = sn.unstable_ImmediatePriority, ew = sn.unstable_UserBlockingPriority, Lc = sn.unstable_NormalPriority, QI = sn.unstable_LowPriority, tw = sn.unstable_IdlePriority, Jc = null, ar = null; function ZI(e) { if (ar && typeof ar.onCommitFiberRoot == "function") try { ar.onCommitFiberRoot(Jc, e, void 0, (128 & e.current.flags) === 128) } catch { } } var An = Math.clz32 ? Math.clz32 : t2, JI = Math.log, e2 = Math.LN2; function t2(e) { return e >>>= 0, e === 0 ? 32 : 31 - (JI(e) / e2 | 0) | 0 } var rc = 64, ic = 4194304; function Zs(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Mc(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, s = 268435455 & n; if (s !== 0) { var a = s & ~i; a !== 0 ? r = Zs(a) : (o &= s, o !== 0 && (r = Zs(o))) } else s = n & ~i, s !== 0 ? r = Zs(s) : o !== 0 && (r = Zs(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (4194240 & o) !== 0)) return t; if (4 & r && (r |= 16 & n), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - An(t), i = 1 << n, r |= e[n], t &= ~i; return r } function n2(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function r2(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var s = 31 - An(o), a = 1 << s, l = i[s]; l === -1 ? a & n && !(a & r) || (i[s] = n2(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a } } function Nh(e) { return e = -1073741825 & e.pendingLanes, e !== 0 ? e : 1073741824 & e ? 1073741824 : 0 } function nw() { var e = rc; return rc <<= 1, !(4194240 & rc) && (rc = 64), e } function ah(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Ea(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - An(t), e[t] = n } function i2(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - An(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } } function Cp(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - An(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var we = 0; function rw(e) { return e &= -e, 1 < e ? 4 < e ? 268435455 & e ? 16 : 536870912 : 4 : 1 } var iw, Tp, ow, sw, aw, Hh = !1, oc = [], ni = null, ri = null, ii = null, da = new Map, ha = new Map, Zr = [], o2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Ab(e, t) { switch (e) { case "focusin": case "focusout": ni = null; break; case "dragenter": case "dragleave": ri = null; break; case "mouseover": case "mouseout": ii = null; break; case "pointerover": case "pointerout": da.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": ha.delete(t.pointerId) } } function js(e, t, n, r, i, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, t !== null && (t = Pa(t), t !== null && Tp(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function s2(e, t, n, r, i) { switch (t) { case "focusin": return ni = js(ni, e, t, n, r, i), !0; case "dragenter": return ri = js(ri, e, t, n, r, i), !0; case "mouseover": return ii = js(ii, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return da.set(o, js(da.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, ha.set(o, js(ha.get(o) || null, e, t, n, r, i)), !0 }return !1 } function lw(e) { var t = Ai(e.target); if (t !== null) { var n = qi(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Kx(n), t !== null) { e.blockedOn = t, aw(e.priority, function () { ow(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function bc(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = jh(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n !== null) return t = Pa(n), t !== null && Tp(t), e.blockedOn = n, !1; n = e.nativeEvent; var r = new n.constructor(n.type, n); Vh = r, n.target.dispatchEvent(r), Vh = null, t.shift() } return !0 } function Vb(e, t, n) { bc(e) && n.delete(t) } function a2() { Hh = !1, ni !== null && bc(ni) && (ni = null), ri !== null && bc(ri) && (ri = null), ii !== null && bc(ii) && (ii = null), da.forEach(Vb), ha.forEach(Vb) } function Ws(e, t) { e.blockedOn === t && (e.blockedOn = null, Hh || (Hh = !0, sn.unstable_scheduleCallback(sn.unstable_NormalPriority, a2))) } function pa(e) { function t(i) { return Ws(i, e) } if (0 < oc.length) { Ws(oc[0], e); for (var n = 1; n < oc.length; n++) { var r = oc[n]; r.blockedOn === e && (r.blockedOn = null) } } for (ni !== null && Ws(ni, e), ri !== null && Ws(ri, e), ii !== null && Ws(ii, e), da.forEach(t), ha.forEach(t), n = 0; n < Zr.length; n++)r = Zr[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < Zr.length && (n = Zr[0], n.blockedOn === null);)lw(n), n.blockedOn === null && Zr.shift() } var zo = Mr.ReactCurrentBatchConfig, Oc = !0; function l2(e, t, n, r) { var i = we, o = zo.transition; zo.transition = null; try { we = 1, Ep(e, t, n, r) } finally { we = i, zo.transition = o } } function c2(e, t, n, r) { var i = we, o = zo.transition; zo.transition = null; try { we = 4, Ep(e, t, n, r) } finally { we = i, zo.transition = o } } function Ep(e, t, n, r) { if (Oc) { var i = jh(e, t, n, r); if (i === null) ph(e, t, r, Dc, n), Ab(e, r); else if (s2(i, e, t, n, r)) r.stopPropagation(); else if (Ab(e, r), 4 & t && -1 < o2.indexOf(e)) { for (; i !== null;) { var o = Pa(i); if (o !== null && iw(o), o = jh(e, t, n, r), o === null && ph(e, t, r, Dc, n), o === i) break; i = o } i !== null && r.stopPropagation() } else ph(e, t, r, null, n) } } var Dc = null; function jh(e, t, n, r) { if (Dc = null, e = Sp(r), e = Ai(e), e !== null) if (t = qi(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Kx(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Dc = e, null } function cw(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (KI()) { case kp: return 1; case ew: return 4; case Lc: case QI: return 16; case tw: return 536870912; default: return 16 }default: return 16 } } var ei = null, Rp = null, xc = null; function uw() { if (xc) return xc; var e, t, n = Rp, r = n.length, i = "value" in ei ? ei.value : ei.textContent, o = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var s = r - e; for (t = 1; t <= s && n[r - t] === i[o - t]; t++); return xc = i.slice(e, 1 < t ? 1 - t : void 0) } function wc(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function sc() { return !0 } function Bb() { return !1 } function ln(e) { function t(n, r, i, o, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? sc : Bb, this.isPropagationStopped = Bb, this } return $e(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = sc) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = sc) }, persist: function () { }, isPersistent: sc }), t } var lh, ch, Us, Yo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Pp = ln(Yo), Ra = $e({}, Yo, { view: 0, detail: 0 }), u2 = ln(Ra), eu = $e({}, Ra, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: _p, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Us && (Us && e.type === "mousemove" ? (lh = e.screenX - Us.screenX, ch = e.screenY - Us.screenY) : ch = lh = 0, Us = e), lh) }, movementY: function (e) { return "movementY" in e ? e.movementY : ch } }), zb = ln(eu), f2 = $e({}, eu, { dataTransfer: 0 }), d2 = ln(f2), h2 = $e({}, Ra, { relatedTarget: 0 }), uh = ln(h2), p2 = $e({}, Yo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), m2 = ln(p2), g2 = $e({}, Yo, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : I.clipboardData } }), v2 = ln(g2), y2 = $e({}, Yo, { data: 0 }), $b = ln(y2), b2 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, x2 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, w2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function S2(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = w2[e]) && !!t[e] } function _p() { return S2 } var k2 = $e({}, Ra, { key: function (e) { if (e.key) { var t = b2[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = wc(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? x2[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: _p, charCode: function (e) { return e.type === "keypress" ? wc(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? wc(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), C2 = ln(k2), T2 = $e({}, eu, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Nb = ln(T2), E2 = $e({}, Ra, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: _p }), R2 = ln(E2), P2 = $e({}, Yo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), _2 = ln(P2), F2 = $e({}, eu, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), I2 = ln(F2), L2 = [9, 13, 27, 32], Fp = _r && "CompositionEvent" in I, na = null; _r && "documentMode" in document && (na = document.documentMode); var M2 = _r && "TextEvent" in I && !na, fw = _r && (!Fp || na && 8 < na && 11 >= na), Hb = String.fromCharCode(32), jb = !1; function dw(e, t) { switch (e) { case "keyup": return L2.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function hw(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Eo = !1; function O2(e, t) { switch (e) { case "compositionend": return hw(t); case "keypress": return t.which !== 32 ? null : (jb = !0, Hb); case "textInput": return e = t.data, e === Hb && jb ? null : e; default: return null } } function D2(e, t) { if (Eo) return e === "compositionend" || !Fp && dw(e, t) ? (e = uw(), xc = Rp = ei = null, Eo = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return fw && t.locale !== "ko" ? null : t.data; default: return null } } var A2 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Wb(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!A2[e.type] : t === "textarea" } function pw(e, t, n, r) { Ux(r), t = Ac(t, "onChange"), 0 < t.length && (n = new Pp("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var ra = null, ma = null; function V2(e) { Tw(e, 0) } function tu(e) { var t = _o(e); if (Bx(t)) return e } function B2(e, t) { if (e === "change") return t } var mw = !1; _r && (_r ? (lc = "oninput" in document, lc || (fh = document.createElement("div"), fh.setAttribute("oninput", "return;"), lc = typeof fh.oninput == "function"), ac = lc) : ac = !1, mw = ac && (!document.documentMode || 9 < document.documentMode)); var ac, lc, fh; function Ub() { ra && (ra.detachEvent("onpropertychange", gw), ma = ra = null) } function gw(e) { if (e.propertyName === "value" && tu(ma)) { var t = []; pw(t, ma, e, Sp(e)), Yx(V2, t) } } function z2(e, t, n) { e === "focusin" ? (Ub(), ra = t, ma = n, ra.attachEvent("onpropertychange", gw)) : e === "focusout" && Ub() } function $2(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return tu(ma) } function N2(e, t) { if (e === "click") return tu(t) } function H2(e, t) { if (e === "input" || e === "change") return tu(t) } function j2(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Bn = typeof Object.is == "function" ? Object.is : j2; function ga(e, t) { if (Bn(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!Th.call(t, i) || !Bn(e[i], t[i])) return !1 } return !0 } function Gb(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function qb(e, t) { var n = Gb(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Gb(n) } } function vw(e, t) { return !(!e || !t) && (e === t || (!e || e.nodeType !== 3) && (t && t.nodeType === 3 ? vw(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function yw() { for (var e = I, t = _c(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (!n) break; e = t.contentWindow, t = _c(e.document) } return t } function Ip(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function W2(e) { var t = yw(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && vw(n.ownerDocument.documentElement, n)) { if (r !== null && Ip(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || I, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = qb(n, o); var s = qb(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var U2 = _r && "documentMode" in document && 11 >= document.documentMode, Ro = null, Wh = null, ia = null, Uh = !1; function Xb(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Uh || Ro == null || Ro !== _c(r) || (r = Ro, "selectionStart" in r && Ip(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || I).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), ia && ga(ia, r) || (ia = r, r = Ac(Wh, "onSelect"), 0 < r.length && (t = new Pp("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Ro))) } function cc(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Po = { animationend: cc("Animation", "AnimationEnd"), animationiteration: cc("Animation", "AnimationIteration"), animationstart: cc("Animation", "AnimationStart"), transitionend: cc("Transition", "TransitionEnd") }, dh = {}, bw = {}; _r && (bw = document.createElement("div").style, "AnimationEvent" in I || (delete Po.animationend.animation, delete Po.animationiteration.animation, delete Po.animationstart.animation), "TransitionEvent" in I || delete Po.transitionend.transition); function nu(e) { if (dh[e]) return dh[e]; if (!Po[e]) return e; var t, n = Po[e]; for (t in n) if (n.hasOwnProperty(t) && t in bw) return dh[e] = n[t]; return e } var xw = nu("animationend"), ww = nu("animationiteration"), Sw = nu("animationstart"), kw = nu("transitionend"), Cw = new Map, Yb = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function di(e, t) { Cw.set(e, t), Gi(t, [e]) } for (uc = 0; uc < Yb.length; uc++)fc = Yb[uc], Kb = fc.toLowerCase(), Qb = fc[0].toUpperCase() + fc.slice(1), di(Kb, "on" + Qb); var fc, Kb, Qb, uc; di(xw, "onAnimationEnd"); di(ww, "onAnimationIteration"); di(Sw, "onAnimationStart"); di("dblclick", "onDoubleClick"); di("focusin", "onFocus"); di("focusout", "onBlur"); di(kw, "onTransitionEnd"); Ho("onMouseEnter", ["mouseout", "mouseover"]); Ho("onMouseLeave", ["mouseout", "mouseover"]); Ho("onPointerEnter", ["pointerout", "pointerover"]); Ho("onPointerLeave", ["pointerout", "pointerover"]); Gi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Gi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Gi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Gi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Gi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Gi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Js = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), G2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Js)); function Zb(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, GI(r, t, void 0, e), e.currentTarget = null } function Tw(e, t) { t = (4 & t) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== o && i.isPropagationStopped()) break e; Zb(i, a, c), o = l } else for (s = 0; s < r.length; s++) { if (a = r[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e; Zb(i, a, c), o = l } } } if (Ic) throw e = $h, Ic = !1, $h = null, e } function Le(e, t) { var n = t[Kh]; n === void 0 && (n = t[Kh] = new Set); var r = e + "__bubble"; n.has(r) || (Ew(t, e, 2, !1), n.add(r)) } function hh(e, t, n) { var r = 0; t && (r |= 4), Ew(n, e, r, t) } var dc = "_reactListening" + Math.random().toString(36).slice(2); function va(e) { if (!e[dc]) { e[dc] = !0, Mx.forEach(function (n) { n !== "selectionchange" && (G2.has(n) || hh(n, !1, e), hh(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[dc] || (t[dc] = !0, hh("selectionchange", !1, t)) } } function Ew(e, t, n, r) { switch (cw(t)) { case 1: var i = l2; break; case 4: i = c2; break; default: i = Ep }n = i.bind(null, t, n, e), i = void 0, !zh || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function ph(e, t, n, r, i) { var o = r; if (!(1 & t) && !(2 & t) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = Ai(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { r = o = s; continue e } a = a.parentNode } } r = r.return } Yx(function () { var c = o, u = Sp(n), f = []; e: { var d = Cw.get(e); if (d !== void 0) { var p = Pp, y = e; switch (e) { case "keypress": if (wc(n) === 0) break e; case "keydown": case "keyup": p = C2; break; case "focusin": y = "focus", p = uh; break; case "focusout": y = "blur", p = uh; break; case "beforeblur": case "afterblur": p = uh; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": p = zb; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": p = d2; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": p = R2; break; case xw: case ww: case Sw: p = m2; break; case kw: p = _2; break; case "scroll": p = u2; break; case "wheel": p = I2; break; case "copy": case "cut": case "paste": p = v2; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": p = Nb }var g = (4 & t) !== 0, b = !g && e === "scroll", h = g ? d !== null ? d + "Capture" : null : d; g = []; for (var m, v = c; v !== null;) { m = v; var w = m.stateNode; if (m.tag === 5 && w !== null && (m = w, h !== null && (w = fa(v, h), w != null && g.push(ya(v, w, m)))), b) break; v = v.return } 0 < g.length && (d = new p(d, y, null, n, u), f.push({ event: d, listeners: g })) } } if (!(7 & t)) { if (d = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", (!d || n === Vh || !(y = n.relatedTarget || n.fromElement) || !Ai(y) && !y[Fr]) && (p || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : I, p ? (y = n.relatedTarget || n.toElement, p = c, y = y ? Ai(y) : null, y !== null && (b = qi(y), y !== b || y.tag !== 5 && y.tag !== 6) && (y = null)) : (p = null, y = c), p !== y)) { if (g = zb, w = "onMouseLeave", h = "onMouseEnter", v = "mouse", e !== "pointerout" && e !== "pointerover" || (g = Nb, w = "onPointerLeave", h = "onPointerEnter", v = "pointer"), b = p == null ? d : _o(p), m = y == null ? d : _o(y), d = new g(w, v + "leave", p, n, u), d.target = b, d.relatedTarget = m, w = null, Ai(u) === c && (g = new g(h, v + "enter", y, n, u), g.target = m, g.relatedTarget = b, w = g), b = w, p && y) e: { for (g = p, h = y, v = 0, m = g; m; m = ko(m))v++; for (m = 0, w = h; w; w = ko(w))m++; for (; 0 < v - m;)g = ko(g), v--; for (; 0 < m - v;)h = ko(h), m--; for (; v--;) { if (g === h || h !== null && g === h.alternate) break e; g = ko(g), h = ko(h) } g = null } else g = null; p !== null && Jb(f, d, p, g, !1), y !== null && b !== null && Jb(f, b, y, g, !0) } if (d = c ? _o(c) : I, p = d.nodeName && d.nodeName.toLowerCase(), p === "select" || p === "input" && d.type === "file") var C = B2; else if (Wb(d)) if (mw) C = H2; else { C = $2; var S = z2 } else (p = d.nodeName) && p.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (C = N2); switch (C && (C = C(e, c)) ? pw(f, C, n, u) : (S && S(e, d, c), e === "focusout" && (S = d._wrapperState) && S.controlled && d.type === "number" && Lh(d, "number", d.value)), S = c ? _o(c) : I, e) { case "focusin": (Wb(S) || S.contentEditable === "true") && (Ro = S, Wh = c, ia = null); break; case "focusout": ia = Wh = Ro = null; break; case "mousedown": Uh = !0; break; case "contextmenu": case "mouseup": case "dragend": Uh = !1, Xb(f, n, u); break; case "selectionchange": if (U2) break; case "keydown": case "keyup": Xb(f, n, u) }var R; if (Fp) e: { switch (e) { case "compositionstart": var E = "onCompositionStart"; break e; case "compositionend": E = "onCompositionEnd"; break e; case "compositionupdate": E = "onCompositionUpdate"; break e }E = void 0 } else Eo ? dw(e, n) && (E = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (E = "onCompositionStart"); E && (fw && n.locale !== "ko" && (Eo || E !== "onCompositionStart" ? E === "onCompositionEnd" && Eo && (R = uw()) : (ei = u, Rp = "value" in ei ? ei.value : ei.textContent, Eo = !0)), S = Ac(c, E), 0 < S.length && (E = new $b(E, e, null, n, u), f.push({ event: E, listeners: S }), R ? E.data = R : (R = hw(n), R !== null && (E.data = R)))), (R = M2 ? O2(e, n) : D2(e, n)) && (c = Ac(c, "onBeforeInput"), 0 < c.length && (u = new $b("onBeforeInput", "beforeinput", null, n, u), f.push({ event: u, listeners: c }), u.data = R)) } Tw(f, t) }) } function ya(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Ac(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = fa(e, n), o != null && r.unshift(ya(e, o, i)), o = fa(e, t), o != null && r.push(ya(e, o, i))), e = e.return } return r } function ko(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Jb(e, t, n, r, i) { for (var o = t._reactName, s = []; n !== null && n !== r;) { var a = n, l = a.alternate, c = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && c !== null && (a = c, i ? (l = fa(n, o), l != null && s.unshift(ya(n, l, a))) : i || (l = fa(n, o), l != null && s.push(ya(n, l, a)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var q2 = /\r\n?/g, X2 = /\u0000|\uFFFD/g; function ex(e) {
    return (typeof e == "string" ? e : "" + e).replace(q2, `
`).replace(X2, "")
} function hc(e, t, n) { if (t = ex(t), ex(e) !== t && n) throw Error(M(425)) } function Vc() { } var Gh = null, qh = null; function Xh(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var Yh = typeof setTimeout == "function" ? setTimeout : void 0, Y2 = typeof clearTimeout == "function" ? clearTimeout : void 0, tx = typeof Promise == "function" ? Promise : void 0, K2 = typeof queueMicrotask == "function" ? queueMicrotask : typeof tx < "u" ? function (e) { return tx.resolve(null).then(e).catch(Q2) } : Yh; function Q2(e) { setTimeout(function () { throw e }) } function mh(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), pa(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); pa(t) } function oi(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function nx(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var Ko = Math.random().toString(36).slice(2), sr = "__reactFiber$" + Ko, ba = "__reactProps$" + Ko, Fr = "__reactContainer$" + Ko, Kh = "__reactEvents$" + Ko, Z2 = "__reactListeners$" + Ko, J2 = "__reactHandles$" + Ko; function Ai(e) { var t = e[sr]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[Fr] || n[sr]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = nx(e); e !== null;) { if (n = e[sr]) return n; e = nx(e) } return t } e = n, n = e.parentNode } return null } function Pa(e) { return e = e[sr] || e[Fr], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function _o(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(M(33)) } function ru(e) { return e[ba] || null } var Qh = [], Fo = -1; function hi(e) { return { current: e } } function Me(e) { 0 > Fo || (e.current = Qh[Fo], Qh[Fo] = null, Fo--) } function Pe(e, t) { Fo++, Qh[Fo] = e.current, e.current = t } var fi = {}, Ft = hi(fi), qt = hi(!1), Ni = fi; function jo(e, t) { var n = e.type.contextTypes; if (!n) return fi; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, o = {}; for (i in n) o[i] = t[i]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o } function Xt(e) { return e = e.childContextTypes, e != null } function Bc() { Me(qt), Me(Ft) } function rx(e, t, n) { if (Ft.current !== fi) throw Error(M(168)); Pe(Ft, t), Pe(qt, n) } function Rw(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(M(108, zI(e) || "Unknown", i)); return $e({}, n, r) } function zc(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || fi, Ni = Ft.current, Pe(Ft, e), Pe(qt, qt.current), !0 } function ix(e, t, n) { var r = e.stateNode; if (!r) throw Error(M(169)); n ? (e = Rw(e, t, Ni), r.__reactInternalMemoizedMergedChildContext = e, Me(qt), Me(Ft), Pe(Ft, e)) : Me(qt), Pe(qt, n) } var Tr = null, iu = !1, gh = !1; function Pw(e) { Tr === null ? Tr = [e] : Tr.push(e) } function eL(e) { iu = !0, Pw(e) } function pi() { if (!gh && Tr !== null) { gh = !0; var e = 0, t = we; try { var n = Tr; for (we = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } Tr = null, iu = !1 } catch (i) { throw Tr !== null && (Tr = Tr.slice(e + 1)), Jx(kp, pi), i } finally { we = t, gh = !1 } } return null } var Io = [], Lo = 0, $c = null, Nc = 0, bn = [], xn = 0, Hi = null, Er = 1, Rr = ""; function Oi(e, t) { Io[Lo++] = Nc, Io[Lo++] = $c, $c = e, Nc = t } function _w(e, t, n) { bn[xn++] = Er, bn[xn++] = Rr, bn[xn++] = Hi, Hi = e; var r = Er; e = Rr; var i = 32 - An(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - An(t) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Er = 1 << 32 - An(t) + i | n << i | r, Rr = o + e } else Er = 1 << o | n << i | r, Rr = e } function Lp(e) { e.return !== null && (Oi(e, 1), _w(e, 1, 0)) } function Mp(e) { for (; e === $c;)$c = Io[--Lo], Io[Lo] = null, Nc = Io[--Lo], Io[Lo] = null; for (; e === Hi;)Hi = bn[--xn], bn[xn] = null, Rr = bn[--xn], bn[xn] = null, Er = bn[--xn], bn[xn] = null } var on = null, rn = null, Ae = !1, Dn = null; function Fw(e, t) { var n = wn(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function ox(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null && (e.stateNode = t, on = e, rn = oi(t.firstChild), !0); case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null && (e.stateNode = t, on = e, rn = null, !0); case 13: return t = t.nodeType !== 8 ? null : t, t !== null && (n = Hi !== null ? { id: Er, overflow: Rr } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = wn(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, on = e, rn = null, !0); default: return !1 } } function Zh(e) { return (1 & e.mode) !== 0 && (128 & e.flags) === 0 } function Jh(e) { if (Ae) { var t = rn; if (t) { var n = t; if (!ox(e, t)) { if (Zh(e)) throw Error(M(418)); t = oi(n.nextSibling); var r = on; t && ox(e, t) ? Fw(r, n) : (e.flags = -4097 & e.flags | 2, Ae = !1, on = e) } } else { if (Zh(e)) throw Error(M(418)); e.flags = -4097 & e.flags | 2, Ae = !1, on = e } } } function sx(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; on = e } function pc(e) { if (e !== on) return !1; if (!Ae) return sx(e), Ae = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Xh(e.type, e.memoizedProps)), t && (t = rn)) { if (Zh(e)) throw Iw(), Error(M(418)); for (; t;)Fw(e, t), t = oi(t.nextSibling) } if (sx(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(M(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { rn = oi(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } rn = null } } else rn = on ? oi(e.stateNode.nextSibling) : null; return !0 } function Iw() { for (var e = rn; e;)e = oi(e.nextSibling) } function Wo() { rn = on = null, Ae = !1 } function Op(e) { Dn === null ? Dn = [e] : Dn.push(e) } var tL = Mr.ReactCurrentBatchConfig; function Mn(e, t) { if (e && e.defaultProps) { t = $e({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } var Hc = hi(null), jc = null, Mo = null, Dp = null; function Ap() { Dp = Mo = jc = null } function Vp(e) { var t = Hc.current; Me(Hc), e._currentValue = t } function ep(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function $o(e, t) { jc = e, Dp = Mo = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Gt = !0), e.firstContext = null) } function kn(e) { var t = e._currentValue; if (Dp !== e) if (e = { context: e, memoizedValue: t, next: null }, Mo === null) { if (jc === null) throw Error(M(308)); Mo = e, jc.dependencies = { lanes: 0, firstContext: e } } else Mo = Mo.next = e; return t } var Vi = null; function Bp(e) { Vi === null ? Vi = [e] : Vi.push(e) } function Lw(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, Bp(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Ir(e, r) } function Ir(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var Qr = !1; function zp(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Mw(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Pr(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function si(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, 2 & ve) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Ir(e, n) } return i = r.interleaved, i === null ? (t.next = t, Bp(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Ir(e, n) } function Sc(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (4194240 & n) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Cp(e, n) } } function ax(e, t) { var n = e.updateQueue, r = e.alternate; if (r === null || (r = r.updateQueue, n !== r)) e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t; else { var i = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? i = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? i = o = t : o = o.next = t } else i = o = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n } } function Wc(e, t, n, r) { var i = e.updateQueue; Qr = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, c = l.next; l.next = null, s === null ? o = c : s.next = c, s = l; var u = e.alternate; u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (o !== null) { var f = i.baseState; s = 0, u = c = l = null, a = o; do { var d = a.lane, p = a.eventTime; if ((r & d) === d) { u !== null && (u = u.next = { eventTime: p, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var y = e, g = a; switch (d = t, p = n, g.tag) { case 1: if (y = g.payload, typeof y == "function") { f = y.call(p, f, d); break e } f = y; break e; case 3: y.flags = -65537 & y.flags | 128; case 0: if (y = g.payload, d = typeof y == "function" ? y.call(p, f, d) : y, d == null) break e; f = $e({}, f, d); break e; case 2: Qr = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, d = i.effects, d === null ? i.effects = [a] : d.push(a)) } else p = { eventTime: p, lane: d, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, u === null ? (c = u = p, l = f) : u = u.next = p, s |= d; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; d = a, a = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null } } while (1); if (u === null && (l = f), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else o === null && (i.shared.lanes = 0); Wi |= s, e.lanes = s, e.memoizedState = f } } function lx(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(M(191, i)); i.call(r) } } } var Ow = new Lx.Component().refs; function tp(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : $e({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var ou = { isMounted: function (e) { return !!(e = e._reactInternals) && qi(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Bt(), i = li(e), o = Pr(r, i); o.payload = t, n != null && (o.callback = n), t = si(e, o, i), t !== null && (Vn(t, e, i, r), Sc(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Bt(), i = li(e), o = Pr(r, i); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = si(e, o, i), t !== null && (Vn(t, e, i, r), Sc(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Bt(), r = li(e), i = Pr(n, r); i.tag = 2, t != null && (i.callback = t), t = si(e, i, r), t !== null && (Vn(t, e, r, n), Sc(t, e, r)) } }; function cx(e, t, n, r, i, o, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || !ga(n, r) || !ga(i, o) } function Dw(e, t, n) { var r = !1, i = fi, o = t.contextType; return typeof o == "object" && o !== null ? o = kn(o) : (i = Xt(t) ? Ni : Ft.current, r = t.contextTypes, o = (r = r != null) ? jo(e, i) : fi), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = ou, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function ux(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && ou.enqueueReplaceState(t, t.state, null) } function np(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = Ow, zp(e); var o = t.contextType; typeof o == "object" && o !== null ? i.context = kn(o) : (o = Xt(t) ? Ni : Ft.current, i.context = jo(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (tp(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && ou.enqueueReplaceState(i, i.state, null), Wc(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function Gs(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(M(309)); var r = n.stateNode } if (!r) throw Error(M(147, e)); var i = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) { var a = i.refs; a === Ow && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s }, t._stringRef = o, t) } if (typeof e != "string") throw Error(M(284)); if (!n._owner) throw Error(M(290, e)) } return e } function mc(e, t) { throw e = Object.prototype.toString.call(t), Error(M(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function fx(e) { var t = e._init; return t(e._payload) } function Aw(e) { function t(h, m) { if (e) { var v = h.deletions; v === null ? (h.deletions = [m], h.flags |= 16) : v.push(m) } } function n(h, m) { if (!e) return null; for (; m !== null;)t(h, m), m = m.sibling; return null } function r(h, m) { for (h = new Map; m !== null;)m.key !== null ? h.set(m.key, m) : h.set(m.index, m), m = m.sibling; return h } function i(h, m) { return h = ci(h, m), h.index = 0, h.sibling = null, h } function o(h, m, v) { return h.index = v, e ? (v = h.alternate, v !== null ? (v = v.index, v < m ? (h.flags |= 2, m) : v) : (h.flags |= 2, m)) : (h.flags |= 1048576, m) } function s(h) { return e && h.alternate === null && (h.flags |= 2), h } function a(h, m, v, w) { return m === null || m.tag !== 6 ? (m = kh(v, h.mode, w), m.return = h, m) : (m = i(m, v), m.return = h, m) } function l(h, m, v, w) { var C = v.type; return C === To ? u(h, m, v.props.children, w, v.key) : m !== null && (m.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Kr && fx(C) === m.type) ? (w = i(m, v.props), w.ref = Gs(h, m, v), w.return = h, w) : (w = Pc(v.type, v.key, v.props, null, h.mode, w), w.ref = Gs(h, m, v), w.return = h, w) } function c(h, m, v, w) { return m === null || m.tag !== 4 || m.stateNode.containerInfo !== v.containerInfo || m.stateNode.implementation !== v.implementation ? (m = Ch(v, h.mode, w), m.return = h, m) : (m = i(m, v.children || []), m.return = h, m) } function u(h, m, v, w, C) { return m === null || m.tag !== 7 ? (m = $i(v, h.mode, w, C), m.return = h, m) : (m = i(m, v), m.return = h, m) } function f(h, m, v) { if (typeof m == "string" && m !== "" || typeof m == "number") return m = kh("" + m, h.mode, v), m.return = h, m; if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case ec: return v = Pc(m.type, m.key, m.props, null, h.mode, v), v.ref = Gs(h, null, m), v.return = h, v; case Co: return m = Ch(m, h.mode, v), m.return = h, m; case Kr: var w = m._init; return f(h, w(m._payload), v) }if (Qs(m) || Hs(m)) return m = $i(m, h.mode, v, null), m.return = h, m; mc(h, m) } return null } function d(h, m, v, w) { var C = m !== null ? m.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return C !== null ? null : a(h, m, "" + v, w); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case ec: return v.key === C ? l(h, m, v, w) : null; case Co: return v.key === C ? c(h, m, v, w) : null; case Kr: return C = v._init, d(h, m, C(v._payload), w) }if (Qs(v) || Hs(v)) return C !== null ? null : u(h, m, v, w, null); mc(h, v) } return null } function p(h, m, v, w, C) { if (typeof w == "string" && w !== "" || typeof w == "number") return h = h.get(v) || null, a(m, h, "" + w, C); if (typeof w == "object" && w !== null) { switch (w.$$typeof) { case ec: return h = h.get(w.key === null ? v : w.key) || null, l(m, h, w, C); case Co: return h = h.get(w.key === null ? v : w.key) || null, c(m, h, w, C); case Kr: var S = w._init; return p(h, m, v, S(w._payload), C) }if (Qs(w) || Hs(w)) return h = h.get(v) || null, u(m, h, w, C, null); mc(m, w) } return null } function y(h, m, v, w) { for (var C = null, S = null, R = m, E = m = 0, L = null; R !== null && E < v.length; E++) { R.index > E ? (L = R, R = null) : L = R.sibling; var F = d(h, R, v[E], w); if (F === null) { R === null && (R = L); break } e && R && F.alternate === null && t(h, R), m = o(F, m, E), S === null ? C = F : S.sibling = F, S = F, R = L } if (E === v.length) return n(h, R), Ae && Oi(h, E), C; if (R === null) { for (; E < v.length; E++)R = f(h, v[E], w), R !== null && (m = o(R, m, E), S === null ? C = R : S.sibling = R, S = R); return Ae && Oi(h, E), C } for (R = r(h, R); E < v.length; E++)L = p(R, h, E, v[E], w), L !== null && (e && L.alternate !== null && R.delete(L.key === null ? E : L.key), m = o(L, m, E), S === null ? C = L : S.sibling = L, S = L); return e && R.forEach(function (N) { return t(h, N) }), Ae && Oi(h, E), C } function g(h, m, v, w) { var C = Hs(v); if (typeof C != "function") throw Error(M(150)); if (v = C.call(v), v == null) throw Error(M(151)); for (var S = C = null, R = m, E = m = 0, L = null, F = v.next(); R !== null && !F.done; E++, F = v.next()) { R.index > E ? (L = R, R = null) : L = R.sibling; var N = d(h, R, F.value, w); if (N === null) { R === null && (R = L); break } e && R && N.alternate === null && t(h, R), m = o(N, m, E), S === null ? C = N : S.sibling = N, S = N, R = L } if (F.done) return n(h, R), Ae && Oi(h, E), C; if (R === null) { for (; !F.done; E++, F = v.next())F = f(h, F.value, w), F !== null && (m = o(F, m, E), S === null ? C = F : S.sibling = F, S = F); return Ae && Oi(h, E), C } for (R = r(h, R); !F.done; E++, F = v.next())F = p(R, h, E, F.value, w), F !== null && (e && F.alternate !== null && R.delete(F.key === null ? E : F.key), m = o(F, m, E), S === null ? C = F : S.sibling = F, S = F); return e && R.forEach(function (A) { return t(h, A) }), Ae && Oi(h, E), C } function b(h, m, v, w) { if (typeof v == "object" && v !== null && v.type === To && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case ec: e: { for (var C = v.key, S = m; S !== null;) { if (S.key === C) { if (C = v.type, C === To) { if (S.tag === 7) { n(h, S.sibling), m = i(S, v.props.children), m.return = h, h = m; break e } } else if (S.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Kr && fx(C) === S.type) { n(h, S.sibling), m = i(S, v.props), m.ref = Gs(h, S, v), m.return = h, h = m; break e } n(h, S); break } t(h, S), S = S.sibling } v.type === To ? (m = $i(v.props.children, h.mode, w, v.key), m.return = h, h = m) : (w = Pc(v.type, v.key, v.props, null, h.mode, w), w.ref = Gs(h, m, v), w.return = h, h = w) } return s(h); case Co: e: { for (S = v.key; m !== null;) { if (m.key === S) { if (m.tag === 4 && m.stateNode.containerInfo === v.containerInfo && m.stateNode.implementation === v.implementation) { n(h, m.sibling), m = i(m, v.children || []), m.return = h, h = m; break e } n(h, m); break } t(h, m), m = m.sibling } m = Ch(v, h.mode, w), m.return = h, h = m } return s(h); case Kr: return S = v._init, b(h, m, S(v._payload), w) }if (Qs(v)) return y(h, m, v, w); if (Hs(v)) return g(h, m, v, w); mc(h, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, m !== null && m.tag === 6 ? (n(h, m.sibling), m = i(m, v), m.return = h, h = m) : (n(h, m), m = kh(v, h.mode, w), m.return = h, h = m), s(h)) : n(h, m) } return b } var Uo = Aw(!0), Vw = Aw(!1), _a = {}, lr = hi(_a), xa = hi(_a), wa = hi(_a); function Bi(e) { if (e === _a) throw Error(M(174)); return e } function $p(e, t) { switch (Pe(wa, t), Pe(xa, e), Pe(lr, _a), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Oh(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Oh(t, e) }Me(lr), Pe(lr, t) } function Go() { Me(lr), Me(xa), Me(wa) } function Bw(e) { Bi(wa.current); var t = Bi(lr.current), n = Oh(t, e.type); t !== n && (Pe(xa, e), Pe(lr, n)) } function Np(e) { xa.current === e && (Me(lr), Me(xa)) } var Be = hi(0); function Uc(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (128 & t.flags) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var vh = []; function Hp() { for (var e = 0; e < vh.length; e++)vh[e]._workInProgressVersionPrimary = null; vh.length = 0 } var kc = Mr.ReactCurrentDispatcher, yh = Mr.ReactCurrentBatchConfig, ji = 0, ze = null, nt = null, at = null, Gc = !1, oa = !1, Sa = 0, nL = 0; function Rt() { throw Error(M(321)) } function jp(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Bn(e[n], t[n])) return !1; return !0 } function Wp(e, t, n, r, i, o) { if (ji = o, ze = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, kc.current = e === null || e.memoizedState === null ? sL : aL, e = n(r, i), oa) { o = 0; do { if (oa = !1, Sa = 0, 25 <= o) throw Error(M(301)); o += 1, at = nt = null, t.updateQueue = null, kc.current = lL, e = n(r, i) } while (oa) } if (kc.current = qc, t = nt !== null && nt.next !== null, ji = 0, at = nt = ze = null, Gc = !1, t) throw Error(M(300)); return e } function Up() { var e = Sa !== 0; return Sa = 0, e } function or() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return at === null ? ze.memoizedState = at = e : at = at.next = e, at } function Cn() { if (nt === null) { var e = ze.alternate; e = e !== null ? e.memoizedState : null } else e = nt.next; var t = at === null ? ze.memoizedState : at.next; if (t !== null) at = t, nt = e; else { if (e === null) throw Error(M(310)); nt = e, e = { memoizedState: nt.memoizedState, baseState: nt.baseState, baseQueue: nt.baseQueue, queue: nt.queue, next: null }, at === null ? ze.memoizedState = at = e : at = at.next = e } return at } function ka(e, t) { return typeof t == "function" ? t(e) : t } function bh(e) { var t = Cn(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = nt, i = r.baseQueue, o = n.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (i !== null) { o = i.next, r = r.baseState; var a = s = null, l = null, c = o; do { var u = c.lane; if ((ji & u) === u) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), r = c.hasEagerState ? c.eagerState : e(r, c.action); else { var f = { lane: u, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = f, s = r) : l = l.next = f, ze.lanes |= u, Wi |= u } c = c.next } while (c !== null && c !== o); l === null ? s = r : l.next = a, Bn(r, t.memoizedState) || (Gt = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do o = i.lane, ze.lanes |= o, Wi |= o, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function xh(e) { var t = Cn(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do o = e(o, s.action), s = s.next; while (s !== i); Bn(o, t.memoizedState) || (Gt = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function zw() { } function $w(e, t) { var n = ze, r = Cn(), i = t(), o = !Bn(r.memoizedState, i); if (o && (r.memoizedState = i, Gt = !0), r = r.queue, Gp(jw.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || at !== null && 1 & at.memoizedState.tag) { if (n.flags |= 2048, Ca(9, Hw.bind(null, n, r, i, t), void 0, null), lt === null) throw Error(M(349)); 30 & ji || Nw(n, t, i) } return i } function Nw(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ze.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ze.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function Hw(e, t, n, r) { t.value = n, t.getSnapshot = r, Ww(t) && Uw(e) } function jw(e, t, n) { return n(function () { Ww(t) && Uw(e) }) } function Ww(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Bn(e, n) } catch { return !0 } } function Uw(e) { var t = Ir(e, 1); t !== null && Vn(t, e, 1, -1) } function dx(e) { var t = or(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ka, lastRenderedState: e }, t.queue = e, e = e.dispatch = oL.bind(null, ze, e), [t.memoizedState, e] } function Ca(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = ze.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ze.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function Gw() { return Cn().memoizedState } function Cc(e, t, n, r) { var i = or(); ze.flags |= e, i.memoizedState = Ca(1 | t, n, void 0, r === void 0 ? null : r) } function su(e, t, n, r) { var i = Cn(); r = r === void 0 ? null : r; var o = void 0; if (nt !== null) { var s = nt.memoizedState; if (o = s.destroy, r !== null && jp(r, s.deps)) { i.memoizedState = Ca(t, n, o, r); return } } ze.flags |= e, i.memoizedState = Ca(1 | t, n, o, r) } function hx(e, t) { return Cc(8390656, 8, e, t) } function Gp(e, t) { return su(2048, 8, e, t) } function qw(e, t) { return su(4, 2, e, t) } function Xw(e, t) { return su(4, 4, e, t) } function Yw(e, t) { return typeof t == "function" ? (e = e(), t(e), function () { t(null) }) : t != null ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Kw(e, t, n) { return n = n != null ? n.concat([e]) : null, su(4, 4, Yw.bind(null, t, e), n) } function qp() { } function Qw(e, t) { var n = Cn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && jp(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Zw(e, t) { var n = Cn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && jp(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Jw(e, t, n) { return 21 & ji ? (Bn(n, t) || (n = nw(), ze.lanes |= n, Wi |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Gt = !0), e.memoizedState = n) } function rL(e, t) { var n = we; we = n !== 0 && 4 > n ? n : 4, e(!0); var r = yh.transition; yh.transition = {}; try { e(!1), t() } finally { we = n, yh.transition = r } } function e1() { return Cn().memoizedState } function iL(e, t, n) { var r = li(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, t1(e)) n1(t, n); else if (n = Lw(e, t, n, r), n !== null) { var i = Bt(); Vn(n, e, r, i), r1(n, t, r) } } function oL(e, t, n) { var r = li(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (t1(e)) n1(t, i); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var s = t.lastRenderedState, a = o(s, n); if (i.hasEagerState = !0, i.eagerState = a, Bn(a, s)) { var l = t.interleaved; l === null ? (i.next = i, Bp(t)) : (i.next = l.next, l.next = i), t.interleaved = i; return } } catch { } n = Lw(e, t, i, r), n !== null && (i = Bt(), Vn(n, e, r, i), r1(n, t, r)) } } function t1(e) { var t = e.alternate; return e === ze || t !== null && t === ze } function n1(e, t) { oa = Gc = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function r1(e, t, n) { if (4194240 & n) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Cp(e, n) } } var qc = { readContext: kn, useCallback: Rt, useContext: Rt, useEffect: Rt, useImperativeHandle: Rt, useInsertionEffect: Rt, useLayoutEffect: Rt, useMemo: Rt, useReducer: Rt, useRef: Rt, useState: Rt, useDebugValue: Rt, useDeferredValue: Rt, useTransition: Rt, useMutableSource: Rt, useSyncExternalStore: Rt, useId: Rt, unstable_isNewReconciler: !1 }, sL = { readContext: kn, useCallback: function (e, t) { return or().memoizedState = [e, t === void 0 ? null : t], e }, useContext: kn, useEffect: hx, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, Cc(4194308, 4, Yw.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Cc(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Cc(4, 2, e, t) }, useMemo: function (e, t) { var n = or(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = or(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = iL.bind(null, ze, e), [r.memoizedState, e] }, useRef: function (e) { var t = or(); return e = { current: e }, t.memoizedState = e }, useState: dx, useDebugValue: qp, useDeferredValue: function (e) { return or().memoizedState = e }, useTransition: function () { var e = dx(!1), t = e[0]; return e = rL.bind(null, e[1]), or().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ze, i = or(); if (Ae) { if (n === void 0) throw Error(M(407)); n = n() } else { if (n = t(), lt === null) throw Error(M(349)); 30 & ji || Nw(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, hx(jw.bind(null, r, o, e), [e]), r.flags |= 2048, Ca(9, Hw.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = or(), t = lt.identifierPrefix; if (Ae) { var n = Rr, r = Er; n = (r & ~(1 << 32 - An(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Sa++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = nL++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, aL = { readContext: kn, useCallback: Qw, useContext: kn, useEffect: Gp, useImperativeHandle: Kw, useInsertionEffect: qw, useLayoutEffect: Xw, useMemo: Zw, useReducer: bh, useRef: Gw, useState: function () { return bh(ka) }, useDebugValue: qp, useDeferredValue: function (e) { var t = Cn(); return Jw(t, nt.memoizedState, e) }, useTransition: function () { var e = bh(ka)[0], t = Cn().memoizedState; return [e, t] }, useMutableSource: zw, useSyncExternalStore: $w, useId: e1, unstable_isNewReconciler: !1 }, lL = { readContext: kn, useCallback: Qw, useContext: kn, useEffect: Gp, useImperativeHandle: Kw, useInsertionEffect: qw, useLayoutEffect: Xw, useMemo: Zw, useReducer: xh, useRef: Gw, useState: function () { return xh(ka) }, useDebugValue: qp, useDeferredValue: function (e) { var t = Cn(); return nt === null ? t.memoizedState = e : Jw(t, nt.memoizedState, e) }, useTransition: function () { var e = xh(ka)[0], t = Cn().memoizedState; return [e, t] }, useMutableSource: zw, useSyncExternalStore: $w, useId: e1, unstable_isNewReconciler: !1 }; function qo(e, t) {
    try { var n = "", r = t; do n += BI(r), r = r.return; while (r); var i = n } catch (o) {
        i = `
Error generating stack: `+ o.message + `
`+ o.stack
    } return { value: e, source: t, stack: i, digest: null }
} function wh(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function rp(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var cL = typeof WeakMap == "function" ? WeakMap : Map; function i1(e, t, n) { n = Pr(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Yc || (Yc = !0, dp = r), rp(e, t) }, n } function o1(e, t, n) { n = Pr(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { rp(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { rp(e, t), typeof r != "function" && (ai === null ? ai = new Set([this]) : ai.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function px(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new cL; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = kL.bind(null, e, t, n), t.then(e, e)) } function mx(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t === null || t.dehydrated !== null), t) return e; e = e.return } while (e !== null); return null } function gx(e, t, n, r, i) { return 1 & e.mode ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Pr(-1, 1), t.tag = 2, si(n, t, 1))), n.lanes |= 1), e) } var uL = Mr.ReactCurrentOwner, Gt = !1; function Vt(e, t, n, r) { t.child = e === null ? Vw(t, null, n, r) : Uo(t, e.child, n, r) } function vx(e, t, n, r, i) { n = n.render; var o = t.ref; return $o(t, i), r = Wp(e, t, n, r, o, i), n = Up(), e !== null && !Gt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Lr(e, t, i)) : (Ae && n && Lp(t), t.flags |= 1, Vt(e, t, r, i), t.child) } function yx(e, t, n, r, i) { if (e === null) { var o = n.type; return typeof o == "function" && !tm(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, s1(e, t, o, r, i)) : (e = Pc(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & i)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : ga, n(s, r) && e.ref === t.ref) return Lr(e, t, i) } return t.flags |= 1, e = ci(o, r), e.ref = t.ref, e.return = t, t.child = e } function s1(e, t, n, r, i) { if (e !== null) { var o = e.memoizedProps; if (ga(o, r) && e.ref === t.ref) { if (Gt = !1, t.pendingProps = r = o, (e.lanes & i) === 0) return t.lanes = e.lanes, Lr(e, t, i); 131072 & e.flags && (Gt = !0) } } return ip(e, t, n, r, i) } function a1(e, t, n) { var r = t.pendingProps, i = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Pe(Do, nn), nn |= n; else { if (!(1073741824 & n)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Pe(Do, nn), nn |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, Pe(Do, nn), nn |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Pe(Do, nn), nn |= r; return Vt(e, t, i, n), t.child } function l1(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function ip(e, t, n, r, i) { var o = Xt(n) ? Ni : Ft.current; return o = jo(t, o), $o(t, i), n = Wp(e, t, n, r, o, i), r = Up(), e !== null && !Gt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Lr(e, t, i)) : (Ae && r && Lp(t), t.flags |= 1, Vt(e, t, n, i), t.child) } function bx(e, t, n, r, i) { if (Xt(n)) { var o = !0; zc(t) } else o = !1; if ($o(t, i), t.stateNode === null) Tc(e, t), Dw(t, n, r), np(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var l = s.context, c = n.contextType; typeof c == "object" && c !== null ? c = kn(c) : (c = Xt(n) ? Ni : Ft.current, c = jo(t, c)); var u = n.getDerivedStateFromProps, f = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function"; f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && ux(t, s, r, c), Qr = !1; var d = t.memoizedState; s.state = d, Wc(t, r, s, i), l = t.memoizedState, a !== r || d !== l || qt.current || Qr ? (typeof u == "function" && (tp(t, n, u, r), l = t.memoizedState), (a = Qr || cx(t, n, a, r, d, l, c)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, Mw(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : Mn(t.type, a), s.props = c, f = t.pendingProps, d = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = kn(l) : (l = Xt(n) ? Ni : Ft.current, l = jo(t, l)); var p = n.getDerivedStateFromProps; (u = typeof p == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== f || d !== l) && ux(t, s, r, l), Qr = !1, d = t.memoizedState, s.state = d, Wc(t, r, s, i); var y = t.memoizedState; a !== f || d !== y || qt.current || Qr ? (typeof p == "function" && (tp(t, n, p, r), y = t.memoizedState), (c = Qr || cx(t, n, c, r, d, y, l) || !1) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, y, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, y, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = y), s.props = r, s.state = y, s.context = l, r = c) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1) } return op(e, t, n, r, o, i) } function op(e, t, n, r, i, o) { l1(e, t); var s = (128 & t.flags) !== 0; if (!r && !s) return i && ix(t, n, !1), Lr(e, t, o); r = t.stateNode, uL.current = t; var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = Uo(t, e.child, null, o), t.child = Uo(t, null, a, o)) : Vt(e, t, a, o), t.memoizedState = r.state, i && ix(t, n, !0), t.child } function c1(e) { var t = e.stateNode; t.pendingContext ? rx(e, t.pendingContext, t.pendingContext !== t.context) : t.context && rx(e, t.context, !1), $p(e, t.containerInfo) } function xx(e, t, n, r, i) { return Wo(), Op(i), t.flags |= 256, Vt(e, t, n, r), t.child } var sp = { dehydrated: null, treeContext: null, retryLane: 0 }; function ap(e) { return { baseLanes: e, cachePool: null, transitions: null } } function u1(e, t, n) { var r, i = t.pendingProps, o = Be.current, s = !1, a = (128 & t.flags) !== 0; if ((r = a) || (r = (e === null || e.memoizedState !== null) && (2 & o) !== 0), r ? (s = !0, t.flags &= -129) : e !== null && e.memoizedState === null || (o |= 1), Pe(Be, 1 & o), e === null) return Jh(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (1 & t.mode ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (a = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, a = { mode: "hidden", children: a }, !(1 & i) && s !== null ? (s.childLanes = 0, s.pendingProps = a) : s = cu(a, i, 0, null), e = $i(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = ap(n), t.memoizedState = sp, e) : Xp(t, a)); if (o = e.memoizedState, o !== null && (r = o.dehydrated, r !== null)) return fL(e, t, a, i, r, o, n); if (s) { s = i.fallback, a = t.mode, o = e.child, r = o.sibling; var l = { mode: "hidden", children: i.children }; return !(1 & a) && t.child !== o ? (i = t.child, i.childLanes = 0, i.pendingProps = l, t.deletions = null) : (i = ci(o, l), i.subtreeFlags = 14680064 & o.subtreeFlags), r !== null ? s = ci(r, s) : (s = $i(s, a, n, null), s.flags |= 2), s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, a = e.child.memoizedState, a = a === null ? ap(n) : { baseLanes: a.baseLanes | n, cachePool: null, transitions: a.transitions }, s.memoizedState = a, s.childLanes = e.childLanes & ~n, t.memoizedState = sp, i } return s = e.child, e = s.sibling, i = ci(s, { mode: "visible", children: i.children }), !(1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Xp(e, t) { return t = cu({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function gc(e, t, n, r) { return r !== null && Op(r), Uo(t, e.child, null, n), e = Xp(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function fL(e, t, n, r, i, o, s) { if (n) return 256 & t.flags ? (t.flags &= -257, r = wh(Error(M(422))), gc(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = cu({ mode: "visible", children: r.children }, i, 0, null), o = $i(o, i, s, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, 1 & t.mode && Uo(t, e.child, null, s), t.child.memoizedState = ap(s), t.memoizedState = sp, o); if (!(1 & t.mode)) return gc(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(M(419)), r = wh(o, r, void 0), gc(e, t, s, r) } if (a = (s & e.childLanes) !== 0, Gt || a) { if (r = lt, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Ir(e, i), Vn(r, e, i, -1)) } return em(), r = wh(Error(M(421))), gc(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = CL.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, rn = oi(i.nextSibling), on = t, Ae = !0, Dn = null, e !== null && (bn[xn++] = Er, bn[xn++] = Rr, bn[xn++] = Hi, Er = e.id, Rr = e.overflow, Hi = t), t = Xp(t, r.children), t.flags |= 4096, t) } function wx(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), ep(e.return, t, n) } function Sh(e, t, n, r, i) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function f1(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (Vt(e, t, r.children, n), r = Be.current, 2 & r) r = 1 & r | 2, t.flags |= 128; else { if (e !== null && 128 & e.flags) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && wx(e, n, t); else if (e.tag === 19) wx(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Pe(Be, r), !(1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && Uc(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Sh(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && Uc(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Sh(t, !0, n, null, o); break; case "together": Sh(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Tc(e, t) { !(1 & t.mode) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Lr(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Wi |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(M(153)); if (t.child !== null) { for (e = t.child, n = ci(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = ci(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function dL(e, t, n) { switch (t.tag) { case 3: c1(t), Wo(); break; case 5: Bw(t); break; case 1: Xt(t.type) && zc(t); break; case 4: $p(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Pe(Hc, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (Pe(Be, 1 & Be.current), t.flags |= 128, null) : n & t.child.childLanes ? u1(e, t, n) : (Pe(Be, 1 & Be.current), e = Lr(e, t, n), e !== null ? e.sibling : null); Pe(Be, 1 & Be.current); break; case 19: if (r = (n & t.childLanes) !== 0, 128 & e.flags) { if (r) return f1(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Pe(Be, Be.current), r) break; return null; case 22: case 23: return t.lanes = 0, a1(e, t, n) }return Lr(e, t, n) } var d1, lp, h1, p1; d1 = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; lp = function () { }; h1 = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, Bi(lr.current); var o = null; switch (n) { case "input": i = Fh(e, i), r = Fh(e, r), o = []; break; case "select": i = $e({}, i, { value: void 0 }), r = $e({}, r, { value: void 0 }), o = []; break; case "textarea": i = Mh(e, i), r = Mh(e, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Vc) }Dh(n, r); var s; n = null; for (c in i) if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null) if (c === "style") { var a = i[c]; for (s in a) a.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (ca.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null)); for (c in r) { var l = r[c]; if (a = i?.[c], r.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]) } else n || (o || (o = []), o.push(c, n)), n = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (ca.hasOwnProperty(c) ? (l != null && c === "onScroll" && Le("scroll", e), o || a === l || (o = [])) : (o = o || []).push(c, l)) } n && (o = o || []).push("style", n); var c = o; (t.updateQueue = c) && (t.flags |= 4) } }; p1 = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function qs(e, t) { if (!Ae) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Pt(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function hL(e, t, n) { var r = t.pendingProps; switch (Mp(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Pt(t), null; case 1: return Xt(t.type) && Bc(), Pt(t), null; case 3: return r = t.stateNode, Go(), Me(qt), Me(Ft), Hp(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), e !== null && e.child !== null || (pc(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(256 & t.flags) || (t.flags |= 1024, Dn !== null && (mp(Dn), Dn = null))), lp(e, t), Pt(t), null; case 5: Np(t); var i = Bi(wa.current); if (n = t.type, e !== null && t.stateNode != null) h1(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(M(166)); return Pt(t), null } if (e = Bi(lr.current), pc(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[sr] = t, r[ba] = o, e = (1 & t.mode) !== 0, n) { case "dialog": Le("cancel", r), Le("close", r); break; case "iframe": case "object": case "embed": Le("load", r); break; case "video": case "audio": for (i = 0; i < Js.length; i++)Le(Js[i], r); break; case "source": Le("error", r); break; case "img": case "image": case "link": Le("error", r), Le("load", r); break; case "details": Le("toggle", r); break; case "input": _b(r, o), Le("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, Le("invalid", r); break; case "textarea": Ib(r, o), Le("invalid", r) }Dh(n, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && hc(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && hc(r.textContent, a, e), i = ["children", "" + a]) : ca.hasOwnProperty(s) && a != null && s === "onScroll" && Le("scroll", r) } switch (n) { case "input": tc(r), Fb(r, o, !0); break; case "textarea": tc(r), Lb(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = Vc) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Nx(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[sr] = t, e[ba] = r, d1(e, t, !1, !1), t.stateNode = e; e: { switch (s = Ah(n, r), n) { case "dialog": Le("cancel", e), Le("close", e), i = r; break; case "iframe": case "object": case "embed": Le("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Js.length; i++)Le(Js[i], e); i = r; break; case "source": Le("error", e), i = r; break; case "img": case "image": case "link": Le("error", e), Le("load", e), i = r; break; case "details": Le("toggle", e), i = r; break; case "input": _b(e, r), i = Fh(e, r), Le("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = $e({}, r, { value: void 0 }), Le("invalid", e); break; case "textarea": Ib(e, r), i = Mh(e, r), Le("invalid", e); break; default: i = r }Dh(n, i), a = i; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? Wx(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Hx(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && ua(e, l) : typeof l == "number" && ua(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (ca.hasOwnProperty(o) ? l != null && o === "onScroll" && Le("scroll", e) : l != null && yp(e, o, l, s)) } switch (n) { case "input": tc(e), Fb(e, r, !1); break; case "textarea": tc(e), Lb(e); break; case "option": r.value != null && e.setAttribute("value", "" + ui(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? Ao(e, !!r.multiple, o, !1) : r.defaultValue != null && Ao(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = Vc) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Pt(t), null; case 6: if (e && t.stateNode != null) p1(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(M(166)); if (n = Bi(wa.current), Bi(lr.current), pc(t)) { if (r = t.stateNode, n = t.memoizedProps, r[sr] = t, (o = r.nodeValue !== n) && (e = on, e !== null)) switch (e.tag) { case 3: hc(r.nodeValue, n, (1 & e.mode) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && hc(r.nodeValue, n, (1 & e.mode) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[sr] = t, t.stateNode = r } return Pt(t), null; case 13: if (Me(Be), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Ae && rn !== null && 1 & t.mode && !(128 & t.flags)) Iw(), Wo(), t.flags |= 98560, o = !1; else if (o = pc(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(M(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(M(317)); o[sr] = t } else Wo(), !(128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Pt(t), o = !1 } else Dn !== null && (mp(Dn), Dn = null), o = !0; if (!o) return 65536 & t.flags ? t : null } return 128 & t.flags ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, 1 & t.mode && (e === null || 1 & Be.current ? rt === 0 && (rt = 3) : em())), t.updateQueue !== null && (t.flags |= 4), Pt(t), null); case 4: return Go(), lp(e, t), e === null && va(t.stateNode.containerInfo), Pt(t), null; case 10: return Vp(t.type._context), Pt(t), null; case 17: return Xt(t.type) && Bc(), Pt(t), null; case 19: if (Me(Be), o = t.memoizedState, o === null) return Pt(t), null; if (r = (128 & t.flags) !== 0, s = o.rendering, s === null) if (r) qs(o, !1); else { if (rt !== 0 || e !== null && 128 & e.flags) for (e = t.child; e !== null;) { if (s = Uc(e), s !== null) { for (t.flags |= 128, qs(o, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, e = s.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Pe(Be, 1 & Be.current | 2), t.child } e = e.sibling } o.tail !== null && Ke() > Xo && (t.flags |= 128, r = !0, qs(o, !1), t.lanes = 4194304) } else { if (!r) if (e = Uc(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), qs(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !Ae) return Pt(t), null } else 2 * Ke() - o.renderingStartTime > Xo && n !== 1073741824 && (t.flags |= 128, r = !0, qs(o, !1), t.lanes = 4194304); o.isBackwards ? (s.sibling = t.child, t.child = s) : (n = o.last, n !== null ? n.sibling = s : t.child = s, o.last = s) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = Ke(), t.sibling = null, n = Be.current, Pe(Be, r ? 1 & n | 2 : 1 & n), t) : (Pt(t), null); case 22: case 23: return Jp(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && 1 & t.mode ? 1073741824 & nn && (Pt(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Pt(t), null; case 24: return null; case 25: return null }throw Error(M(156, t.tag)) } function pL(e, t) { switch (Mp(t), t.tag) { case 1: return Xt(t.type) && Bc(), e = t.flags, 65536 & e ? (t.flags = -65537 & e | 128, t) : null; case 3: return Go(), Me(qt), Me(Ft), Hp(), e = t.flags, 65536 & e && !(128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return Np(t), null; case 13: if (Me(Be), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(M(340)); Wo() } return e = t.flags, 65536 & e ? (t.flags = -65537 & e | 128, t) : null; case 19: return Me(Be), null; case 4: return Go(), null; case 10: return Vp(t.type._context), null; case 22: case 23: return Jp(), null; case 24: return null; default: return null } } var vc = !1, _t = !1, mL = typeof WeakSet == "function" ? WeakSet : Set, B = null; function Oo(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { Ge(e, t, r) } else n.current = null } function m1(e, t, n) { try { n() } catch (r) { Ge(e, t, r) } } var Sx = !1; function gL(e, t) { if (Gh = Oc, e = yw(), Ip(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || I; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, a = -1, l = -1, c = 0, u = 0, f = e, d = null; t: for (; ;) { for (var p; f !== n || i !== 0 && f.nodeType !== 3 || (a = s + i), f !== o || r !== 0 && f.nodeType !== 3 || (l = s + r), f.nodeType === 3 && (s += f.nodeValue.length), (p = f.firstChild) !== null;)d = f, f = p; for (; ;) { if (f === e) break t; if (d === n && ++c === i && (a = s), d === o && ++u === r && (l = s), (p = f.nextSibling) !== null) break; f = d, d = f.parentNode } f = p } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (qh = { focusedElem: e, selectionRange: n }, Oc = !1, B = t; B !== null;)if (t = B, e = t.child, (1028 & t.subtreeFlags) !== 0 && e !== null) e.return = t, B = e; else for (; B !== null;) { t = B; try { var y = t.alternate; if (1024 & t.flags) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (y !== null) { var g = y.memoizedProps, b = y.memoizedState, h = t.stateNode, m = h.getSnapshotBeforeUpdate(t.elementType === t.type ? g : Mn(t.type, g), b); h.__reactInternalSnapshotBeforeUpdate = m } break; case 3: var v = t.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(M(163)) } } catch (w) { Ge(t, t.return, w) } if (e = t.sibling, e !== null) { e.return = t.return, B = e; break } B = t.return } return y = Sx, Sx = !1, y } function sa(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, o !== void 0 && m1(t, n, o) } i = i.next } while (i !== r) } } function au(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function cp(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function g1(e) { var t = e.alternate; t !== null && (e.alternate = null, g1(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[sr], delete t[ba], delete t[Kh], delete t[Z2], delete t[J2])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function v1(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function kx(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || v1(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (2 & e.flags || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function up(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Vc)); else if (r !== 4 && (e = e.child, e !== null)) for (up(e, t, n), e = e.sibling; e !== null;)up(e, t, n), e = e.sibling } function fp(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (fp(e, t, n), e = e.sibling; e !== null;)fp(e, t, n), e = e.sibling } var vt = null, On = !1; function Yr(e, t, n) { for (n = n.child; n !== null;)y1(e, t, n), n = n.sibling } function y1(e, t, n) { if (ar && typeof ar.onCommitFiberUnmount == "function") try { ar.onCommitFiberUnmount(Jc, n) } catch { } switch (n.tag) { case 5: _t || Oo(n, t); case 6: var r = vt, i = On; vt = null, Yr(e, t, n), vt = r, On = i, vt !== null && (On ? (e = vt, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : vt.removeChild(n.stateNode)); break; case 18: vt !== null && (On ? (e = vt, n = n.stateNode, e.nodeType === 8 ? mh(e.parentNode, n) : e.nodeType === 1 && mh(e, n), pa(e)) : mh(vt, n.stateNode)); break; case 4: r = vt, i = On, vt = n.stateNode.containerInfo, On = !0, Yr(e, t, n), vt = r, On = i; break; case 0: case 11: case 14: case 15: if (!_t && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (2 & o || 4 & o) && m1(n, t, s), i = i.next } while (i !== r) } Yr(e, t, n); break; case 1: if (!_t && (Oo(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Ge(n, t, a) } Yr(e, t, n); break; case 21: Yr(e, t, n); break; case 22: 1 & n.mode ? (_t = (r = _t) || n.memoizedState !== null, Yr(e, t, n), _t = r) : Yr(e, t, n); break; default: Yr(e, t, n) } } function Cx(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new mL), t.forEach(function (r) { var i = TL.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function Ln(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: vt = a.stateNode, On = !1; break e; case 3: vt = a.stateNode.containerInfo, On = !0; break e; case 4: vt = a.stateNode.containerInfo, On = !0; break e }a = a.return } if (vt === null) throw Error(M(160)); y1(o, s, i), vt = null, On = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (c) { Ge(i, t, c) } } if (12854 & t.subtreeFlags) for (t = t.child; t !== null;)b1(t, e), t = t.sibling } function b1(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Ln(t, e), ir(e), 4 & r) { try { sa(3, e, e.return), au(3, e) } catch (g) { Ge(e, e.return, g) } try { sa(5, e, e.return) } catch (g) { Ge(e, e.return, g) } } break; case 1: Ln(t, e), ir(e), 512 & r && n !== null && Oo(n, n.return); break; case 5: if (Ln(t, e), ir(e), 512 & r && n !== null && Oo(n, n.return), 32 & e.flags) { var i = e.stateNode; try { ua(i, "") } catch (g) { Ge(e, e.return, g) } } if (4 & r && (i = e.stateNode, i != null)) { var o = e.memoizedProps, s = n !== null ? n.memoizedProps : o, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && zx(i, o), Ah(a, s); var c = Ah(a, o); for (s = 0; s < l.length; s += 2) { var u = l[s], f = l[s + 1]; u === "style" ? Wx(i, f) : u === "dangerouslySetInnerHTML" ? Hx(i, f) : u === "children" ? ua(i, f) : yp(i, u, f, c) } switch (a) { case "input": Ih(i, o); break; case "textarea": $x(i, o); break; case "select": var d = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var p = o.value; p != null ? Ao(i, !!o.multiple, p, !1) : d !== !!o.multiple && (o.defaultValue != null ? Ao(i, !!o.multiple, o.defaultValue, !0) : Ao(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[ba] = o } catch (g) { Ge(e, e.return, g) } } break; case 6: if (Ln(t, e), ir(e), 4 & r) { if (e.stateNode === null) throw Error(M(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (g) { Ge(e, e.return, g) } } break; case 3: if (Ln(t, e), ir(e), 4 & r && n !== null && n.memoizedState.isDehydrated) try { pa(t.containerInfo) } catch (g) { Ge(e, e.return, g) } break; case 4: Ln(t, e), ir(e); break; case 13: Ln(t, e), ir(e), i = e.child, 8192 & i.flags && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (Qp = Ke())), 4 & r && Cx(e); break; case 22: if (u = n !== null && n.memoizedState !== null, 1 & e.mode ? (_t = (c = _t) || u, Ln(t, e), _t = c) : Ln(t, e), ir(e), 8192 & r) { if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !u && 1 & e.mode) for (B = e, u = e.child; u !== null;) { for (f = B = u; B !== null;) { switch (d = B, p = d.child, d.tag) { case 0: case 11: case 14: case 15: sa(4, d, d.return); break; case 1: Oo(d, d.return); var y = d.stateNode; if (typeof y.componentWillUnmount == "function") { r = d, n = d.return; try { t = r, y.props = t.memoizedProps, y.state = t.memoizedState, y.componentWillUnmount() } catch (g) { Ge(r, n, g) } } break; case 5: Oo(d, d.return); break; case 22: if (d.memoizedState !== null) { Ex(f); continue } }p !== null ? (p.return = d, B = p) : Ex(f) } u = u.sibling } e: for (u = null, f = e; ;) { if (f.tag === 5) { if (u === null) { u = f; try { i = f.stateNode, c ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = jx("display", s)) } catch (g) { Ge(e, e.return, g) } } } else if (f.tag === 6) { if (u === null) try { f.stateNode.nodeValue = c ? "" : f.memoizedProps } catch (g) { Ge(e, e.return, g) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === e) break e; for (; f.sibling === null;) { if (f.return === null || f.return === e) break e; u === f && (u = null), f = f.return } u === f && (u = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: Ln(t, e), ir(e), 4 & r && Cx(e); break; case 21: break; default: Ln(t, e), ir(e) } } function ir(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; n !== null;) { if (v1(n)) { var r = n; break e } n = n.return } throw Error(M(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (ua(i, ""), r.flags &= -33); var o = kx(e); fp(e, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = kx(e); up(e, a, s); break; default: throw Error(M(161)) } } catch (l) { Ge(e, e.return, l) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function vL(e, t, n) { B = e, x1(e, t, n) } function x1(e, t, n) { for (var r = (1 & e.mode) !== 0; B !== null;) { var i = B, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || vc; if (!s) { var a = i.alternate, l = a !== null && a.memoizedState !== null || _t; a = vc; var c = _t; if (vc = s, (_t = l) && !c) for (B = i; B !== null;)s = B, l = s.child, s.tag === 22 && s.memoizedState !== null ? Rx(i) : l !== null ? (l.return = s, B = l) : Rx(i); for (; o !== null;)B = o, x1(o, t, n), o = o.sibling; B = i, vc = a, _t = c } Tx(e, t, n) } else 8772 & i.subtreeFlags && o !== null ? (o.return = i, B = o) : Tx(e, t, n) } } function Tx(e) { for (; B !== null;) { var t = B; if (8772 & t.flags) { var n = t.alternate; try { if (8772 & t.flags) switch (t.tag) { case 0: case 11: case 15: _t || au(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !_t) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : Mn(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && lx(t, o, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }lx(t, s, n) } break; case 5: var a = t.stateNode; if (n === null && 4 & t.flags) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var c = t.alternate; if (c !== null) { var u = c.memoizedState; if (u !== null) { var f = u.dehydrated; f !== null && pa(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(M(163)) }_t || 512 & t.flags && cp(t) } catch (d) { Ge(t, t.return, d) } } if (t === e) { B = null; break } if (n = t.sibling, n !== null) { n.return = t.return, B = n; break } B = t.return } } function Ex(e) { for (; B !== null;) { var t = B; if (t === e) { B = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, B = n; break } B = t.return } } function Rx(e) { for (; B !== null;) { var t = B; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { au(4, t) } catch (l) { Ge(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (l) { Ge(t, i, l) } } var o = t.return; try { cp(t) } catch (l) { Ge(t, o, l) } break; case 5: var s = t.return; try { cp(t) } catch (l) { Ge(t, s, l) } } } catch (l) { Ge(t, t.return, l) } if (t === e) { B = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, B = a; break } B = t.return } } var yL = Math.ceil, Xc = Mr.ReactCurrentDispatcher, Yp = Mr.ReactCurrentOwner, Sn = Mr.ReactCurrentBatchConfig, ve = 0, lt = null, Ze = null, yt = 0, nn = 0, Do = hi(0), rt = 0, Ta = null, Wi = 0, lu = 0, Kp = 0, aa = null, Ut = null, Qp = 0, Xo = 1 / 0, Cr = null, Yc = !1, dp = null, ai = null, yc = !1, ti = null, Kc = 0, la = 0, hp = null, Ec = -1, Rc = 0; function Bt() { return 6 & ve ? Ke() : Ec !== -1 ? Ec : Ec = Ke() } function li(e) { return 1 & e.mode ? 2 & ve && yt !== 0 ? yt & -yt : tL.transition !== null ? (Rc === 0 && (Rc = nw()), Rc) : (e = we, e !== 0 || (e = I.event, e = e === void 0 ? 16 : cw(e.type)), e) : 1 } function Vn(e, t, n, r) { if (50 < la) throw la = 0, hp = null, Error(M(185)); Ea(e, n, r), 2 & ve && e === lt || (e === lt && (!(2 & ve) && (lu |= n), rt === 4 && Jr(e, yt)), Yt(e, r), n === 1 && ve === 0 && !(1 & t.mode) && (Xo = Ke() + 500, iu && pi())) } function Yt(e, t) { var n = e.callbackNode; r2(e, t); var r = Mc(e, e === lt ? yt : 0); if (r === 0) n !== null && Db(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Db(n), t === 1) e.tag === 0 ? eL(Px.bind(null, e)) : Pw(Px.bind(null, e)), K2(function () { !(6 & ve) && pi() }), n = null; else { switch (rw(r)) { case 1: n = kp; break; case 4: n = ew; break; case 16: n = Lc; break; case 536870912: n = tw; break; default: n = Lc }n = P1(n, w1.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function w1(e, t) { if (Ec = -1, Rc = 0, 6 & ve) throw Error(M(327)); var n = e.callbackNode; if (No() && e.callbackNode !== n) return null; var r = Mc(e, e === lt ? yt : 0); if (r === 0) return null; if (30 & r || r & e.expiredLanes || t) t = Qc(e, r); else { t = r; var i = ve; ve |= 2; var o = k1(); lt === e && yt === t || (Cr = null, Xo = Ke() + 500, zi(e, t)); do try { wL(); break } catch (a) { S1(e, a) } while (1); Ap(), Xc.current = o, ve = i, Ze !== null ? t = 0 : (lt = null, yt = 0, t = rt) } if (t !== 0) { if (t === 2 && (i = Nh(e), i !== 0 && (r = i, t = pp(e, i))), t === 1) throw n = Ta, zi(e, 0), Jr(e, r), Yt(e, Ke()), n; if (t === 6) Jr(e, r); else { if (i = e.current.alternate, !(30 & r) && !bL(i) && (t = Qc(e, r), t === 2 && (o = Nh(e), o !== 0 && (r = o, t = pp(e, o))), t === 1)) throw n = Ta, zi(e, 0), Jr(e, r), Yt(e, Ke()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(M(345)); case 2: Di(e, Ut, Cr); break; case 3: if (Jr(e, r), (130023424 & r) === r && (t = Qp + 500 - Ke(), 10 < t)) { if (Mc(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { Bt(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = Yh(Di.bind(null, e, Ut, Cr), t); break } Di(e, Ut, Cr); break; case 4: if (Jr(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - An(r); o = 1 << s, s = t[s], s > i && (i = s), r &= ~o } if (r = i, r = Ke() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * yL(r / 1960)) - r, 10 < r) { e.timeoutHandle = Yh(Di.bind(null, e, Ut, Cr), r); break } Di(e, Ut, Cr); break; case 5: Di(e, Ut, Cr); break; default: throw Error(M(329)) } } } return Yt(e, Ke()), e.callbackNode === n ? w1.bind(null, e) : null } function pp(e, t) { var n = aa; return e.current.memoizedState.isDehydrated && (zi(e, t).flags |= 256), e = Qc(e, t), e !== 2 && (t = Ut, Ut = n, t !== null && mp(t)), e } function mp(e) { Ut === null ? Ut = e : Ut.push.apply(Ut, e) } function bL(e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!Bn(o(), i)) return !1 } catch { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function Jr(e, t) { for (t &= ~Kp, t &= ~lu, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - An(t), r = 1 << n; e[n] = -1, t &= ~r } } function Px(e) { if (6 & ve) throw Error(M(327)); No(); var t = Mc(e, 0); if (!(1 & t)) return Yt(e, Ke()), null; var n = Qc(e, t); if (e.tag !== 0 && n === 2) { var r = Nh(e); r !== 0 && (t = r, n = pp(e, r)) } if (n === 1) throw n = Ta, zi(e, 0), Jr(e, t), Yt(e, Ke()), n; if (n === 6) throw Error(M(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Di(e, Ut, Cr), Yt(e, Ke()), null } function Zp(e, t) { var n = ve; ve |= 1; try { return e(t) } finally { ve = n, ve === 0 && (Xo = Ke() + 500, iu && pi()) } } function Ui(e) { ti !== null && ti.tag === 0 && !(6 & ve) && No(); var t = ve; ve |= 1; var n = Sn.transition, r = we; try { if (Sn.transition = null, we = 1, e) return e() } finally { we = r, Sn.transition = n, ve = t, !(6 & ve) && pi() } } function Jp() { nn = Do.current, Me(Do) } function zi(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, Y2(n)), Ze !== null) for (n = Ze.return; n !== null;) { var r = n; switch (Mp(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Bc(); break; case 3: Go(), Me(qt), Me(Ft), Hp(); break; case 5: Np(r); break; case 4: Go(); break; case 13: Me(Be); break; case 19: Me(Be); break; case 10: Vp(r.type._context); break; case 22: case 23: Jp() }n = n.return } if (lt = e, Ze = e = ci(e.current, null), yt = nn = t, rt = 0, Ta = null, Kp = lu = Wi = 0, Ut = aa = null, Vi !== null) { for (t = 0; t < Vi.length; t++)if (n = Vi[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, o = n.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } n.pending = r } Vi = null } return e } function S1(e, t) { do { var n = Ze; try { if (Ap(), kc.current = qc, Gc) { for (var r = ze.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } Gc = !1 } if (ji = 0, at = nt = ze = null, oa = !1, Sa = 0, Yp.current = null, n === null || n.return === null) { rt = 1, Ta = t, Ze = null; break } e: { var o = e, s = n.return, a = n, l = t; if (t = yt, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, u = a, f = u.tag; if (!(1 & u.mode) && (f === 0 || f === 11 || f === 15)) { var d = u.alternate; d ? (u.updateQueue = d.updateQueue, u.memoizedState = d.memoizedState, u.lanes = d.lanes) : (u.updateQueue = null, u.memoizedState = null) } var p = mx(s); if (p !== null) { p.flags &= -257, gx(p, s, a, o, t), 1 & p.mode && px(o, c, t), t = p, l = c; var y = t.updateQueue; if (y === null) { var g = new Set; g.add(l), t.updateQueue = g } else y.add(l); break e } if (!(1 & t)) { px(o, c, t), em(); break e } l = Error(M(426)) } else if (Ae && 1 & a.mode) { var b = mx(s); if (b !== null) { !(65536 & b.flags) && (b.flags |= 256), gx(b, s, a, o, t), Op(qo(l, a)); break e } } o = l = qo(l, a), rt !== 4 && (rt = 2), aa === null ? aa = [o] : aa.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var h = i1(o, l, t); ax(o, h); break e; case 1: a = l; var m = o.type, v = o.stateNode; if (!(128 & o.flags) && (typeof m.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (ai === null || !ai.has(v)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var w = o1(o, a, t); ax(o, w); break e } }o = o.return } while (o !== null) } T1(n) } catch (C) { t = C, Ze === n && n !== null && (Ze = n = n.return); continue } break } while (1) } function k1() { var e = Xc.current; return Xc.current = qc, e === null ? qc : e } function em() { rt !== 0 && rt !== 3 && rt !== 2 || (rt = 4), lt === null || !(268435455 & Wi) && !(268435455 & lu) || Jr(lt, yt) } function Qc(e, t) { var n = ve; ve |= 2; var r = k1(); lt === e && yt === t || (Cr = null, zi(e, t)); do try { xL(); break } catch (i) { S1(e, i) } while (1); if (Ap(), ve = n, Xc.current = r, Ze !== null) throw Error(M(261)); return lt = null, yt = 0, rt } function xL() { for (; Ze !== null;)C1(Ze) } function wL() { for (; Ze !== null && !XI();)C1(Ze) } function C1(e) { var t = R1(e.alternate, e, nn); e.memoizedProps = e.pendingProps, t === null ? T1(e) : Ze = t, Yp.current = null } function T1(e) { var t = e; do { var n = t.alternate; if (e = t.return, 32768 & t.flags) { if (n = pL(n, t), n !== null) { n.flags &= 32767, Ze = n; return } if (e === null) { rt = 6, Ze = null; return } e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } else if (n = hL(n, t, nn), n !== null) { Ze = n; return } if (t = t.sibling, t !== null) { Ze = t; return } Ze = t = e } while (t !== null); rt === 0 && (rt = 5) } function Di(e, t, n) { var r = we, i = Sn.transition; try { Sn.transition = null, we = 1, SL(e, t, n, r) } finally { Sn.transition = i, we = r } return null } function SL(e, t, n, r) { do No(); while (ti !== null); if (6 & ve) throw Error(M(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(M(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (i2(e, o), e === lt && (Ze = lt = null, yt = 0), !(2064 & n.subtreeFlags) && !(2064 & n.flags) || yc || (yc = !0, P1(Lc, function () { return No(), null })), o = (15990 & n.flags) !== 0, 15990 & n.subtreeFlags || o) { o = Sn.transition, Sn.transition = null; var s = we; we = 1; var a = ve; ve |= 4, Yp.current = null, gL(e, n), b1(n, e), W2(qh), Oc = !!Gh, qh = Gh = null, e.current = n, vL(n, e, i), YI(), ve = a, we = s, Sn.transition = o } else e.current = n; if (yc && (yc = !1, ti = e, Kc = i), o = e.pendingLanes, o === 0 && (ai = null), ZI(n.stateNode, r), Yt(e, Ke()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Yc) throw Yc = !1, e = dp, dp = null, e; return 1 & Kc && e.tag !== 0 && No(), o = e.pendingLanes, 1 & o ? e === hp ? la++ : (la = 0, hp = e) : la = 0, pi(), null } function No() { if (ti !== null) { var e = rw(Kc), t = Sn.transition, n = we; try { if (Sn.transition = null, we = 16 > e ? 16 : e, ti === null) var r = !1; else { if (e = ti, ti = null, Kc = 0, 6 & ve) throw Error(M(331)); var i = ve; for (ve |= 4, B = e.current; B !== null;) { var o = B, s = o.child; if (16 & B.flags) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (B = c; B !== null;) { var u = B; switch (u.tag) { case 0: case 11: case 15: sa(8, u, o) }var f = u.child; if (f !== null) f.return = u, B = f; else for (; B !== null;) { u = B; var d = u.sibling, p = u.return; if (g1(u), u === c) { B = null; break } if (d !== null) { d.return = p, B = d; break } B = p } } } var y = o.alternate; if (y !== null) { var g = y.child; if (g !== null) { y.child = null; do { var b = g.sibling; g.sibling = null, g = b } while (g !== null) } } B = o } } if (2064 & o.subtreeFlags && s !== null) s.return = o, B = s; else e: for (; B !== null;) { if (o = B, 2048 & o.flags) switch (o.tag) { case 0: case 11: case 15: sa(9, o, o.return) }var h = o.sibling; if (h !== null) { h.return = o.return, B = h; break e } B = o.return } } var m = e.current; for (B = m; B !== null;) { s = B; var v = s.child; if (2064 & s.subtreeFlags && v !== null) v.return = s, B = v; else e: for (s = m; B !== null;) { if (a = B, 2048 & a.flags) try { switch (a.tag) { case 0: case 11: case 15: au(9, a) } } catch (C) { Ge(a, a.return, C) } if (a === s) { B = null; break e } var w = a.sibling; if (w !== null) { w.return = a.return, B = w; break e } B = a.return } } if (ve = i, pi(), ar && typeof ar.onPostCommitFiberRoot == "function") try { ar.onPostCommitFiberRoot(Jc, e) } catch { } r = !0 } return r } finally { we = n, Sn.transition = t } } return !1 } function _x(e, t, n) { t = qo(n, t), t = i1(e, t, 1), e = si(e, t, 1), t = Bt(), e !== null && (Ea(e, 1, t), Yt(e, t)) } function Ge(e, t, n) { if (e.tag === 3) _x(e, e, n); else for (; t !== null;) { if (t.tag === 3) { _x(t, e, n); break } if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (ai === null || !ai.has(r))) { e = qo(n, e), e = o1(t, e, 1), t = si(t, e, 1), e = Bt(), t !== null && (Ea(t, 1, e), Yt(t, e)); break } } t = t.return } } function kL(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = Bt(), e.pingedLanes |= e.suspendedLanes & n, lt === e && (yt & n) === n && (rt === 4 || rt === 3 && (130023424 & yt) === yt && 500 > Ke() - Qp ? zi(e, 0) : Kp |= n), Yt(e, t) } function E1(e, t) { t === 0 && (1 & e.mode ? (t = ic, ic <<= 1, !(130023424 & ic) && (ic = 4194304)) : t = 1); var n = Bt(); e = Ir(e, t), e !== null && (Ea(e, t, n), Yt(e, n)) } function CL(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), E1(e, n) } function TL(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(M(314)) }r !== null && r.delete(t), E1(e, n) } var R1; R1 = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || qt.current) Gt = !0; else { if (!(e.lanes & n) && !(128 & t.flags)) return Gt = !1, dL(e, t, n); Gt = (131072 & e.flags) !== 0 } else Gt = !1, Ae && 1048576 & t.flags && _w(t, Nc, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Tc(e, t), e = t.pendingProps; var i = jo(t, Ft.current); $o(t, n), i = Wp(null, t, r, e, i, n); var o = Up(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Xt(r) ? (o = !0, zc(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, zp(t), i.updater = ou, t.stateNode = i, i._reactInternals = t, np(t, r, e, n), t = op(null, t, r, !0, o, n)) : (t.tag = 0, Ae && o && Lp(t), Vt(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Tc(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = RL(r), e = Mn(r, e), i) { case 0: t = ip(null, t, r, e, n); break e; case 1: t = bx(null, t, r, e, n); break e; case 11: t = vx(null, t, r, e, n); break e; case 14: t = yx(null, t, r, Mn(r.type, e), n); break e }throw Error(M(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), ip(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), bx(e, t, r, i, n); case 3: e: { if (c1(t), e === null) throw Error(M(387)); r = t.pendingProps, o = t.memoizedState, i = o.element, Mw(e, t), Wc(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) { if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) { i = qo(Error(M(423)), t), t = xx(e, t, r, n, i); break e } if (r !== i) { i = qo(Error(M(424)), t), t = xx(e, t, r, n, i); break e } for (rn = oi(t.stateNode.containerInfo.firstChild), on = t, Ae = !0, Dn = null, n = Vw(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (Wo(), r === i) { t = Lr(e, t, n); break e } Vt(e, t, r, n) } t = t.child } return t; case 5: return Bw(t), e === null && Jh(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, Xh(r, i) ? s = null : o !== null && Xh(r, o) && (t.flags |= 32), l1(e, t), Vt(e, t, s, n), t.child; case 6: return e === null && Jh(t), null; case 13: return u1(e, t, n); case 4: return $p(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Uo(t, null, r, n) : Vt(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), vx(e, t, r, i, n); case 7: return Vt(e, t, t.pendingProps, n), t.child; case 8: return Vt(e, t, t.pendingProps.children, n), t.child; case 12: return Vt(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, Pe(Hc, r._currentValue), r._currentValue = s, o !== null) if (Bn(o.value, s)) { if (o.children === i.children && !qt.current) { t = Lr(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var a = o.dependencies; if (a !== null) { s = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = Pr(-1, n & -n), l.tag = 2; var c = o.updateQueue; if (c !== null) { c = c.shared; var u = c.pending; u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l } } o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), ep(o.return, n, t), a.lanes |= n; break } l = l.next } } else if (o.tag === 10) s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(M(341)); s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), ep(s, n, t), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } Vt(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, $o(t, n), i = kn(i), r = r(i), t.flags |= 1, Vt(e, t, r, n), t.child; case 14: return r = t.type, i = Mn(r, t.pendingProps), i = Mn(r.type, i), yx(e, t, r, i, n); case 15: return s1(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), Tc(e, t), t.tag = 1, Xt(r) ? (e = !0, zc(t)) : e = !1, $o(t, n), Dw(t, r, i), np(t, r, i, n), op(null, t, r, !0, e, n); case 19: return f1(e, t, n); case 22: return a1(e, t, n) }throw Error(M(156, t.tag)) }; function P1(e, t) { return Jx(e, t) } function EL(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function wn(e, t, n, r) { return new EL(e, t, n, r) } function tm(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function RL(e) { if (typeof e == "function") return tm(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === xp) return 11; if (e === wp) return 14 } return 2 } function ci(e, t) { var n = e.alternate; return n === null ? (n = wn(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Pc(e, t, n, r, i, o) { var s = 2; if (r = e, typeof e == "function") tm(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case To: return $i(n.children, i, o, t); case bp: s = 8, i |= 8; break; case Eh: return e = wn(12, n, t, 2 | i), e.elementType = Eh, e.lanes = o, e; case Rh: return e = wn(13, n, t, i), e.elementType = Rh, e.lanes = o, e; case Ph: return e = wn(19, n, t, i), e.elementType = Ph, e.lanes = o, e; case Ax: return cu(n, i, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Ox: s = 10; break e; case Dx: s = 9; break e; case xp: s = 11; break e; case wp: s = 14; break e; case Kr: s = 16, r = null; break e }throw Error(M(130, e == null ? e : typeof e, "")) }return t = wn(s, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t } function $i(e, t, n, r) { return e = wn(7, e, r, t), e.lanes = n, e } function cu(e, t, n, r) { return e = wn(22, e, r, t), e.elementType = Ax, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function kh(e, t, n) { return e = wn(6, e, null, t), e.lanes = n, e } function Ch(e, t, n) { return t = wn(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function PL(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ah(0), this.expirationTimes = ah(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ah(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function nm(e, t, n, r, i, o, s, a, l) { return e = new PL(e, t, n, a, l), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = wn(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, zp(o), e } function _L(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Co, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function _1(e) { if (!e) return fi; e = e._reactInternals; e: { if (qi(e) !== e || e.tag !== 1) throw Error(M(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Xt(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(M(171)) } if (e.tag === 1) { var n = e.type; if (Xt(n)) return Rw(e, n, t) } return t } function F1(e, t, n, r, i, o, s, a, l) { return e = nm(n, r, !0, e, i, o, s, a, l), e.context = _1(null), n = e.current, r = Bt(), i = li(n), o = Pr(r, i), o.callback = t ?? null, si(n, o, i), e.current.lanes = i, Ea(e, i, r), Yt(e, r), e } function uu(e, t, n, r) { var i = t.current, o = Bt(), s = li(i); return n = _1(n), t.context === null ? t.context = n : t.pendingContext = n, t = Pr(o, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = si(i, t, s), e !== null && (Vn(e, i, s, o), Sc(e, i, s)), s } function Zc(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Fx(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function rm(e, t) { Fx(e, t), (e = e.alternate) && Fx(e, t) } function FL() { return null } var I1 = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function im(e) { this._internalRoot = e } fu.prototype.render = im.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(M(409)); uu(e, t, null, null) }; fu.prototype.unmount = im.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Ui(function () { uu(null, e, null, null) }), t[Fr] = null } }; function fu(e) { this._internalRoot = e } fu.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = sw(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Zr.length && t !== 0 && t < Zr[n].priority; n++); Zr.splice(n, 0, e), n === 0 && lw(e) } }; function om(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function du(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Ix() { } function IL(e, t, n, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var c = Zc(s); o.call(c) } } var s = F1(t, r, e, 0, null, !1, !1, "", Ix); return e._reactRootContainer = s, e[Fr] = s.current, va(e.nodeType === 8 ? e.parentNode : e), Ui(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var c = Zc(l); a.call(c) } } var l = nm(e, 0, !1, null, null, !1, !1, "", Ix); return e._reactRootContainer = l, e[Fr] = l.current, va(e.nodeType === 8 ? e.parentNode : e), Ui(function () { uu(t, l, n, r) }), l } function hu(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var a = i; i = function () { var l = Zc(s); a.call(l) } } uu(t, s, e, i) } else s = IL(n, t, e, i, r); return Zc(s) } iw = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Zs(t.pendingLanes); n !== 0 && (Cp(t, 1 | n), Yt(t, Ke()), !(6 & ve) && (Xo = Ke() + 500, pi())) } break; case 13: Ui(function () { var r = Ir(e, 1); if (r !== null) { var i = Bt(); Vn(r, e, 1, i) } }), rm(e, 1) } }; Tp = function (e) { if (e.tag === 13) { var t = Ir(e, 134217728); if (t !== null) { var n = Bt(); Vn(t, e, 134217728, n) } rm(e, 134217728) } }; ow = function (e) { if (e.tag === 13) { var t = li(e), n = Ir(e, t); if (n !== null) { var r = Bt(); Vn(n, e, t, r) } rm(e, t) } }; sw = function () { return we }; aw = function (e, t) { var n = we; try { return we = e, t() } finally { we = n } }; Bh = function (e, t, n) { switch (t) { case "input": if (Ih(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = ru(r); if (!i) throw Error(M(90)); Bx(r), Ih(r, i) } } } break; case "textarea": $x(e, n); break; case "select": t = n.value, t != null && Ao(e, !!n.multiple, t, !1) } }; qx = Zp; Xx = Ui; var LL = { usingClientEntryPoint: !1, Events: [Pa, _o, ru, Ux, Gx, Zp] }, Xs = { findFiberByHostInstance: Ai, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, ML = { bundleType: Xs.bundleType, version: Xs.version, rendererPackageName: Xs.rendererPackageName, rendererConfig: Xs.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Mr.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Qx(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Xs.findFiberByHostInstance || FL, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Ys = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Ys.isDisabled && Ys.supportsFiber)) try { Jc = Ys.inject(ML), ar = Ys } catch { } var Ys; an.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LL; an.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!om(t)) throw Error(M(200)); return _L(e, t, null, n) }; an.createRoot = function (e, t) { if (!om(e)) throw Error(M(299)); var n = !1, r = "", i = I1; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = nm(e, 1, !1, null, null, n, !1, r, i), e[Fr] = t.current, va(e.nodeType === 8 ? e.parentNode : e), new im(t) }; an.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(M(188)) : (e = Object.keys(e).join(","), Error(M(268, e))); return e = Qx(t), e = e === null ? null : e.stateNode, e }; an.flushSync = function (e) { return Ui(e) }; an.hydrate = function (e, t, n) { if (!du(t)) throw Error(M(200)); return hu(null, e, t, !0, n) }; an.hydrateRoot = function (e, t, n) { if (!om(e)) throw Error(M(405)); var r = n != null && n.hydratedSources || null, i = !1, o = "", s = I1; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = F1(t, null, e, 1, n ?? null, i, !1, o, s), e[Fr] = t.current, va(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new fu(t) }; an.render = function (e, t, n) { if (!du(t)) throw Error(M(200)); return hu(null, e, t, !1, n) }; an.unmountComponentAtNode = function (e) { if (!du(e)) throw Error(M(40)); return !!e._reactRootContainer && (Ui(function () { hu(null, null, e, !1, function () { e._reactRootContainer = null, e[Fr] = null }) }), !0) }; an.unstable_batchedUpdates = Zp; an.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!du(n)) throw Error(M(200)); if (e == null || e._reactInternals === void 0) throw Error(M(38)); return hu(e, t, n, !1, r) }; an.version = "18.2.0-next-9e3b772b8-20220608"; function L1() { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE == "function") try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(L1) } catch (e) { console.error(e) } } L1(); var cn = an, M1 = cn, OL = cn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, DL = cn.createPortal, AL = cn.createRoot, VL = cn.findDOMNode, BL = cn.flushSync, zL = cn.hydrate, $L = cn.hydrateRoot, NL = cn.render, HL = cn.unmountComponentAtNode, jL = cn.unstable_batchedUpdates, WL = cn.unstable_renderSubtreeIntoContainer, UL = cn.version; var qL = gn({ "../../../node_modules/hsluv/dist/hsluv.cjs"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Hsluv = void 0; var t = class { constructor() { this.hex = "#000000", this.rgb_r = 0, this.rgb_g = 0, this.rgb_b = 0, this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0, this.luv_l = 0, this.luv_u = 0, this.luv_v = 0, this.lch_l = 0, this.lch_c = 0, this.lch_h = 0, this.hsluv_h = 0, this.hsluv_s = 0, this.hsluv_l = 0, this.hpluv_h = 0, this.hpluv_p = 0, this.hpluv_l = 0, this.r0s = 0, this.r0i = 0, this.r1s = 0, this.r1i = 0, this.g0s = 0, this.g0i = 0, this.g1s = 0, this.g1i = 0, this.b0s = 0, this.b0i = 0, this.b1s = 0, this.b1i = 0 } static fromLinear(n) { return n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055 } static toLinear(n) { return n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92 } static yToL(n) { return n <= t.epsilon ? n / t.refY * t.kappa : 116 * Math.pow(n / t.refY, 1 / 3) - 16 } static lToY(n) { return n <= 8 ? t.refY * n / t.kappa : t.refY * Math.pow((n + 16) / 116, 3) } static rgbChannelToHex(n) { let r = Math.round(n * 255), i = r % 16, o = (r - i) / 16 | 0; return t.hexChars.charAt(o) + t.hexChars.charAt(i) } static hexToRgbChannel(n, r) { let i = t.hexChars.indexOf(n.charAt(r)), o = t.hexChars.indexOf(n.charAt(r + 1)); return (i * 16 + o) / 255 } static distanceFromOriginAngle(n, r, i) { let o = r / (Math.sin(i) - n * Math.cos(i)); return o < 0 ? 1 / 0 : o } static distanceFromOrigin(n, r) { return Math.abs(r) / Math.sqrt(Math.pow(n, 2) + 1) } static min6(n, r, i, o, s, a) { return Math.min(n, Math.min(r, Math.min(i, Math.min(o, Math.min(s, a))))) } rgbToHex() { this.hex = "#", this.hex += t.rgbChannelToHex(this.rgb_r), this.hex += t.rgbChannelToHex(this.rgb_g), this.hex += t.rgbChannelToHex(this.rgb_b) } hexToRgb() { this.hex = this.hex.toLowerCase(), this.rgb_r = t.hexToRgbChannel(this.hex, 1), this.rgb_g = t.hexToRgbChannel(this.hex, 3), this.rgb_b = t.hexToRgbChannel(this.hex, 5) } xyzToRgb() { this.rgb_r = t.fromLinear(t.m_r0 * this.xyz_x + t.m_r1 * this.xyz_y + t.m_r2 * this.xyz_z), this.rgb_g = t.fromLinear(t.m_g0 * this.xyz_x + t.m_g1 * this.xyz_y + t.m_g2 * this.xyz_z), this.rgb_b = t.fromLinear(t.m_b0 * this.xyz_x + t.m_b1 * this.xyz_y + t.m_b2 * this.xyz_z) } rgbToXyz() { let n = t.toLinear(this.rgb_r), r = t.toLinear(this.rgb_g), i = t.toLinear(this.rgb_b); this.xyz_x = .41239079926595 * n + .35758433938387 * r + .18048078840183 * i, this.xyz_y = .21263900587151 * n + .71516867876775 * r + .072192315360733 * i, this.xyz_z = .019330818715591 * n + .11919477979462 * r + .95053215224966 * i } xyzToLuv() { let n = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z, r = 4 * this.xyz_x, i = 9 * this.xyz_y; n !== 0 ? (r /= n, i /= n) : (r = NaN, i = NaN), this.luv_l = t.yToL(this.xyz_y), this.luv_l === 0 ? (this.luv_u = 0, this.luv_v = 0) : (this.luv_u = 13 * this.luv_l * (r - t.refU), this.luv_v = 13 * this.luv_l * (i - t.refV)) } luvToXyz() { if (this.luv_l === 0) { this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0; return } let n = this.luv_u / (13 * this.luv_l) + t.refU, r = this.luv_v / (13 * this.luv_l) + t.refV; this.xyz_y = t.lToY(this.luv_l), this.xyz_x = 0 - 9 * this.xyz_y * n / ((n - 4) * r - n * r), this.xyz_z = (9 * this.xyz_y - 15 * r * this.xyz_y - r * this.xyz_x) / (3 * r) } luvToLch() { if (this.lch_l = this.luv_l, this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v), this.lch_c < 1e-8) this.lch_h = 0; else { let n = Math.atan2(this.luv_v, this.luv_u); this.lch_h = n * 180 / Math.PI, this.lch_h < 0 && (this.lch_h = 360 + this.lch_h) } } lchToLuv() { let n = this.lch_h / 180 * Math.PI; this.luv_l = this.lch_l, this.luv_u = Math.cos(n) * this.lch_c, this.luv_v = Math.sin(n) * this.lch_c } calculateBoundingLines(n) { let r = Math.pow(n + 16, 3) / 1560896, i = r > t.epsilon ? r : n / t.kappa, o = i * (284517 * t.m_r0 - 94839 * t.m_r2), s = i * (838422 * t.m_r2 + 769860 * t.m_r1 + 731718 * t.m_r0), a = i * (632260 * t.m_r2 - 126452 * t.m_r1), l = i * (284517 * t.m_g0 - 94839 * t.m_g2), c = i * (838422 * t.m_g2 + 769860 * t.m_g1 + 731718 * t.m_g0), u = i * (632260 * t.m_g2 - 126452 * t.m_g1), f = i * (284517 * t.m_b0 - 94839 * t.m_b2), d = i * (838422 * t.m_b2 + 769860 * t.m_b1 + 731718 * t.m_b0), p = i * (632260 * t.m_b2 - 126452 * t.m_b1); this.r0s = o / a, this.r0i = s * n / a, this.r1s = o / (a + 126452), this.r1i = (s - 769860) * n / (a + 126452), this.g0s = l / u, this.g0i = c * n / u, this.g1s = l / (u + 126452), this.g1i = (c - 769860) * n / (u + 126452), this.b0s = f / p, this.b0i = d * n / p, this.b1s = f / (p + 126452), this.b1i = (d - 769860) * n / (p + 126452) } calcMaxChromaHpluv() { let n = t.distanceFromOrigin(this.r0s, this.r0i), r = t.distanceFromOrigin(this.r1s, this.r1i), i = t.distanceFromOrigin(this.g0s, this.g0i), o = t.distanceFromOrigin(this.g1s, this.g1i), s = t.distanceFromOrigin(this.b0s, this.b0i), a = t.distanceFromOrigin(this.b1s, this.b1i); return t.min6(n, r, i, o, s, a) } calcMaxChromaHsluv(n) { let r = n / 360 * Math.PI * 2, i = t.distanceFromOriginAngle(this.r0s, this.r0i, r), o = t.distanceFromOriginAngle(this.r1s, this.r1i, r), s = t.distanceFromOriginAngle(this.g0s, this.g0i, r), a = t.distanceFromOriginAngle(this.g1s, this.g1i, r), l = t.distanceFromOriginAngle(this.b0s, this.b0i, r), c = t.distanceFromOriginAngle(this.b1s, this.b1i, r); return t.min6(i, o, s, a, l, c) } hsluvToLch() { if (this.hsluv_l > 99.9999999) this.lch_l = 100, this.lch_c = 0; else if (this.hsluv_l < 1e-8) this.lch_l = 0, this.lch_c = 0; else { this.lch_l = this.hsluv_l, this.calculateBoundingLines(this.hsluv_l); let n = this.calcMaxChromaHsluv(this.hsluv_h); this.lch_c = n / 100 * this.hsluv_s } this.lch_h = this.hsluv_h } lchToHsluv() { if (this.lch_l > 99.9999999) this.hsluv_s = 0, this.hsluv_l = 100; else if (this.lch_l < 1e-8) this.hsluv_s = 0, this.hsluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let n = this.calcMaxChromaHsluv(this.lch_h); this.hsluv_s = this.lch_c / n * 100, this.hsluv_l = this.lch_l } this.hsluv_h = this.lch_h } hpluvToLch() { if (this.hpluv_l > 99.9999999) this.lch_l = 100, this.lch_c = 0; else if (this.hpluv_l < 1e-8) this.lch_l = 0, this.lch_c = 0; else { this.lch_l = this.hpluv_l, this.calculateBoundingLines(this.hpluv_l); let n = this.calcMaxChromaHpluv(); this.lch_c = n / 100 * this.hpluv_p } this.lch_h = this.hpluv_h } lchToHpluv() { if (this.lch_l > 99.9999999) this.hpluv_p = 0, this.hpluv_l = 100; else if (this.lch_l < 1e-8) this.hpluv_p = 0, this.hpluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let n = this.calcMaxChromaHpluv(); this.hpluv_p = this.lch_c / n * 100, this.hpluv_l = this.lch_l } this.hpluv_h = this.lch_h } hsluvToRgb() { this.hsluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hpluvToRgb() { this.hpluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hsluvToHex() { this.hsluvToRgb(), this.rgbToHex() } hpluvToHex() { this.hpluvToRgb(), this.rgbToHex() } rgbToHsluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHsluv() } rgbToHpluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHpluv() } hexToHsluv() { this.hexToRgb(), this.rgbToHsluv() } hexToHpluv() { this.hexToRgb(), this.rgbToHpluv() } }; e.Hsluv = t, t.hexChars = "0123456789abcdef", t.refY = 1, t.refU = .19783000664283, t.refV = .46831999493879, t.kappa = 903.2962962, t.epsilon = .0088564516, t.m_r0 = 3.240969941904521, t.m_r1 = -1.537383177570093, t.m_r2 = -.498610760293, t.m_g0 = -.96924363628087, t.m_g1 = 1.87596750150772, t.m_g2 = .041555057407175, t.m_b0 = .055630079696993, t.m_b1 = -.20397695888897, t.m_b2 = 1.056971514242878 } }), XL = gn({ "../../../node_modules/eventemitter3/index.js"(e, t) { "use strict"; var n = Object.prototype.hasOwnProperty, r = "~"; function i() { } Object.create && (i.prototype = Object.create(null), new i().__proto__ || (r = !1)); function o(c, u, f) { this.fn = c, this.context = u, this.once = f || !1 } function s(c, u, f, d, p) { if (typeof f != "function") throw new TypeError("The listener must be a function"); var y = new o(f, d || c, p), g = r ? r + u : u; return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], y] : c._events[g].push(y) : (c._events[g] = y, c._eventsCount++), c } function a(c, u) { --c._eventsCount === 0 ? c._events = new i : delete c._events[u] } function l() { this._events = new i, this._eventsCount = 0 } l.prototype.eventNames = function () { var u = [], f, d; if (this._eventsCount === 0) return u; for (d in f = this._events) n.call(f, d) && u.push(r ? d.slice(1) : d); return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u }, l.prototype.listeners = function (u) { var f = r ? r + u : u, d = this._events[f]; if (!d) return []; if (d.fn) return [d.fn]; for (var p = 0, y = d.length, g = new Array(y); p < y; p++)g[p] = d[p].fn; return g }, l.prototype.listenerCount = function (u) { var f = r ? r + u : u, d = this._events[f]; return d ? d.fn ? 1 : d.length : 0 }, l.prototype.emit = function (u, f, d, p, y, g) { var b = r ? r + u : u; if (!this._events[b]) return !1; var h = this._events[b], m = arguments.length, v, w; if (h.fn) { switch (h.once && this.removeListener(u, h.fn, void 0, !0), m) { case 1: return h.fn.call(h.context), !0; case 2: return h.fn.call(h.context, f), !0; case 3: return h.fn.call(h.context, f, d), !0; case 4: return h.fn.call(h.context, f, d, p), !0; case 5: return h.fn.call(h.context, f, d, p, y), !0; case 6: return h.fn.call(h.context, f, d, p, y, g), !0 }for (w = 1, v = new Array(m - 1); w < m; w++)v[w - 1] = arguments[w]; h.fn.apply(h.context, v) } else { var C = h.length, S; for (w = 0; w < C; w++)switch (h[w].once && this.removeListener(u, h[w].fn, void 0, !0), m) { case 1: h[w].fn.call(h[w].context); break; case 2: h[w].fn.call(h[w].context, f); break; case 3: h[w].fn.call(h[w].context, f, d); break; case 4: h[w].fn.call(h[w].context, f, d, p); break; default: if (!v) for (S = 1, v = new Array(m - 1); S < m; S++)v[S - 1] = arguments[S]; h[w].fn.apply(h[w].context, v) } } return !0 }, l.prototype.on = function (u, f, d) { return s(this, u, f, d, !1) }, l.prototype.once = function (u, f, d) { return s(this, u, f, d, !0) }, l.prototype.removeListener = function (u, f, d, p) { var y = r ? r + u : u; if (!this._events[y]) return this; if (!f) return a(this, y), this; var g = this._events[y]; if (g.fn) g.fn === f && (!p || g.once) && (!d || g.context === d) && a(this, y); else { for (var b = 0, h = [], m = g.length; b < m; b++)(g[b].fn !== f || p && !g[b].once || d && g[b].context !== d) && h.push(g[b]); h.length ? this._events[y] = h.length === 1 ? h[0] : h : a(this, y) } return this }, l.prototype.removeAllListeners = function (u) { var f; return u ? (f = r ? r + u : u, this._events[f] && a(this, f)) : (this._events = new i, this._eventsCount = 0), this }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = r, l.EventEmitter = l, typeof t < "u" && (t.exports = l) } }), Jm = gn({ "../../../node_modules/process/browser.js"(e, t) { var n = t.exports = {}, r, i; function o() { throw new Error("setTimeout has not been defined") } function s() { throw new Error("clearTimeout has not been defined") } (function () { try { typeof setTimeout == "function" ? r = setTimeout : r = o } catch { r = o } try { typeof clearTimeout == "function" ? i = clearTimeout : i = s } catch { i = s } })(); function a(h) { if (r === setTimeout) return setTimeout(h, 0); if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(h, 0); try { return r(h, 0) } catch { try { return r.call(null, h, 0) } catch { return r.call(this, h, 0) } } } function l(h) { if (i === clearTimeout) return clearTimeout(h); if ((i === s || !i) && clearTimeout) return i = clearTimeout, clearTimeout(h); try { return i(h) } catch { try { return i.call(null, h) } catch { return i.call(this, h) } } } var c = [], u = !1, f, d = -1; function p() { !u || !f || (u = !1, f.length ? c = f.concat(c) : d = -1, c.length && y()) } function y() { if (!u) { var h = a(p); u = !0; for (var m = c.length; m;) { for (f = c, c = []; ++d < m;)f && f[d].run(); d = -1, m = c.length } f = null, u = !1, l(h) } } n.nextTick = function (h) { var m = new Array(arguments.length - 1); if (arguments.length > 1) for (var v = 1; v < arguments.length; v++)m[v - 1] = arguments[v]; c.push(new g(h, m)), c.length === 1 && !u && a(y) }; function g(h, m) { this.fun = h, this.array = m } g.prototype.run = function () { this.fun.apply(null, this.array) }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}; function b() { } n.on = b, n.addListener = b, n.once = b, n.off = b, n.removeListener = b, n.removeAllListeners = b, n.emit = b, n.prependListener = b, n.prependOnceListener = b, n.listeners = function (h) { return [] }, n.binding = function (h) { throw new Error("process.binding is not supported") }, n.cwd = function () { return "/" }, n.chdir = function (h) { throw new Error("process.chdir is not supported") }, n.umask = function () { return 0 } } }), YL = gn({ "../../../node_modules/@juggle/resize-observer/lib/exports/resize-observer.umd.js"(e, t) { (function (n, r) { typeof e == "object" && typeof t < "u" ? r(e) : typeof define == "function" && define.amd ? define(["exports"], r) : (n = typeof globalThis < "u" ? globalThis : n || self, r(n.ResizeObserver = {})) })(e, function (n) { "use strict"; var r = [], i = function () { return r.some(function (P) { return P.activeTargets.length > 0 }) }, o = function () { return r.some(function (P) { return P.skippedTargets.length > 0 }) }, s = "ResizeObserver loop completed with undelivered notifications.", a = function () { var P; typeof ErrorEvent == "function" ? P = new ErrorEvent("error", { message: s }) : (P = document.createEvent("Event"), P.initEvent("error", !1, !1), P.message = s), I.dispatchEvent(P) }, l; (function (P) { P.BORDER_BOX = "border-box", P.CONTENT_BOX = "content-box", P.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box" })(l || (l = {})); var c = function (P) { return Object.freeze(P) }, u = function () { function P(_, O) { this.inlineSize = _, this.blockSize = O, c(this) } return P }(), f = function () { function P(_, O, j, ge) { return this.x = _, this.y = O, this.width = j, this.height = ge, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, c(this) } return P.prototype.toJSON = function () { var _ = this, O = _.x, j = _.y, ge = _.top, Mt = _.right, pt = _.bottom, Xe = _.left, mr = _.width, Jt = _.height; return { x: O, y: j, top: ge, right: Mt, bottom: pt, left: Xe, width: mr, height: Jt } }, P.fromRect = function (_) { return new P(_.x, _.y, _.width, _.height) }, P }(), d = function (P) { return P instanceof SVGElement && "getBBox" in P }, p = function (P) { if (d(P)) { var _ = P.getBBox(), O = _.width, j = _.height; return !O && !j } var ge = P, Mt = ge.offsetWidth, pt = ge.offsetHeight; return !(Mt || pt || P.getClientRects().length) }, y = function (P) { var _, O; if (P instanceof Element) return !0; var j = (O = (_ = P) === null || _ === void 0 ? void 0 : _.ownerDocument) === null || O === void 0 ? void 0 : O.defaultView; return !!(j && P instanceof j.Element) }, g = function (P) { switch (P.tagName) { case "INPUT": if (P.type !== "image") break; case "VIDEO": case "AUDIO": case "EMBED": case "OBJECT": case "CANVAS": case "IFRAME": case "IMG": return !0 }return !1 }, b = typeof I < "u" ? I : {}, h = new WeakMap, m = /auto|scroll/, v = /^tb|vertical/, w = /msie|trident/i.test(b.navigator && b.navigator.userAgent), C = function (P) { return parseFloat(P || "0") }, S = function (P, _, O) { return P === void 0 && (P = 0), _ === void 0 && (_ = 0), O === void 0 && (O = !1), new u((O ? _ : P) || 0, (O ? P : _) || 0) }, R = c({ devicePixelContentBoxSize: S(), borderBoxSize: S(), contentBoxSize: S(), contentRect: new f(0, 0, 0, 0) }), E = function (P, _) { if (_ === void 0 && (_ = !1), h.has(P) && !_) return h.get(P); if (p(P)) return h.set(P, R), R; var O = getComputedStyle(P), j = d(P) && P.ownerSVGElement && P.getBBox(), ge = !w && O.boxSizing === "border-box", Mt = v.test(O.writingMode || ""), pt = !j && m.test(O.overflowY || ""), Xe = !j && m.test(O.overflowX || ""), mr = j ? 0 : C(O.paddingTop), Jt = j ? 0 : C(O.paddingRight), Ci = j ? 0 : C(O.paddingBottom), ro = j ? 0 : C(O.paddingLeft), ST = j ? 0 : C(O.borderTopWidth), kT = j ? 0 : C(O.borderRightWidth), CT = j ? 0 : C(O.borderBottomWidth), TT = j ? 0 : C(O.borderLeftWidth), Pg = ro + Jt, _g = mr + Ci, hf = TT + kT, pf = ST + CT, Fg = Xe ? P.offsetHeight - pf - P.clientHeight : 0, Ig = pt ? P.offsetWidth - hf - P.clientWidth : 0, ET = ge ? Pg + hf : 0, RT = ge ? _g + pf : 0, ul = j ? j.width : C(O.width) - ET - Ig, fl = j ? j.height : C(O.height) - RT - Fg, PT = ul + Pg + Ig + hf, _T = fl + _g + Fg + pf, Lg = c({ devicePixelContentBoxSize: S(Math.round(ul * devicePixelRatio), Math.round(fl * devicePixelRatio), Mt), borderBoxSize: S(PT, _T, Mt), contentBoxSize: S(ul, fl, Mt), contentRect: new f(ro, mr, ul, fl) }); return h.set(P, Lg), Lg }, L = function (P, _, O) { var j = E(P, O), ge = j.borderBoxSize, Mt = j.contentBoxSize, pt = j.devicePixelContentBoxSize; switch (_) { case l.DEVICE_PIXEL_CONTENT_BOX: return pt; case l.BORDER_BOX: return ge; default: return Mt } }, F = function () { function P(_) { var O = E(_); this.target = _, this.contentRect = O.contentRect, this.borderBoxSize = c([O.borderBoxSize]), this.contentBoxSize = c([O.contentBoxSize]), this.devicePixelContentBoxSize = c([O.devicePixelContentBoxSize]) } return P }(), N = function (P) { if (p(P)) return 1 / 0; for (var _ = 0, O = P.parentNode; O;)_ += 1, O = O.parentNode; return _ }, A = function () { var P = 1 / 0, _ = []; r.forEach(function (pt) { if (pt.activeTargets.length !== 0) { var Xe = []; pt.activeTargets.forEach(function (Jt) { var Ci = new F(Jt.target), ro = N(Jt.target); Xe.push(Ci), Jt.lastReportedSize = L(Jt.target, Jt.observedBox), ro < P && (P = ro) }), _.push(function () { pt.callback.call(pt.observer, Xe, pt.observer) }), pt.activeTargets.splice(0, pt.activeTargets.length) } }); for (var O = 0, j = _; O < j.length; O++) { var ge = j[O]; ge() } return P }, K = function (P) { r.forEach(function (O) { O.activeTargets.splice(0, O.activeTargets.length), O.skippedTargets.splice(0, O.skippedTargets.length), O.observationTargets.forEach(function (ge) { ge.isActive() && (N(ge.target) > P ? O.activeTargets.push(ge) : O.skippedTargets.push(ge)) }) }) }, U = function () { var P = 0; for (K(P); i();)P = A(), K(P); return o() && a(), P > 0 }, H, W = [], ee = function () { return W.splice(0).forEach(function (P) { return P() }) }, te = function (P) { if (!H) { var _ = 0, O = document.createTextNode(""), j = { characterData: !0 }; new MutationObserver(function () { return ee() }).observe(O, j), H = function () { O.textContent = "" + (_ ? _-- : _++) } } W.push(P), H() }, q = function (P) { te(function () { requestAnimationFrame(P) }) }, ne = 0, be = function () { return !!ne }, re = 250, pe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, ie = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], ht = function (P) { return P === void 0 && (P = 0), Date.now() + P }, Fe = !1, Lt = function () { function P() { var _ = this; this.stopped = !0, this.listener = function () { return _.schedule() } } return P.prototype.run = function (_) { var O = this; if (_ === void 0 && (_ = re), !Fe) { Fe = !0; var j = ht(_); q(function () { var ge = !1; try { ge = U() } finally { if (Fe = !1, _ = j - ht(), !be()) return; ge ? O.run(1e3) : _ > 0 ? O.run(_) : O.start() } }) } }, P.prototype.schedule = function () { this.stop(), this.run() }, P.prototype.observe = function () { var _ = this, O = function () { return _.observer && _.observer.observe(document.body, pe) }; document.body ? O() : b.addEventListener("DOMContentLoaded", O) }, P.prototype.start = function () { var _ = this; this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), ie.forEach(function (O) { return b.addEventListener(O, _.listener, !0) })) }, P.prototype.stop = function () { var _ = this; this.stopped || (this.observer && this.observer.disconnect(), ie.forEach(function (O) { return b.removeEventListener(O, _.listener, !0) }), this.stopped = !0) }, P }(), Se = new Lt, Zt = function (P) { !ne && P > 0 && Se.start(), ne += P, !ne && Se.stop() }, Pn = function (P) { return !d(P) && !g(P) && getComputedStyle(P).display === "inline" }, _n = function () { function P(_, O) { this.target = _, this.observedBox = O || l.CONTENT_BOX, this.lastReportedSize = { inlineSize: 0, blockSize: 0 } } return P.prototype.isActive = function () { var _ = L(this.target, this.observedBox, !0); return Pn(this.target) && (this.lastReportedSize = _), this.lastReportedSize.inlineSize !== _.inlineSize || this.lastReportedSize.blockSize !== _.blockSize }, P }(), me = function () { function P(_, O) { this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = _, this.callback = O } return P }(), Gn = new WeakMap, ot = function (P, _) { for (var O = 0; O < P.length; O += 1)if (P[O].target === _) return O; return -1 }, hn = function () { function P() { } return P.connect = function (_, O) { var j = new me(_, O); Gn.set(_, j) }, P.observe = function (_, O, j) { var ge = Gn.get(_), Mt = ge.observationTargets.length === 0; ot(ge.observationTargets, O) < 0 && (Mt && r.push(ge), ge.observationTargets.push(new _n(O, j && j.box)), Zt(1), Se.schedule()) }, P.unobserve = function (_, O) { var j = Gn.get(_), ge = ot(j.observationTargets, O), Mt = j.observationTargets.length === 1; ge >= 0 && (Mt && r.splice(r.indexOf(j), 1), j.observationTargets.splice(ge, 1), Zt(-1)) }, P.disconnect = function (_) { var O = this, j = Gn.get(_); j.observationTargets.slice().forEach(function (ge) { return O.unobserve(_, ge.target) }), j.activeTargets.splice(0, j.activeTargets.length) }, P }(), cl = function () { function P(_) { if (arguments.length === 0) throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present."); if (typeof _ != "function") throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function."); hn.connect(this, _) } return P.prototype.observe = function (_, O) { if (arguments.length === 0) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present."); if (!y(_)) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element"); hn.observe(this, _, O) }, P.prototype.unobserve = function (_) { if (arguments.length === 0) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present."); if (!y(_)) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element"); hn.unobserve(this, _) }, P.prototype.disconnect = function () { hn.disconnect(this) }, P.toString = function () { return "function ResizeObserver () { [polyfill code] }" }, P }(); n.ResizeObserver = cl, n.ResizeObserverEntry = F, n.ResizeObserverSize = u, Object.defineProperty(n, "__esModule", { value: !0 }) }) } }), KL = gn({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(e) { "use strict"; var t = typeof Symbol == "function" && Symbol.for, n = t ? Symbol.for("react.element") : 60103, r = t ? Symbol.for("react.portal") : 60106, i = t ? Symbol.for("react.fragment") : 60107, o = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, l = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, f = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, p = t ? Symbol.for("react.suspense_list") : 60120, y = t ? Symbol.for("react.memo") : 60115, g = t ? Symbol.for("react.lazy") : 60116, b = t ? Symbol.for("react.block") : 60121, h = t ? Symbol.for("react.fundamental") : 60117, m = t ? Symbol.for("react.responder") : 60118, v = t ? Symbol.for("react.scope") : 60119; function w(S) { if (typeof S == "object" && S !== null) { var R = S.$$typeof; switch (R) { case n: switch (S = S.type, S) { case c: case u: case i: case s: case o: case d: return S; default: switch (S = S && S.$$typeof, S) { case l: case f: case g: case y: case a: return S; default: return R } }case r: return R } } } function C(S) { return w(S) === u } e.AsyncMode = c, e.ConcurrentMode = u, e.ContextConsumer = l, e.ContextProvider = a, e.Element = n, e.ForwardRef = f, e.Fragment = i, e.Lazy = g, e.Memo = y, e.Portal = r, e.Profiler = s, e.StrictMode = o, e.Suspense = d, e.isAsyncMode = function (S) { return C(S) || w(S) === c }, e.isConcurrentMode = C, e.isContextConsumer = function (S) { return w(S) === l }, e.isContextProvider = function (S) { return w(S) === a }, e.isElement = function (S) { return typeof S == "object" && S !== null && S.$$typeof === n }, e.isForwardRef = function (S) { return w(S) === f }, e.isFragment = function (S) { return w(S) === i }, e.isLazy = function (S) { return w(S) === g }, e.isMemo = function (S) { return w(S) === y }, e.isPortal = function (S) { return w(S) === r }, e.isProfiler = function (S) { return w(S) === s }, e.isStrictMode = function (S) { return w(S) === o }, e.isSuspense = function (S) { return w(S) === d }, e.isValidElementType = function (S) { return typeof S == "string" || typeof S == "function" || S === i || S === u || S === s || S === o || S === d || S === p || typeof S == "object" && S !== null && (S.$$typeof === g || S.$$typeof === y || S.$$typeof === a || S.$$typeof === l || S.$$typeof === f || S.$$typeof === h || S.$$typeof === m || S.$$typeof === v || S.$$typeof === b) }, e.typeOf = w } }), QL = gn({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(e, t) { "use strict"; t.exports = KL() } }), Qu = gn({ "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(e, t) { "use strict"; var n = QL(), r = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, i = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, o = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, s = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, a = {}; a[n.ForwardRef] = o, a[n.Memo] = s; function l(b) { return n.isMemo(b) ? s : a[b.$$typeof] || r } var c = Object.defineProperty, u = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, y = Object.prototype; function g(b, h, m) { if (typeof h != "string") { if (y) { var v = p(h); v && v !== y && g(b, v, m) } var w = u(h); f && (w = w.concat(f(h))); for (var C = l(b), S = l(h), R = 0; R < w.length; ++R) { var E = w[R]; if (!i[E] && !(m && m[E]) && !(S && S[E]) && !(C && C[E])) { var L = d(h, E); try { c(b, E, L) } catch { } } } } return b } t.exports = g } }), ZL = gn({
    "../../../node_modules/archy/index.js"(e, t) {
        t.exports = function n(r, i, o) {
            i === void 0 && (i = ""), o || (o = {}); var s = function (u) { var f = { "\u2502": "|", "\u2514": "`", "\u251C": "+", "\u2500": "-", "\u252C": "-" }; return o.unicode === !1 ? f[u] : u }; typeof r == "string" && (r = { label: r }); var a = r.nodes || [], l = (r.label || "").split(`
`), c = `
`+ i + (a.length ? s("\u2502") : " ") + " "; return i + l.join(c) + `
`+ a.map(function (u, f) { var d = f === a.length - 1, p = u.nodes && u.nodes.length, y = i + (d ? " " : s("\u2502")) + " "; return i + s(d ? "\u2514" : "\u251C") + s("\u2500") + s(p ? "\u252C" : "\u2500") + " " + n(u, y, o).slice(i.length + 2) }).join("")
        }
    }
}), JL = gn({ "../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(e, t) { (function () { function n(h, m) { document.addEventListener ? h.addEventListener("scroll", m, !1) : h.attachEvent("scroll", m) } function r(h) { document.body ? h() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function m() { document.removeEventListener("DOMContentLoaded", m), h() }) : document.attachEvent("onreadystatechange", function m() { (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", m), h()) }) } function i(h) { this.a = document.createElement("div"), this.a.setAttribute("aria-hidden", "true"), this.a.appendChild(document.createTextNode(h)), this.b = document.createElement("span"), this.c = document.createElement("span"), this.h = document.createElement("span"), this.f = document.createElement("span"), this.g = -1, this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.b.appendChild(this.h), this.c.appendChild(this.f), this.a.appendChild(this.b), this.a.appendChild(this.c) } function o(h, m) { h.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + m + ";" } function s(h) { var m = h.a.offsetWidth, v = m + 100; return h.f.style.width = v + "px", h.c.scrollLeft = v, h.b.scrollLeft = h.b.scrollWidth + 100, h.g !== m ? (h.g = m, !0) : !1 } function a(h, m) { function v() { var C = w; s(C) && C.a.parentNode && m(C.g) } var w = h; n(h.b, v), n(h.c, v), s(h) } function l(h, m) { var v = m || {}; this.family = h, this.style = v.style || "normal", this.weight = v.weight || "normal", this.stretch = v.stretch || "normal" } var c = null, u = null, f = null, d = null; function p() { if (u === null) if (y() && /Apple/.test(I.navigator.vendor)) { var h = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(I.navigator.userAgent); u = !!h && 603 > parseInt(h[1], 10) } else u = !1; return u } function y() { return d === null && (d = !!document.fonts), d } function g() { if (f === null) { var h = document.createElement("div"); try { h.style.font = "condensed 100px sans-serif" } catch { } f = h.style.font !== "" } return f } function b(h, m) { return [h.style, h.weight, g() ? h.stretch : "", "100px", m].join(" ") } l.prototype.load = function (h, m) { var v = this, w = h || "BESbswy", C = 0, S = m || 3e3, R = new Date().getTime(); return new Promise(function (E, L) { if (y() && !p()) { var F = new Promise(function (A, K) { function U() { new Date().getTime() - R >= S ? K(Error("" + S + "ms timeout exceeded")) : document.fonts.load(b(v, '"' + v.family + '"'), w).then(function (H) { 1 <= H.length ? A() : setTimeout(U, 25) }, K) } U() }), N = new Promise(function (A, K) { C = setTimeout(function () { K(Error("" + S + "ms timeout exceeded")) }, S) }); Promise.race([N, F]).then(function () { clearTimeout(C), E(v) }, L) } else r(function () { function A() { var ie; (ie = ee != -1 && te != -1 || ee != -1 && q != -1 || te != -1 && q != -1) && ((ie = ee != te && ee != q && te != q) || (c === null && (ie = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(I.navigator.userAgent), c = !!ie && (536 > parseInt(ie[1], 10) || parseInt(ie[1], 10) === 536 && 11 >= parseInt(ie[2], 10))), ie = c && (ee == ne && te == ne && q == ne || ee == be && te == be && q == be || ee == re && te == re && q == re)), ie = !ie), ie && (pe.parentNode && pe.parentNode.removeChild(pe), clearTimeout(C), E(v)) } function K() { if (new Date().getTime() - R >= S) pe.parentNode && pe.parentNode.removeChild(pe), L(Error("" + S + "ms timeout exceeded")); else { var ie = document.hidden; (ie === !0 || ie === void 0) && (ee = U.a.offsetWidth, te = H.a.offsetWidth, q = W.a.offsetWidth, A()), C = setTimeout(K, 50) } } var U = new i(w), H = new i(w), W = new i(w), ee = -1, te = -1, q = -1, ne = -1, be = -1, re = -1, pe = document.createElement("div"); pe.dir = "ltr", o(U, b(v, "sans-serif")), o(H, b(v, "serif")), o(W, b(v, "monospace")), pe.appendChild(U.a), pe.appendChild(H.a), pe.appendChild(W.a), document.body.appendChild(pe), ne = U.a.offsetWidth, be = H.a.offsetWidth, re = W.a.offsetWidth, K(), a(U, function (ie) { ee = ie, A() }), o(U, b(v, '"' + v.family + '",sans-serif')), a(H, function (ie) { te = ie, A() }), o(H, b(v, '"' + v.family + '",serif')), a(W, function (ie) { q = ie, A() }), o(W, b(v, '"' + v.family + '",monospace')) }) }) }, typeof t == "object" ? t.exports = l : (I.FontFaceObserver = l, I.FontFaceObserver.prototype.load = l.prototype.load) })() } }); function Fm(e, t) { let n = { style: t }; return x.isValidElement(e) ? x.cloneElement(e, n) : x.createElement(e, n) } var eM = class extends Error { }, Cu = class extends Error { }, tM = class extends Re { constructor(e) { super(e), this.state = { error: void 0, forceUpdateKey: e.forceUpdateKey } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { if (e.forceUpdateKey !== t.forceUpdateKey) { let n = { forceUpdateKey: e.forceUpdateKey }; return t.error && (n.error = void 0), n } return null } render() { if (this.state.error === void 0) return this.props.children; if (!(this.state.error instanceof eM)) { let n = new Cu; throw n.cause = this.state.error, n } let { notFoundPage: e, defaultPageStyle: t } = this.props; if (!e) throw this.state.error; return Fm(e, t) } }, nM = ":([a-z]\\w*)", eo = new RegExp(nM, "gi"); function gk(e, t) { return e.replace(eo, (n, r) => { let i = t[r]; return typeof i != "string" || i.length === 0 ? n : encodeURIComponent(i) }) } function vk(e, t) { if (!e.startsWith("/") || !t.startsWith("/")) throw new Error("from/to paths are expected to be absolute"); let [n] = O1(e), [r, i] = O1(t), o = rM(n, r); return o === "" && (o = "."), !o.startsWith(".") && !o.startsWith("/") && (o = "./" + o), o + "/" + i } function O1(e) { let t = e.lastIndexOf("/"); return [e.substring(0, t + 1), e.substring(t + 1)] } var sm = 46, es = 47, wi = (e, t) => e.charCodeAt(t), D1 = (e, t) => e.lastIndexOf(t), ns = (e, t, n) => e.slice(t, n); function rM(e, t) { if (e === t || (e = "/" + V1(e), t = "/" + V1(t), e === t)) return ""; let n = 1, r = e.length, i = r - n, o = 1, s = t.length - o, a = i < s ? i : s, l = -1, c = 0; for (; c < a; c++) { let f = wi(e, n + c); if (f !== wi(t, o + c)) break; f === es && (l = c) } if (c === a) if (s > a) { if (wi(t, o + c) === es) return ns(t, o + c + 1); if (c === 0) return ns(t, o + c) } else i > a && (wi(e, n + c) === es ? l = c : c === 0 && (l = 0)); let u = ""; for (c = n + l + 1; c <= r; ++c)(c === r || wi(e, c) === es) && (u += u.length === 0 ? ".." : "/.."); return `${u}${ns(t, o + l)}` } var iM = !1, pu = "/", A1 = e => e === es; function V1(e) { let t = "", n = 0, r = -1, i = 0, o = 0; for (let s = 0; s <= e.length; ++s) { if (s < e.length) o = wi(e, s); else { if (A1(o)) break; o = es } if (A1(o)) { if (!(r === s - 1 || i === 1)) if (i === 2) { if (t.length < 2 || n !== 2 || wi(t, t.length - 1) !== sm || wi(t, t.length - 2) !== sm) { if (t.length > 2) { let a = D1(t, pu); a === -1 ? (t = "", n = 0) : (t = ns(t, 0, a), n = t.length - 1 - D1(t, pu)), r = s, i = 0; continue } else if (t.length !== 0) { t = "", n = 0, r = s, i = 0; continue } } iM && (t += t.length > 0 ? `${pu}..` : "..", n = 2) } else t.length > 0 ? t += `${pu}${ns(e, r + 1, s)}` : t = ns(e, r + 1, s), n = s - r - 1; r = s, i = 0 } else o === sm && i !== -1 ? ++i : i = -1 } return t } function yk(e) { let t = typeof I < "u" ? I.location.search : ""; return t ? oM(t, e) : e } function oM(e, t) { let n = t.indexOf("#"), r = n === -1 ? t : t.substring(0, n), i = n === -1 ? "" : t.substring(n), o = r.indexOf("?"); if (o === -1) return r + e + i; let s = new URLSearchParams(e), a = r.substring(o + 1), l = new URLSearchParams(a); for (let [c, u] of s) l.has(c) || l.append(c, u); return r.substring(0, o + 1) + l.toString() + i } function Va(e) { return typeof e == "object" && e !== null && !Array.isArray(e) } function Zi(e) { return typeof e == "string" } var sM = "preload"; function bk(e) { return typeof e == "object" && e !== null && !x.isValidElement(e) && sM in e } function iH(e) { let t = x.lazy(e), n, r, i = x.forwardRef(function (s, a) { return x.createElement(r ?? t, a ? { ref: a, ...s } : s) }); return i.preload = () => (n || (n = e().then(o => (r = o.default, r))), n), i } function Zu(e, t) { if (t && e) return e.elements && t in e.elements ? e.elements[t] : t } function aM(e) { return /bot|-google|google-|yandex|ia_archiver/iu.test(e) } function xk(e) { if ("scheduler" in I) { if ("yield" in scheduler) return scheduler.yield(e); if ("postTask" in scheduler) return scheduler.postTask(() => { }, e) } return e?.priority === "user-blocking" ? Promise.resolve() : new Promise(t => { setTimeout(t) }) } async function lM(e, t) { return await xk(t), e() } function Ba(e, t = !0) { return new Promise(n => { t && setTimeout(n, 100), requestAnimationFrame(() => { lM(n, e) }) }) } function eg(e, t, n, r = !1) { tt(() => { (async () => { await Ba(n, r), e() })() }, t) } var Au = () => { }; async function cM(e, t, n, r, i, o, s) { var a, l, c; let u = e, f = !1, d = { ...o }, p = Array.from(u.matchAll(eo)), y = await Promise.all(p.map(async m => { var v; let w = m?.[0], C = m?.[1]; if (!w || !C) throw new Error("Failed to replace path variables: unexpected regex match group"); let S = o[C]; if (!S || !Zi(S)) throw new Error(`No slug found for path variable ${C}`); let R = await ((v = s?.[i]) === null || v === void 0 ? void 0 : v.call(s)); if (!R || !t) return S; let E = await R.getRecordIdBySlug(S, t); if (!E) return S; let L = await R.getSlugByRecordId(E, n); if (!L) { f = !0; let F = await R.getSlugByRecordId(E, r); return F && (d[C] = F), F ?? S } return d[C] = L, L })), g = 0, b = "", h = !1; for (let m = 0; m < p.length; m++) { let v = p[m], w = y[m]; !v || !w || (b += u.substring(g, v.index), g = ((a = v.index) !== null && a !== void 0 ? a : 0) + ((c = (l = v[0]) === null || l === void 0 ? void 0 : l.length) !== null && c !== void 0 ? c : 0), b += y[m], h = !0) } return h && (u = b), { path: u, pathVariables: d, isMissingInLocale: f } } async function uM({ currentLocale: e, nextLocale: t, defaultLocale: n, route: r, pathVariables: i, collectionUtils: o, preserveQueryParams: s }) { let { path: a } = r, l = { path: a, pathVariables: i, isMissingInLocale: !1 }; if (!a) return l; if (i && r.collectionId) try { l = await cM(a, e, t, n, r.collectionId, i, o) } catch { } return t.slug && (l.path = "/" + t.slug + l.path), s && l.path && (l.path = yk(l.path)), l } function fM(e, t, { global: n, routes: r }) { var i; return ((i = r[e]) === null || i === void 0 ? void 0 : i[t]) || n } var dM = { global: void 0, routes: {} }, wk = x.createContext(dM); function lH({ children: e, value: t }) { return k(wk.Provider, { value: t, children: e }) } function hM() { return x.useContext(wk) } var am = 10, pM = 1e4; function mM(e) { let t = am, n = e.next(0), r = [n.value]; for (; !n.done && t < pM;)n = e.next(t), r.push(n.value), t += am; return r.length === 1 && r.push(n.value), { easing: `linear(${r.join(",")})`, duration: t - am } } var Br = e => `--view-transition-${e}`; function Im(e) { return [parseFloat(e), e.endsWith("px") ? "px" : "%"] } function Sk(e) { let { innerWidth: t, innerHeight: n } = I, [r, i] = Im(e.x), [o, s] = Im(e.y); return { x: i === "px" ? r : t * (r / 100), y: s === "px" ? o : n * (o / 100) } } var gM = {
    makeKeyframe: (e, t, n) => { let r = 0; return (n === "exit" && e.angularDirection === "clockwise" && t === "start" || n === "exit" && e.angularDirection === "counter-clockwise" && t === "end" || n === "enter" && e.angularDirection === "counter-clockwise" && t === "start" || n === "enter" && e.angularDirection === "clockwise" && t === "end") && (r = e.sweepAngle / 360 * 100), `${Br("conic-offset")}: ${r}%;` }, makeStyles: (e, t) => { let n = `var(${Br("conic-offset")})`, r = t === "exit" && e.angularDirection === "clockwise" || t === "enter" && e.angularDirection === "counter-clockwise", i = r ? "transparent" : "black", o = r ? "black" : "transparent", s = "conic-gradient(from "; return s += `${e.angle}deg at ${e.x} ${e.y}, `, s += `${i} 0%, ${i} ${n}, `, s += `${o} ${n}, ${o} 100%)`, `mask-image: ${s}; -webkit-mask-image: ${s};` }, makePropertyRules: () => `
        @property ${Br("conic-offset")} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `}, vM = { makeKeyframe: (e, t) => { let { x: n, y: r } = Sk(e); return t === "start" ? `clip-path: circle(0 at ${n}px ${r}px);` : `clip-path: circle(${Math.hypot(Math.max(n, I.innerWidth - n), Math.max(r, I.innerHeight - r))}px at ${n}px ${r}px);` } }, yM = { makeKeyframe: (e, t) => { let { x: n, y: r } = Sk(e), i = I.innerHeight - r, o = I.innerWidth - n; return t === "start" ? `clip-path: inset(${r}px ${o}px ${i}px ${n}px round ${e.round}px);` : "clip-path: inset(0 round 0);" } }, bM = {
        makeKeyframe: (e, t, n) => { let [, r] = Im(e.width), i = `0${r}`; return (t === "start" && n === "exit" || t === "end" && n === "enter") && (i = e.width), `${Br("blinds-width")}: ${i};` }, makeStyles: (e, t) => { let n = `var(${Br("blinds-width")})`, r = t === "exit" ? "transparent" : "black", i = t === "exit" ? "black" : "transparent", o = "repeating-linear-gradient("; return o += e.angle + 90 + "deg, ", o += `${r} 0px, ${r} ${n}, `, o += `${i} ${n}, ${i} ${e.width})`, `mask-image: ${o}; -webkit-mask-image: ${o};` }, makePropertyRules: () => `
            @property ${Br("blinds-width")} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `}, xM = {
        makeKeyframe: (e, t, n) => { let r = t === "start" && n === "exit" || t === "end" && n === "enter" ? 1 : 0; return `${Br("wipe-offset")}: ${r};` }, makeStyles: (e, t) => { let n = `var(${Br("wipe-offset")})`, r = t === "exit" ? "transparent" : "black", i = t === "exit" ? "black" : "transparent", o = "linear-gradient("; return o += e.angle + 90 + "deg, ", o += `${r} calc(calc(0% - ${e.width}) + calc(calc(100% + ${e.width}) * ${n})), `, o += `${i} calc(calc(100% + ${e.width}) * ${n}))`, `mask-image: ${o}; -webkit-mask-image: ${o};` }, makePropertyRules: () => `
            @property ${Br("wipe-offset")} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `}, wM = { circle: vM, conic: gM, inset: yM, blinds: bM, wipe: xM }, SM = { opacity: 1, x: "0px", y: "0px", scale: 1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0 }; function B1(e, t, n, r) {
    var i; let o = `
      opacity: ${e.opacity};
      transform: translate(${e.x}, ${e.y}) scale(${e.scale}) rotateX(${e.rotateX}deg) rotateY(${e.rotateY}deg) rotateZ(${e.rotate}deg);
    `; return e.mask && (o += ((i = r?.makeKeyframe) === null || i === void 0 ? void 0 : i.call(r, e.mask, t, n)) || ""), o
} function kM(e) { return e ? wM[e] : void 0 } function z1(e, { transition: t, ...n }) {
    var r; let i = "view-transition-" + e, o = { duration: "0s", easing: "linear" }; if (t.type === "tween") o.duration = t.duration + "s", o.easing = `cubic-bezier(${t.ease.join(",")})`; else if (t.type === "spring") { let { easing: c, duration: u } = mM(As({ keyframes: [0, 1], stiffness: t.stiffness, damping: t.damping, mass: t.mass, restDelta: .001, restSpeed: 1e-4 })); o.duration = u + "ms", o.easing = c } let s = kM((r = n?.mask) === null || r === void 0 ? void 0 : r.type), a = B1(n, "start", e, s), l = B1({ ...SM, mask: n.mask }, "end", e, s); return e === "exit" && ([a, l] = [l, a]), `
        ${n.mask && s?.makePropertyRules ? s.makePropertyRules(n.mask) : ""}

        @keyframes ${i} {
            0% {
                ${a}
            }

            100% {
                ${l}
            }
        }

        ::view-transition-${e === "enter" ? "new" : "old"}(root) {
            animation-name: ${i};
            animation-duration: ${o.duration};
            animation-delay: ${t.delay}s;
            animation-timing-function: ${o.easing};
            animation-fill-mode: both;
            ${n.mask && s?.makeStyles ? s.makeStyles(n.mask, e) : ""}
        }
    `} var kk = "view-transition-styles", CM = { x: "0px", y: "0px", scale: 1, opacity: 1, rotate3d: !1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0, transition: { type: "tween", delay: 0, duration: .2, ease: [.27, 0, .51, 1], stiffness: 400, damping: 30, mass: 1 } }; function TM({ exit: e = CM, enter: t }) {
    let n = document.createElement("style"); n.id = kk; let r = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `; (e.mask || t.mask || e.opacity || t.opacity || e.transition.delay || t.transition.delay) && (r += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `), r += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `, r += z1("exit", e), r += z1("enter", t), n.textContent = r, document.head.appendChild(n)
} function EM() { requestIdleCallback(() => { Y.render(() => { performance.mark("framer-vt-remove"); let e = document.getElementById(kk); e && document.head.removeChild(e) }) }) } var $1 = () => { }; function RM() { return !!document.startViewTransition } function PM(e) { return new Promise(t => { Y.render(() => { performance.mark("framer-vt-style"), TM(e), t() }) }) } async function N1(e, t, n) { if (!RM()) { e(); return } if (await PM(t), n?.aborted) return; performance.mark("framer-vt"); let r = document.startViewTransition(async () => { performance.mark("framer-vt-freeze"), !n?.aborted && (n?.addEventListener("abort", () => r.skipTransition()), await e()) }); return r.updateCallbackDone.then(() => { performance.mark("framer-vt-unfreeze") }).catch($1), Promise.all([r.ready, r.finished]).then(() => { performance.mark("framer-vt-finished"), EM() }).catch($1), r } function Ck() { let e = hM(), t = D(void 0); return z(() => { t.current && (t.current(), t.current = void 0) }), se((n, r, i, o, s) => { let a = fM(n, r, e); if (a) { let l = new Promise(f => { t.current = f }), c = async () => { i(), await l }, u = async () => (await Ba({ priority: "user-blocking", signal: s }, !1).catch(Au), N1(c, a, s)); return o ? u() : N1(c, a) } else return i() }, [e]) } function Tk(e, t = !1) { let n = `${e}-start`, r = `${e}-end`, i = D(void 0); return eg(() => { i.current && (i.current(), i.current = void 0) }, void 0, { priority: "user-blocking" }, t), se(() => { let o = new Promise(s => { i.current = s }); return performance.mark(n), o.finally(() => { performance.mark(r), performance.measure(e, n, r) }).catch(s => { console.error(s) }) }, [e, n, r]) } async function H1(e, t, { currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, localeId: s, preserveQueryParams: a }, l = !1, c = !1) { let { path: u } = t; if (u) try { let f = Ju(t, { currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, preserveQueryParams: a }), d = Ek({ routeId: e, hash: i, pathVariables: o, localeId: s }, f, l, c); l || await d } catch { } } function _M(e) { let t = "routeId"; return Va(e) && Zi(e[t]) } function FM(e, t, n = !1) { performance.mark("framer-history-replace"), (n ? I.history.__proto__.replaceState : I.history.replaceState).call(I.history, e, "", t) } async function Ek(e, t, n = !1, r = !1) { if (n && await Ba({ priority: "user-blocking" }), performance.mark("framer-history-push"), !r) { I.history.pushState(e, "", t); return } let i = !1, o = () => { i = !0 }; I.addEventListener("popstate", o, { once: !0 }), I.history.__proto__.pushState.call(I.history, e, "", t), queueMicrotask(() => { i || (I.removeEventListener("popstate", o), I.history.replaceState(e, "")) }) } function IM({ disabled: e, routeId: t, initialPathVariables: n, initialLocaleId: r }) { tt(() => { e || (performance.mark("framer-history-set-initial-state"), FM({ routeId: t, pathVariables: n, localeId: r }, void 0, !0)) }, []) } function LM(e, t) { let n = Ck(), r = Tk("framer-route-change-popstate"), i = D(void 0), o = se(async ({ state: a }) => { var l, c, u, f, d, p; if (!((l = I.navigation) === null || l === void 0) && l.transition && ((u = (c = I.navigation) === null || c === void 0 ? void 0 : c.transition) === null || u === void 0 ? void 0 : u.navigationType) !== "traverse" || !Va(a)) return; let { routeId: y, hash: g, pathVariables: b, localeId: h } = a; if (!Zi(y)) return; r(); let m = () => { t(y, Zi(h) ? h : void 0, Zi(g) ? g : void 0, Va(b) ? b : void 0, !1, !0) }, v = await n(e.current, y, m, !1); v ? v.updateCallbackDone.then((f = i.current) === null || f === void 0 ? void 0 : f.resolve).catch((d = i.current) === null || d === void 0 ? void 0 : d.reject) : (p = i.current) === null || p === void 0 || p.resolve() }, [e, r, t, n]), s = se(a => { a.navigationType === "traverse" && a.intercept({ async handler() { await new Promise((l, c) => { i.current = { resolve: l, reject: c } }) }, scroll: "after-transition" }) }, []); z(() => { var a; return I.addEventListener("popstate", o), (a = I.navigation) === null || a === void 0 || a.addEventListener("navigate", s), () => { var l; I.removeEventListener("popstate", o), (l = I.navigation) === null || l === void 0 || l.removeEventListener("navigate", s) } }, [o, s]) } function MM(e, t, n) { let r = Zu(t, e); if (!r) return; let i = Object.assign({}, t?.elements, n); return r.replace(eo, (o, s) => { var a; return String((a = i[s]) !== null && a !== void 0 ? a : o) }) } function Ju(e, { currentRoutePath: t, currentPathVariables: n, hash: r, pathVariables: i, hashVariables: o, relative: s = !0, preserveQueryParams: a }) { var l; let c = t ?? "/"; n && (c = c.replace(eo, (y, g) => String(n[g] || y))); let f = (l = e?.path) !== null && l !== void 0 ? l : "/"; i && (f = f.replace(eo, (y, g) => String(i[g] || y))); let d = MM(r, e, o), p = c === f && d; return s && (f = vk(c, f)), (a || p) && (f = yk(f)), d && (f = `${f}#${d}`), f } async function OM(e, t, n) { if (!e.path || !t) return !1; let i = `${n.slug ? `/${n.slug}` : ""}${gk(e.path, t)}`; return (await fetch(i, { method: "HEAD", redirect: "manual" })).type === "opaqueredirect" ? (I.location.href = I.location.origin + i, !0) : !1 } async function DM(e) { let t = await uM(e); if (t) { try { localStorage.setItem("preferredLocale", e.nextLocale.code) } catch { } try { if (!Zi(t.path)) throw new Error("Expected result.path to be a string"); if (t.isMissingInLocale && await OM(e.route, t.pathVariables, e.nextLocale)) return } catch { } return t } } function AM() { let e = D(Promise.resolve()), t = D(), n = se(r => { if (r.navigationType === "traverse") return; let i = t.current; i?.signal.addEventListener("abort", () => { i.abort("user aborted") }), r.intercept({ handler: () => e.current }) }, []); return se((r, i, o) => { if (!I.navigation) { i(); return } e.current = r, t.current = o, I.navigation.addEventListener("navigate", n), i(!0), r.catch(Au).finally(() => { I.navigation.removeEventListener("navigate", n) }) }, [n]) } function Dr(e, t, n) { try { performance.measure(e, t, n) } catch (r) { console.warn(`Could not measure ${e}`, r) } } var $n = !1; function fH() { $n = !0, performance.mark("framer-hydration-start") } var j1 = !1, W1 = !1, U1 = !1; function VM() { let e = "framer-hydration-router"; st(() => { j1 || !$n || (j1 = !0, performance.mark(`${e}-insertion-effect`)) }, []), tt(() => { W1 || !$n || (W1 = !0, performance.mark(`${e}-layout-effect`)) }, []), z(() => { U1 || !$n || (U1 = !0, performance.mark(`${e}-effect`)) }, []) } var G1 = !1, q1 = !1, X1 = !1; function BM() { let e = "framer-hydration-", t = `${e}layout-effects-end`, n = `${e}effects-end`, r = `${e}browser-render-start`, i = `${e}render-end`; return st(() => { G1 || !$n || (G1 = !0, performance.mark(i), Dr(`${e}render`, `${e}start`, i), performance.mark(`${e}insertion-effects-start`)) }, []), tt(() => { q1 || !$n || (q1 = !0, performance.mark(`${e}layout-effects-start`), requestAnimationFrame(() => { var o, s, a; performance.mark(r), Dr(`${e}uho`, (s = (o = performance.getEntriesByName(n)[0]) === null || o === void 0 ? void 0 : o.name) !== null && s !== void 0 ? s : (a = performance.getEntriesByName(t)[0]) === null || a === void 0 ? void 0 : a.name, r) })) }, []), z(() => { var o; if (X1 || !$n) return; X1 = !0; let s = `${e}effects-start`; performance.mark(s), ((o = performance.getEntriesByName(r)[0]) === null || o === void 0 ? void 0 : o.name) || (Dr(`${e}commit`, t, s), performance.mark(`${e}effects-sync`)) }, []), null } var Y1 = !1, K1 = !1, Q1 = !1, Z1 = !1; function zM() { let e = "framer-hydration-", t = `${e}layout-effects-end`, n = `${e}effects-end`, r = `${e}browser-render-start`, i = `${e}start`, o = `${e}insertion-effects-end`, s = `${e}first-paint`, a = `${e}browser-raf-end`; return st(() => { Y1 || !$n || (Y1 = !0, performance.mark(o), Dr(`${e}insertion-effects`, `${e}insertion-effects-start`, o)) }, []), tt(() => { K1 || !$n || (K1 = !0, performance.mark(t), Dr(`${e}layout-effects`, `${e}layout-effects-start`, t), requestAnimationFrame(() => { performance.mark(a), Dr(`${e}raf`, r, a) })) }, []), z(() => { var l, c, u; Q1 || !$n || (Q1 = !0, performance.mark(n), Dr(`${e}effects`, (c = (l = performance.getEntriesByName(s)[0]) === null || l === void 0 ? void 0 : l.name) !== null && c !== void 0 ? c : (u = performance.getEntriesByName(`${e}effects-start`)[0]) === null || u === void 0 ? void 0 : u.name, n)) }, []), eg(() => { Z1 || !$n || (Z1 = !0, performance.mark(s), Dr(`${e}time-to-first-paint`, i, s), Dr(`${e}browser-render`, a, s)) }, [], { priority: "user-blocking" }), null } function $M() { return BM(), null } function NM() { return zM(), null } var J1 = { Start: $M, End: NM }, Da = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset"], Rk = e => { var t, n; !((n = (t = e.target) === null || t === void 0 ? void 0 : t.closest) === null || n === void 0) && n.call(t, "#main") && (e.stopPropagation(), performance.mark("framer-react-event-handling-prevented")) }, Pk = !1; function dH() { if (!Da) return; Pk = !0, performance.mark("framer-react-event-handling-start"); let e = { capture: !0 }; Da.forEach(t => document.body.addEventListener(t, Rk, e)) } function HM() { return eg(() => { if (!Pk || !Da) return; let e = { capture: !0 }; Da.forEach(t => document.body.removeEventListener(t, Rk, e)), Da = void 0, performance.mark("framer-react-event-handling-end") }, [], { priority: "user-blocking" }), null } var tg = !1; function pH() { tg = !0 } function jM() { tg = !1 } function WM() { let e = D(typeof I > "u" || tg); return z(() => { e.current = !1 }, []), e } function UM(e, t) { if (e.routeId !== t.routeId) return !1; if (e.pathVariables === t.pathVariables) return !0; let n = e.pathVariables || {}, r = t.pathVariables || {}; return n.length === r.length && Object.keys(n).every(i => n[i] === r[i]) } function _k(e) { return x.useCallback(t => e[t], [e]) } var ng = (() => x.createContext({}))(); function GM({ api: e, children: t }) { return k(ng.Provider, { value: e, children: t }) } function cs() { return x.useContext(ng) } function qM({ routes: e, children: t }) { let n = _k(e); return k(ng.Provider, { value: { getRoute: n }, children: t }) } var XM = class extends Re { constructor() { super(...arguments), this.state = { error: void 0 } } static getDerivedStateFromError(e) { return e instanceof Cu || console.error("Derived error in SuspenseErrorBoundary", e), { error: e } } componentDidCatch(e, t) { var n; if (e instanceof Cu) return; let r = t?.componentStack; if (console.error("Caught error in SuspenseErrorBoundary", e, r), typeof I < "u") { let i = e instanceof Error && typeof e.stack == "string" ? e.stack : null; (n = I.__framer_events) === null || n === void 0 || n.push(["published_site_load_recoverable_error", { message: String(e), stack: i, componentStack: i ? void 0 : r }]) } } render() { if (this.state.error === void 0) return this.props.children; if (this.state.error instanceof Cu) throw this.state.error.cause; return k(ms, { children: this.props.fallbackChildren }) } }, YM = (() => typeof I < "u" ? new Promise(() => { }) : null)(); function KM() { if (typeof I > "u") return null; throw YM } function Fk({ children: e }) { return k(XM, { fallbackChildren: e, children: k(ms, { fallback: k(KM, {}), children: e }) }) } var eS = "default"; function QM() { let [e, t] = x.useState(0); return [e, x.useCallback(() => t(n => n + 1), [])] } var ZM = async () => { }, JM = { activeLocale: null, locales: [], setLocale: ZM }, Ik = x.createContext(JM); function rg() { return x.useContext(Ik) } function tS(e, t, n) { let r = e && document.getElementById(e); if (r) { rO(r, t); return } n || I.scrollTo(0, 0) } function eO(e) { let t = D([]); return tt(() => { var n; !((n = t.current) === null || n === void 0) && n.length && (t.current.forEach(r => r()), t.current = []) }, [e]), se(n => { t.current.push(n) }, []) } function tO(e) { let t = AM(), n = Tk("framer-route-change", !0), r = D(void 0); return se(async (i, o, s = !0) => { var a; if (jM(), !e) return await o?.(), i(), n(), new Promise(p => { p() }); (a = r.current) === null || a === void 0 || a.abort(); let l = s ? new AbortController : void 0; r.current = l; let c = l?.signal, u = n(); if (!o) return r.current = void 0, i(c), u; i(c), await Ba({ priority: "user-visible", signal: c }).catch(Au), await Ba({ priority: "user-visible", signal: c }).catch(Au); let f, d = new Promise((p, y) => { f = p, c?.aborted ? y() : c?.addEventListener("abort", y) }); return t(d, o, l), u.then(() => { f() }) }, [e, n, t]) } function nO({ defaultPageStyle: e, disableHistory: t, initialPathVariables: n, initialRoute: r, notFoundPage: i, collectionUtils: o, routes: s, initialLocaleId: a, locales: l = [], preserveQueryParams: c = !1, enableAsyncURLUpdates: u = !1 }) { VM(), IM({ disabled: t, routeId: r, initialPathVariables: n, initialLocaleId: a }); let f = Ck(), [d, p] = QM(), y = eO(d), g = tO(u), b = D(r), h = D(n), m = D(a), v = m.current, w = ae(() => { var W; return (W = l.find(({ id: ee }) => v ? ee === v : ee === eS)) !== null && W !== void 0 ? W : null }, [v, l]), C = ae(() => ({ activeLocale: w, locales: l, setLocale: async W => { let ee; Zi(W) ? ee = W : Va(W) && (ee = W.id); let te = l.find(({ id: re }) => re === eS), q = l.find(({ id: re }) => re === ee); if (!q) return; let ne = b.current, be = s[ne]; if (be) try { let re = await DM({ currentLocale: w, nextLocale: q, route: be, routeId: ne, defaultLocale: te, pathVariables: h.current, collectionUtils: o, preserveQueryParams: c }); if (!re) return; let pe = h.current, ie = _M(I.history.state) ? I.history.state.paginationInfo : void 0, ht = re.path; h.current = re.pathVariables, m.current = q.id, g(() => { f(ne, ne, () => yr(p), u) }, async (Lt = !1) => { if (ht) return Ek({ routeId: ne, pathVariables: pe, localeId: q.id, paginationInfo: ie }, ht, !1, Lt) }, !1) } catch { } } }), [w, o, u, p, l, c, s, g, f]), S = se((W, ee, te, q, ne = !1, be = !1, re) => { let pe = b.current; if (b.current = W, h.current = q, m.current = ee, y(() => { tS(te, ne, be) }), be) { yr(p); return } g(ie => { f(pe, W, () => yr(p), u, ie) }, re) }, [u, p, y, g, f]); LM(b, S); let R = se(async (W, ee, te, q) => { var ne, be; let re = s[W]; if (te) { let Se = new Set, Zt = (ne = re?.path) !== null && ne !== void 0 ? ne : "/"; for (let Pn of Zt.matchAll(eo)) { let _n = Pn[1]; if (_n === void 0) throw new Error("A matching path variable should not be undefined"); Se.add(_n) } te = Object.fromEntries(Object.entries(te).filter(([Pn]) => Se.has(Pn))) } let pe = Zu(re, ee), ie = h.current, ht = m.current; if (UM({ routeId: b.current, pathVariables: ie }, { routeId: W, pathVariables: te })) { tS(pe, q, !1); let Se = s[W]; if (((be = I.history.state) === null || be === void 0 ? void 0 : be.hash) === ee || t || !Se) return; let Zt = H1(W, Se, { currentRoutePath: Se.path, currentPathVariables: ie, pathVariables: te, hash: ee, localeId: ht, preserveQueryParams: c }, u); return u ? void 0 : await Zt } if (!re) return; let Fe = s[b.current]; S(W, ht, pe, te, q, !1, t ? void 0 : async (Se = !1) => H1(W, re, { currentRoutePath: Fe?.path, currentPathVariables: ie, hash: ee, pathVariables: te, localeId: ht, preserveQueryParams: c }, !1, Se)) }, [s, S, t, c, u]), E = _k(s), L = b.current, F = h.current, N = ae(() => ({ navigate: R, getRoute: E, currentRouteId: L, currentPathVariables: F, routes: s, collectionUtils: o, preserveQueryParams: c }), [R, E, L, F, s, o, c]), A = s[b.current]; if (!A) throw new Error(`Router cannot find route for ${b.current}`); let K = !w || !A.includedLocales || A.includedLocales.includes(w.id), U = A.path && F ? gk(A.path, F) : A.path, H = String(v) + U; return k(GM, { api: N, children: k(Ik.Provider, { value: C, children: ue(Fk, { children: [k(tM, { notFoundPage: i, defaultPageStyle: e, forceUpdateKey: d, children: ue(gr, { children: [k(J1.Start, {}), K ? Fm(A.page, e) : i && Fm(i, e)] }, H) }), k(HM, {}), k(J1.End, {})] }) }) }) } function rO(e, t) { let n = t ? { behavior: "smooth", block: "start", inline: "nearest" } : void 0; e.scrollIntoView(n) } var mu, lm, nS; function iO(e) { if (nS !== e) { mu = {}; for (let [t, { path: n }] of Object.entries(e)) n && (mu[n] = { path: n, depth: oO(n), routeId: t }); lm = Object.values(mu), lm.sort(({ depth: t }, { depth: n }) => n - t), nS = e } return [mu, lm] } function Lk(e, t, n = !0, r = []) { let [i, o] = iO(e), s, a, l = t; if (r.length > 0) { let d = l.split("/").find(Boolean); if (d && (s = r.find(({ slug: p }) => p === d), s && (a = s.id, l = l.substring(s.slug.length + 1))), !a) { let p = r.find(({ slug: y }) => y === ""); p && (a = p.id) } } let c = i[l]; if (c) { let d = rS(l, c.path); if (d.isMatch) return { routeId: c.routeId, localeId: a, pathVariables: d.pathVariables } } for (let { path: d, routeId: p } of o) { let y = rS(l, d); if (y.isMatch) return { routeId: p, localeId: a, pathVariables: y.pathVariables } } if (!n) throw new Error("No exact match found for path"); let u = i["/"]; if (u) return { routeId: u.routeId, localeId: a }; let f = Object.keys(e)[0]; if (!f) throw new Error("Router should not have undefined routes"); return { routeId: f, localeId: a } } function oO(e) { let t = e.replace(/^\/|\/$/gu, ""); return t === "" ? 0 : t.split("/").length } function rS(e, t) { let n = [], i = sO(t).replace(eo, (c, u) => (n.push(u), "([^/]+)")), o = new RegExp(i + "$"), s = e.match(o); if (!s) return { isMatch: !1 }; if (s.length === 1) return { isMatch: !0 }; let a = {}, l = s.slice(1); for (let c = 0; c < n.length; ++c) { let u = n[c]; if (u === void 0) continue; let f = l[c], d = a[u]; if (d) { if (d !== f) return { isMatch: !1 }; continue } if (f === void 0) throw new Error("Path variable values cannot be undefined"); a[u] = f } return { isMatch: !0, pathVariables: a } } function sO(e) { return e.replace(/[|\\{}()[\]^$+*?.]/gu, "\\$&").replace(/-/gu, "\\x2d") } var aO = "page"; function iS(e) { return Va(e) && aO in e && e.page !== void 0 } var lO = (() => x.createContext(void 0))(); function Qa() { var e; let t = cs(), n = V(lO), r = n ?? t.currentRouteId; if (!r) return; let i = (e = t.getRoute) === null || e === void 0 ? void 0 : e.call(t, r); if (i) return { ...i, id: r, pathVariables: n ? void 0 : t.currentPathVariables } } function RH() { var e; return (e = Qa()) === null || e === void 0 ? void 0 : e.pathVariables } function cO(e) { var t; let n = cs(); if (e) return (t = n.getRoute) === null || t === void 0 ? void 0 : t.call(n, e) } var ig = (() => typeof I < "u" && !aM(Ne.userAgent))(); function uO(e, t = !0) { let { getRoute: n } = cs(); z(() => { if (!(!n || !t || !ig)) for (let r of e) Mk(n(r)) }, [e, n, t]) } async function Mk(e) { if (!ig || !e) return; let t = e.page; if (!(!t || !bk(t))) { await xk(); try { await t.preload() } catch { } } } function IH(e, t) { var n; let r = Qa(), i = (n = cO(t)) !== null && n !== void 0 ? n : r; return x.useMemo(() => i ? Zu(i, e) : e, [e, i]) } var oS = new Set; function za(e, ...t) { oS.has(e) || (oS.add(e), console.warn(e, ...t)) } function fO(e, t, n) { let r = n ? `, use ${n} instead` : "", i = `Deprecation warning: ${e} will be removed in version ${t}${r}.`; za(i) } var Ok = class { constructor() { T(this, "observers", new Set), T(this, "transactions", {}) } add(e) { this.observers.add(e); let t = !1; return () => { t || (t = !0, this.remove(e)) } } remove(e) { this.observers.delete(e) } notify(e, t) { if (t) { let n = this.transactions[t] || e; n.value = e.value, this.transactions[t] = n } else this.callObservers(e) } finishTransaction(e) { let t = this.transactions[e]; return delete this.transactions[e], this.callObservers(t, e) } callObservers(e, t) { let n = []; return new Set(this.observers).forEach(r => { typeof r == "function" ? r(e, t) : (r.update(e, t), n.push(r.finish)) }), n } }, it = (() => { function e(t) { return fO("Animatable()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)"), Nn(t) ? t : new hO(t) } return e.transaction = t => { let n = Math.random(), r = new Set; t((s, a) => { s.set(a, n), r.add(s) }, n); let o = []; r.forEach(s => { o.push(...s.finishTransaction(n)) }), o.forEach(s => { s(n) }) }, e.getNumber = (t, n = 0) => e.get(t, n), e.get = (t, n) => t == null ? n : Nn(t) ? t.get() : t, e.objectToValues = t => { if (!t) return t; let n = {}; for (let r in t) { let i = t[r]; Nn(i) ? n[r] = i.get() : n[r] = i } return n }, e })(), sS = "onUpdate", aS = "finishTransaction"; function Nn(e) { return e !== null && typeof e == "object" && sS in e && e[sS] instanceof Function && aS in e && e[aS] instanceof Function } function dO(e, t) { return { interpolate(n, r) { let i = n.get(), o = r.get(), s = it(i); return a => { let l = t.interpolate(i, o)(a); return s.set(l), s } }, difference(n, r) { let i = n.get(); return t.difference(i, r.get()) } } } var hO = class { constructor(e) { this.value = e, T(this, "observers", new Ok) } static interpolationFor(e, t) { if (Nn(e)) return dO(e, t) } get() { return this.value } set(e, t) { let n = this.value; Nn(e) && (e = e.get()), this.value = e; let r = { value: e, oldValue: n }; this.observers.notify(r, t) } finishTransaction(e) { return this.observers.finishTransaction(e) } onUpdate(e) { return this.observers.add(e) } }; function gu(e, t) { let r = 10 ** Math.round(Math.abs(t)); return Math.round(e * r) / r } function lS(e, t) { return t === 0 ? Math.round(e) : (t -= t | 0, t < 0 && (t = 1 - t), Math.round(e - t) + t) } function dn(e, t) { return { x: e, y: t } } (e => { e.add = (...i) => i.reduce((o, s) => ({ x: o.x + s.x, y: o.y + s.y }), { x: 0, y: 0 }), e.subtract = (i, o) => ({ x: i.x - o.x, y: i.y - o.y }), e.multiply = (i, o) => ({ x: i.x * o, y: i.y * o }), e.divide = (i, o) => ({ x: i.x / o, y: i.y / o }), e.absolute = i => ({ x: Math.abs(i.x), y: Math.abs(i.y) }), e.reverse = i => ({ x: i.x * -1, y: i.y * -1 }), e.pixelAligned = (i, o = { x: 0, y: 0 }) => ({ x: lS(i.x, o.x), y: lS(i.y, o.y) }), e.distance = (i, o) => { let s = Math.abs(i.x - o.x), a = Math.abs(i.y - o.y); return Math.sqrt(s * s + a * a) }, e.angle = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI - 90, e.angleFromX = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI, e.isEqual = (i, o) => i.x === o.x && i.y === o.y, e.rotationNormalizer = () => { let i; return o => { typeof i != "number" && (i = o); let s = i - o, a = Math.abs(s) + 180, l = Math.floor(a / 360); return s < 180 && (o -= l * 360), s > 180 && (o += l * 360), i = o, o } }; function t(i, o) { return { x: (i.x + o.x) / 2, y: (i.y + o.y) / 2 } } e.center = t; function n(i) { let o = 0, s = 0; i.forEach(c => { o += c.x, s += c.y }); let a = o / i.length, l = s / i.length; return { x: a, y: l } } e.centroid = n; function r(i) { let o = e.centroid(i), s = new Map; for (let a = 0; a < i.length; a++) { let l = i[a]; s.set(l, Math.atan2(l.x - o.x, l.y - o.y)) } return i.sort((a, l) => s.get(a) - s.get(l)) } e.sortClockwise = r })(dn || (dn = {})); var Lm = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }; function mi(e, t, n, r = !1) { let [i, o] = t, [s, a] = n, l = o - i; if (l === 0) return (a + s) / 2; let c = a - s; if (c === 0) return s; let u = s + (e - i) / l * c; if (r === !0) if (s < a) { if (u < s) return s; if (u > a) return a } else { if (u > s) return s; if (u < a) return a } return u } function rs(e) { return !isNaN(e) && isFinite(e) } function gi(e) { let t = Mm(e); return t !== void 0 ? e.includes("%") ? t / 100 : t : 0 } function Mm(e) { let t = /\d?\.?\d+/u.exec(e); return t ? Number(t[0]) : void 0 } var pO = (() => qL().Hsluv)(), Kt = new pO; function mO(e, t, n) { return Kt.rgb_r = e / 255, Kt.rgb_g = t / 255, Kt.rgb_b = n / 255, Kt.rgbToHsluv(), { h: Kt.hsluv_h, s: Kt.hsluv_s, l: Kt.hsluv_l } } function gO(e, t, n, r = 1) { return Kt.hsluv_h = e, Kt.hsluv_s = t, Kt.hsluv_l = n, Kt.hsluvToRgb(), { r: Kt.rgb_r * 255, g: Kt.rgb_g * 255, b: Kt.rgb_b * 255, a: r } } function vu(e, t, n, r) { let i = Math.round(e), o = Math.round(t * 100), s = Math.round(n * 100); return r === void 0 || r === 1 ? "hsv(" + i + ", " + o + "%, " + s + "%)" : "hsva(" + i + ", " + o + "%, " + s + "%, " + r + ")" } function vO(e, t, n) { return { r: rs(e) ? Nt(e, 255) * 255 : 0, g: rs(t) ? Nt(t, 255) * 255 : 0, b: rs(n) ? Nt(n, 255) * 255 : 0 } } function cS(e, t, n, r) { let i = [um(Math.round(e).toString(16)), um(Math.round(t).toString(16)), um(Math.round(n).toString(16))]; return r && i[0].charAt(0) === i[0].charAt(1) && i[1].charAt(0) === i[1].charAt(1) && i[2].charAt(0) === i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("") } function og(e, t, n) { let r, i, o = Nt(e, 255), s = Nt(t, 255), a = Nt(n, 255), l = Math.max(o, s, a), c = Math.min(o, s, a), u = i = r = (l + c) / 2; if (l === c) u = i = 0; else { let f = l - c; switch (i = r > .5 ? f / (2 - l - c) : f / (l + c), l) { case o: u = (s - a) / f + (s < a ? 6 : 0); break; case s: u = (a - o) / f + 2; break; case a: u = (o - s) / f + 4; break }u /= 6 } return { h: u * 360, s: i, l: r } } function cm(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function yO(e, t, n) { let r, i, o; if (e = Nt(e, 360), t = Nt(t * 100, 100), n = Nt(n * 100, 100), t === 0) r = i = o = n; else { let s = n < .5 ? n * (1 + t) : n + t - n * t, a = 2 * n - s; r = cm(a, s, e + 1 / 3), i = cm(a, s, e), o = cm(a, s, e - 1 / 3) } return { r: r * 255, g: i * 255, b: o * 255 } } function uS(e, t, n) { e = Nt(e, 255), t = Nt(t, 255), n = Nt(n, 255); let r = Math.max(e, t, n), i = Math.min(e, t, n), o = r - i, s, a = r === 0 ? 0 : o / r, l = r; if (r === i) s = 0; else { switch (r) { case e: s = (t - n) / o + (t < n ? 6 : 0); break; case t: s = (n - e) / o + 2; break; case n: s = (e - t) / o + 4; break }s /= 6 } return { h: s, s: a, v: l } } function bO(e, t, n) { e = Nt(e, 360) * 6, t = Nt(t * 100, 100), n = Nt(n * 100, 100); let r = Math.floor(e), i = e - r, o = n * (1 - t), s = n * (1 - i * t), a = n * (1 - (1 - i) * t), l = r % 6, c = [n, s, o, o, a, n][l], u = [a, n, n, s, o, o][l], f = [o, o, a, n, n, s][l]; return { r: c * 255, g: u * 255, b: f * 255 } } function Nt(e, t) { let n, r; if (typeof t == "string" ? n = parseFloat(t) : n = t, typeof e == "string") { xO(e) && (e = "100%"); let i = wO(e); r = Math.min(n, Math.max(0, parseFloat(e))), i && (r = Math.floor(r * n) / 100) } else r = e; return Math.abs(r - n) < 1e-6 ? 1 : r % n / n } function xO(e) { return typeof e == "string" && e.includes(".") && parseFloat(e) === 1 } function wO(e) { return typeof e == "string" && e.includes("%") } function um(e) { return e.length === 1 ? "0" + e : "" + e } var cr = (() => { let e = "[-\\+]?\\d+%?", n = "(?:" + "[-\\+]?\\d*\\.\\d+%?" + ")|(?:" + e + ")", r = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?", i = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?"; return { rgb: new RegExp("rgb" + r), rgba: new RegExp("rgba" + i), hsl: new RegExp("hsl" + r), hsla: new RegExp("hsla" + i), hsv: new RegExp("hsv" + r), hsva: new RegExp("hsva" + i), hex3: /^([\da-f])([\da-f])([\da-f])$/iu, hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu, hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu, hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu } })(); function sg(e) { if (e.includes("gradient(") || e.includes("var(")) return !1; let t = /^[\s,#]+/u, n = e.replace(t, "").trimEnd().toLowerCase(), r = Lm[n]; if (r && (n = r), n === "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" }; let i; return (i = cr.rgb.exec(n)) ? { r: parseInt(i[1] ?? ""), g: parseInt(i[2] ?? ""), b: parseInt(i[3] ?? ""), a: 1, format: "rgb" } : (i = cr.rgba.exec(n)) ? { r: parseInt(i[1] ?? ""), g: parseInt(i[2] ?? ""), b: parseInt(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "rgb" } : (i = cr.hsl.exec(n)) ? { h: parseInt(i[1] ?? ""), s: gi(i[2] ?? ""), l: gi(i[3] ?? ""), a: 1, format: "hsl" } : (i = cr.hsla.exec(n)) ? { h: parseInt(i[1] ?? ""), s: gi(i[2] ?? ""), l: gi(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "hsl" } : (i = cr.hsv.exec(n)) ? { h: parseInt(i[1] ?? ""), s: gi(i[2] ?? ""), v: gi(i[3] ?? ""), a: 1, format: "hsv" } : (i = cr.hsva.exec(n)) ? { h: parseInt(i[1] ?? ""), s: gi(i[2] ?? ""), v: gi(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "hsv" } : (i = cr.hex8.exec(n)) ? { r: fn(i[1] ?? ""), g: fn(i[2] ?? ""), b: fn(i[3] ?? ""), a: fS(i[4] ?? ""), format: r ? "name" : "hex" } : (i = cr.hex6.exec(n)) ? { r: fn(i[1] ?? ""), g: fn(i[2] ?? ""), b: fn(i[3] ?? ""), a: 1, format: r ? "name" : "hex" } : (i = cr.hex4.exec(n)) ? { r: fn(`${i[1]}${i[1]}`), g: fn(`${i[2]}${i[2]}`), b: fn(`${i[3]}${i[3]}`), a: fS(i[4] + "" + i[4]), format: r ? "name" : "hex" } : (i = cr.hex3.exec(n)) ? { r: fn(`${i[1]}${i[1]}`), g: fn(`${i[2]}${i[2]}`), b: fn(`${i[3]}${i[3]}`), a: 1, format: r ? "name" : "hex" } : !1 } function fn(e) { return parseInt(e, 16) } function fS(e) { return fn(e) / 255 } var dS = new Map, G = (() => { function e(o, s, a, l) { if (typeof o == "string") { let u = dS.get(o); return u || (u = t(o), u === void 0 ? { ...e("black"), isValid: !1 } : (dS.set(o, u), u)) } let c = t(o, s, a, l); return c !== void 0 ? c : { ...e("black"), isValid: !1 } } function t(o, s, a, l) { if (o === "") return; let c = SO(o, s, a, l); if (c) { let u = { r: c.r, g: c.g, b: c.b, a: c.a, h: c.h, s: c.s, l: c.l, initialValue: typeof o == "string" && c.format !== "hsv" ? o : void 0, roundA: Math.round(100 * c.a) / 100, format: c.format, mix: e.mix, toValue: () => e.toRgbString(u) }; return u } else return } let n = { isRGB(o) { return o === "rgb" || o === "rgba" }, isHSL(o) { return o === "hsl" || o === "hsla" } }; e.inspect = (o, s) => o.format === "hsl" ? `<${o.constructor.name} h:${o.h} s:${o.s} l:${o.l} a:${o.a}>` : o.format === "hex" || o.format === "name" ? `<${o.constructor.name} "${s}">` : `<${o.constructor.name} r:${o.r} g:${o.g} b:${o.b} a:${o.a}>`, e.isColor = o => typeof o == "string" ? e.isColorString(o) : e.isColorObject(o), e.isColorString = o => typeof o == "string" ? sg(o) !== !1 : !1, e.isColorObject = o => o && typeof o != "string" && typeof o.r == "number" && typeof o.g == "number" && typeof o.b == "number" && typeof o.h == "number" && typeof o.s == "number" && typeof o.l == "number" && typeof o.a == "number" && typeof o.roundA == "number" && typeof o.format == "string", e.toString = o => e.toRgbString(o), e.toHex = (o, s = !1) => cS(o.r, o.g, o.b, s), e.toHexString = (o, s = !1) => `#${e.toHex(o, s)}`, e.toRgbString = o => o.a === 1 ? "rgb(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ")" : "rgba(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ", " + o.roundA + ")", e.toHusl = o => ({ ...mO(o.r, o.g, o.b), a: o.roundA }), e.toHslString = o => { let s = e.toHsl(o), a = Math.round(s.h), l = Math.round(s.s * 100), c = Math.round(s.l * 100); return o.a === 1 ? "hsl(" + a + ", " + l + "%, " + c + "%)" : "hsla(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")" }, e.toHsv = o => { let s = uS(o.r, o.g, o.b); return { h: s.h * 360, s: s.s, v: s.v, a: o.a } }, e.toHsvString = o => { let s = uS(o.r, o.g, o.b), a = Math.round(s.h * 360), l = Math.round(s.s * 100), c = Math.round(s.v * 100); return o.a === 1 ? "hsv(" + a + ", " + l + "%, " + c + "%)" : "hsva(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")" }, e.toName = o => { if (o.a === 0) return "transparent"; if (o.a < 1) return !1; let s = cS(o.r, o.g, o.b, !0); for (let a of Object.keys(Lm)) if (Lm[a] === s) return a; return !1 }, e.toHsl = o => ({ h: Math.round(o.h), s: o.s, l: o.l, a: o.a }), e.toRgb = o => ({ r: Math.round(o.r), g: Math.round(o.g), b: Math.round(o.b), a: o.a }), e.brighten = (o, s = 10) => { let a = e.toRgb(o); return a.r = Math.max(0, Math.min(255, a.r - Math.round(255 * -(s / 100)))), a.g = Math.max(0, Math.min(255, a.g - Math.round(255 * -(s / 100)))), a.b = Math.max(0, Math.min(255, a.b - Math.round(255 * -(s / 100)))), e(a) }, e.lighten = (o, s = 10) => { let a = e.toHsl(o); return a.l += s / 100, a.l = Math.min(1, Math.max(0, a.l)), e(a) }, e.darken = (o, s = 10) => { let a = e.toHsl(o); return a.l -= s / 100, a.l = Math.min(1, Math.max(0, a.l)), e(a) }, e.saturate = (o, s = 10) => { let a = e.toHsl(o); return a.s += s / 100, a.s = Math.min(1, Math.max(0, a.s)), e(a) }, e.desaturate = (o, s = 10) => { let a = e.toHsl(o); return a.s -= s / 100, a.s = Math.min(1, Math.max(0, a.s)), e(a) }, e.grayscale = o => e.desaturate(o, 100), e.hueRotate = (o, s) => { let a = e.toHsl(o); return a.h += s, a.h = a.h > 360 ? a.h - 360 : a.h, e(a) }, e.alpha = (o, s = 1) => e({ r: o.r, g: o.g, b: o.b, a: s }), e.transparent = o => e.alpha(o, 0), e.multiplyAlpha = (o, s = 1) => e({ r: o.r, g: o.g, b: o.b, a: o.a * s }), e.interpolate = (o, s, a = "rgb") => { if (!e.isColorObject(o) || !e.isColorObject(s)) throw new TypeError("Both arguments for Color.interpolate must be Color objects"); return l => e.mixAsColor(o, s, l, !1, a) }, e.mix = (o, s, { model: a = "rgb" } = {}) => { let l = typeof o == "string" ? e(o) : o, c = e.interpolate(l, s, a); return u => e.toRgbString(c(u)) }, e.mixAsColor = (o, s, a = .5, l = !1, c = "rgb") => { let u = null; if (n.isRGB(c)) u = e({ r: mi(a, [0, 1], [o.r, s.r], l), g: mi(a, [0, 1], [o.g, s.g], l), b: mi(a, [0, 1], [o.b, s.b], l), a: mi(a, [0, 1], [o.a, s.a], l) }); else { let f, d; n.isHSL(c) ? (f = e.toHsl(o), d = e.toHsl(s)) : (f = e.toHusl(o), d = e.toHusl(s)), f.s === 0 ? f.h = d.h : d.s === 0 && (d.h = f.h); let p = f.h, y = d.h, g = y - p; g > 180 ? g = y - 360 - p : g < -180 && (g = y + 360 - p); let b = { h: mi(a, [0, 1], [p, p + g], l), s: mi(a, [0, 1], [f.s, d.s], l), l: mi(a, [0, 1], [f.l, d.l], l), a: mi(a, [0, 1], [o.a, s.a], l) }; n.isHSL(c) ? u = e(b) : u = e(gO(b.h, b.s, b.l, b.a)) } return u }, e.random = (o = 1) => { function s() { return Math.floor(Math.random() * 255) } return e("rgba(" + s() + ", " + s() + ", " + s() + ", " + o + ")") }, e.grey = (o = .5, s = 1) => (o = Math.floor(o * 255), e("rgba(" + o + ", " + o + ", " + o + ", " + s + ")")), e.gray = e.grey, e.rgbToHsl = (o, s, a) => og(o, s, a), e.isValidColorProperty = (o, s) => !!((o.toLowerCase().slice(-5) === "color" || o === "fill" || o === "stroke") && typeof s == "string" && e.isColorString(s)), e.difference = (o, s) => { let a = (o.r + s.r) / 2, l = o.r - s.r, c = o.g - s.g, u = o.b - s.b, f = Math.pow(l, 2), d = Math.pow(c, 2), p = Math.pow(u, 2); return Math.sqrt(2 * f + 4 * d + 3 * p + a * (f - p) / 256) }, e.equal = (o, s, a = .1) => !(Math.abs(o.r - s.r) >= a || Math.abs(o.g - s.g) >= a || Math.abs(o.b - s.b) >= a || Math.abs(o.a - s.a) * 256 >= a); let r = xo([0, 255], [0, 1]); function i(o) { o = r(o); let s = Math.abs(o); return s < .04045 ? o / 12.92 : (Math.sign(o) || 1) * Math.pow((s + .055) / 1.055, 2.4) } return e.luminance = o => { let { r: s, g: a, b: l } = e.toRgb(o); return .2126 * i(s) + .7152 * i(a) + .0722 * i(l) }, e.contrast = (o, s) => { let a = e.luminance(o), l = e.luminance(s); return (Math.max(a, l) + .05) / (Math.min(a, l) + .05) }, e })(); function SO(e, t, n, r = 1) { let i; return typeof e == "number" && !Number.isNaN(e) && typeof t == "number" && !Number.isNaN(t) && typeof n == "number" && !Number.isNaN(n) ? i = Om({ r: e, g: t, b: n, a: r }) : typeof e == "string" ? i = kO(e) : typeof e == "object" && (e.hasOwnProperty("r") && e.hasOwnProperty("g") && e.hasOwnProperty("b") ? i = Om(e) : i = Dk(e)), i } function kO(e) { let t = sg(e); if (t) return t.format === "hsl" ? Dk(t) : t.format === "hsv" ? CO(t) : Om(t) } function CO(e) { let t = bO(e.h, e.s, e.v); return { ...og(t.r, t.g, t.b), ...t, format: "rgb", a: e.a !== void 0 ? Ak(e.a) : 1 } } function Om(e) { let t = vO(e.r, e.g, e.b); return { ...og(t.r, t.g, t.b), ...t, format: "rgb", a: e.a !== void 0 ? Ak(e.a) : 1 } } function Dk(e) { let t, n, r, i = { r: 0, g: 0, b: 0 }, o = { h: 0, s: 0, l: 0 }; return t = rs(e.h) ? e.h : 0, t = (t + 360) % 360, n = rs(e.s) ? e.s : 1, typeof e.s == "string" && (n = Mm(e.s)), r = rs(e.l) ? e.l : .5, typeof e.l == "string" && (r = Mm(e.l)), i = yO(t, n, r), o = { h: t, s: n, l: r }, { ...i, ...o, a: e.a === void 0 ? 1 : e.a, format: "hsl" } } function Ak(e) { return e = parseFloat(e), e < 0 && (e = 0), (isNaN(e) || e > 1) && (e = 1), e } var hS = e => e instanceof Vs; var TO = (() => XL().EventEmitter)(), EO = class { constructor() { T(this, "_emitter", new TO) } eventNames() { return this._emitter.eventNames() } eventListeners() { let e = {}; for (let t of this._emitter.eventNames()) e[t] = this._emitter.listeners(t); return e } on(e, t) { this.addEventListener(e, t, !1, !1, this) } off(e, t) { this.removeEventListeners(e, t) } once(e, t) { this.addEventListener(e, t, !0, !1, this) } unique(e, t) { this.addEventListener(e, t, !1, !0, this) } addEventListener(e, t, n, r, i) { if (r) { for (let o of this._emitter.eventNames()) if (t === this._emitter.listeners(o)) return } n === !0 ? this._emitter.once(e, t, i) : this._emitter.addListener(e, t, i) } removeEventListeners(e, t) { e ? this._emitter.removeListener(e, t) : this.removeAllEventListeners() } removeAllEventListeners() { this._emitter.removeAllListeners() } countEventListeners(e, t) { if (e) return this._emitter.listeners(e).length; { let n = 0; for (let r of this._emitter.eventNames()) n += this._emitter.listeners(r).length; return n } } emit(e, ...t) { this._emitter.emit(e, ...t) } }, RO = { addEventListener: () => { }, removeEventListener: () => { }, dispatchEvent: () => !1, ResizeObserver: void 0, onpointerdown: !1, onpointermove: !1, onpointerup: !1, ontouchstart: !1, ontouchmove: !1, ontouchend: !1, onmousedown: !1, onmousemove: !1, onmouseup: !1, devicePixelRatio: 1, scrollX: 0, scrollY: 0, location: { href: "" }, document: { cookie: "" }, setTimeout: () => 0, clearTimeout: () => { }, setInterval: () => 0, clearInterval: () => { }, requestAnimationFrame: () => 0, cancelAnimationFrame: () => { }, getSelection: () => null, matchMedia: e => ({ matches: !1, media: e, onchange: () => { }, addEventListener: () => { }, removeEventListener: () => { }, addListener: () => { }, removeListener: () => { }, dispatchEvent: () => !1 }), innerHeight: 0, innerWidth: 0, SVGSVGElement: {}, open: function (e, t, n) { } }, ft = typeof I > "u" ? RO : I, PO = e => { setTimeout(e, 1 / 60) }, _O = (() => ft.requestAnimationFrame || PO)(), pS = e => _O(e), Fa = (() => 1 / 60)(), FO = class extends EO { constructor(e = !1) { super(), T(this, "_started", !1), T(this, "_frame", 0), T(this, "_frameTasks", []), T(this, "tick", () => { this._started && (pS(this.tick), this.emit("update", this._frame, Fa), this.emit("render", this._frame, Fa), this._processFrameTasks(), this._frame++) }), e && this.start() } addFrameTask(e) { this._frameTasks.push(e) } _processFrameTasks() { var e; let t = this._frameTasks, n = t.length; if (n !== 0) { for (let r = 0; r < n; r++)(e = t[r]) == null || e.call(t); t.length = 0 } } static set TimeStep(e) { Fa = e } static get TimeStep() { return Fa } start() { return this._started ? this : (this._frame = 0, this._started = !0, pS(this.tick), this) } stop() { return this._started = !1, this } get frame() { return this._frame } get time() { return this._frame * Fa } }, Vk = new FO, Vu = { target: "PREVIEW", zoom: 1 }; var le = { canvas: "CANVAS", export: "EXPORT", thumbnail: "THUMBNAIL", preview: "PREVIEW", current: () => Vu.target, hasRestrictions: () => { let e = Vu.target; return e === "CANVAS" || e === "EXPORT" } }; var yu = e => ({ correct: (t, { delta: n, treeScale: r }) => { if (typeof t == "string" && (t = parseFloat(t)), t === 0) return "0px"; let i = t; return n && r && (i = Math.round(t / n[e].scale / r[e]), i = Math.max(i, 1)), i + "px" } }); od({ borderTopWidth: yu("y"), borderLeftWidth: yu("x"), borderRightWidth: yu("x"), borderBottomWidth: yu("y") }); function $(e, ...t) {
    var n, r; if (e) return; let i = Error("Assertion Error" + (t.length > 0 ? ": " + t.join(" ") : "")); if (i.stack) try {
        let o = i.stack.split(`
`); (n = o[1]) != null && n.includes("assert") ? (o.splice(1, 1), i.stack = o.join(`
`)) : (r = o[0]) != null && r.includes("assert") && (o.splice(0, 1), i.stack = o.join(`
`))
    } catch { } throw i
} function xe(e, t) { throw t || new Error(e ? `Unexpected value: ${e}` : "Application entered invalid state") } var is = x.createContext({ getLayoutId: e => null, persistLayoutIdCache: () => { }, top: !1, enabled: !0 }); function IO({ children: e }) { if (V(is).top) return k(He, { children: e }); let n = D({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {}, count: { byId: {}, byName: {} } }), r = D({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }), i = D(new Set).current, o = se(({ id: l, name: c, duplicatedFrom: u }) => { if (!l) return null; let f = c ? "byName" : "byId", d = n.current[f][l]; if (d) return d; let p = c || l; if (!u && !i.has(p) && (!n.current.byLayoutId[p] || n.current.byLayoutId[p] === p)) return n.current.count[f][p] === void 0 && (n.current.count[f][p] = 0, n.current.byLayoutId[p] = p, r.current[f][l] = p), i.add(p), p; let y; if (u?.length) for (let S = u.length - 1; S >= 0; S--) { let R = u[S]; $(!!R, "duplicatedId must be defined"); let E = n.current[f][R], L = n.current.byLastId[R]; if (L && !y) { let A = n.current.byLayoutId[L], K = !A || A === c; L && !i.has(L) && (!c || K) && (y = [L, R]) } let F = E ? n.current.byLayoutId[E] : void 0, N = !F || F === c; if (E && !i.has(E) && (!c || N)) return r.current[f][l] = E, r.current.byLastId[R] = E, i.add(E), E } let g = n.current.byLastId[l]; if (g && !i.has(g)) return i.add(g), r.current.byId[l] = g, g; if (y) { let [S, R] = y; return r.current[f][l] = S, r.current.byLastId[R] = S, i.add(S), S } let b = n.current.byPossibleId[l]; if (b && !i.has(b)) return i.add(b), r.current.byId[l] = b, b; let h = u?.[0], m = c || h || l, v = (n.current.count[f][m] ?? -1) + 1, { layoutId: w, value: C } = LO(m, v, i); if (n.current.count[f][m] = C, r.current[f][l] = w, u?.length && !c) { let S = u[u.length - 1]; if (S && (r.current.byLastId[S] = w), u.length > 1) for (let R = 0; R < u.length - 1; R++) { let E = u[R]; E !== void 0 && (r.current.byPossibleId[E] || (r.current.byPossibleId[E] = w)) } } return r.current.byLayoutId[w] = p, i.add(w), w }, []), s = se(() => { n.current = { byId: { ...n.current.byId, ...r.current.byId }, byLastId: { ...n.current.byLastId, ...r.current.byLastId }, byPossibleId: { ...n.current.byPossibleId, ...r.current.byPossibleId }, byName: { ...n.current.byName, ...r.current.byName }, byLastName: { ...n.current.byLastName, ...r.current.byLastName }, byLayoutId: { ...n.current.byLayoutId, ...r.current.byLayoutId }, count: { ...n.current.count, byName: {} } }, r.current = { byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }, i.clear() }, []), a = D({ getLayoutId: o, persistLayoutIdCache: s, top: !0, enabled: !0 }).current; return k(is.Provider, { value: a, children: e }) } function LO(e, t, n) { let r = t, i = r ? `${e}-${r}` : e; for (; n.has(i);)r++, i = `${e}-${r}`; return { layoutId: i, value: r } } function MO({ enabled: e = !0, ...t }) { let n = V(is), r = ae(() => ({ ...n, enabled: e }), [e]); return k(is.Provider, { ...t, value: r }) } function Qt(e) { let t = D(null); return t.current === null && (t.current = e()), t.current } var OO = { background: void 0, display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", lineHeight: "1.4em", textOverflow: "ellipsis", overflow: "hidden", minHeight: 0, width: "100%", height: "100%" }, DO = (() => ({ ...OO, border: "1px solid rgba(149, 149, 149, 0.15)", borderRadius: 6, fontSize: "12px", backgroundColor: "rgba(149, 149, 149, 0.1)", color: "#a5a5a5" }))(), Bk = { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", maxWidth: "100%", flexShrink: 0, padding: "0 10px" }, AO = (() => ({ ...Bk, fontWeight: 500 }))(), VO = (() => ({ ...Bk, whiteSpace: "pre", maxHeight: "calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))", WebkitMaskImage: "linear-gradient(to bottom, black 80%, transparent 100%)" }))(); function zH(e) { let { error: t, file: n } = e, r = n ? `Error in ${BO(n)}` : "Error", i = t instanceof Error ? t.message : "" + t; return ue("div", { style: DO, children: [k("div", { className: "text", style: AO, children: r }), i && k("div", { className: "text", style: VO, children: i })] }) } function BO(e) { return e.startsWith("./") ? e.replace("./", "") : e } function J(e) { return typeof e == "number" && isFinite(e) } function zO(e) { return !e || !Object.keys(e).length && e.constructor === Object } function Tu(e) { return typeof e != "string" && typeof e != "number" } function Eu(e) { return e !== null && typeof e < "u" && typeof e != "boolean" && !zO(e) } function $O(e) { return e * (Math.PI / 180) } var En = (() => { function e(t, n) { return { a: t, b: n } } return e.offset = (t, n) => { let r = dn.angleFromX(t.a, t.b), i = $O(r), o = n * Math.sin(i), s = n * Math.cos(i); return e({ x: t.a.x + o, y: t.a.y - s }, { x: t.b.x + o, y: t.b.y - s }) }, e.intersection = (t, n, r) => { let i = t.a.x, o = t.a.y, s = t.b.x, a = t.b.y, l = n.a.x, c = n.a.y, u = n.b.x, f = n.b.y, d = (u - l) * (c - o) - (f - c) * (l - i), p = (u - l) * (a - o) - (f - c) * (s - i), y = (s - i) * (c - o) - (a - o) * (l - i); if (d === 0 && p === 0 || p === 0) return null; let g = d / p, b = y / p; return r && (g < 0 || g > 1 || b < 0 || b > 1) ? null : { x: i + g * (s - i), y: o + g * (a - o) } }, e.intersectionAngle = (t, n) => { let r = t.b.x - t.a.x, i = t.b.y - t.a.y, o = n.b.x - n.a.x, s = n.b.y - n.a.y; return Math.atan2(r * s - i * o, r * o + i * s) * (180 / Math.PI) }, e.isOrthogonal = t => t.a.x === t.b.x || t.a.y === t.b.y, e.perpendicular = (t, n) => { let r = t.a.x - t.b.x, i = t.a.y - t.b.y, o = dn(n.x - i, n.y + r); return e(o, n) }, e.projectPoint = (t, n) => { let r = e.perpendicular(t, n); return e.intersection(t, r) }, e.pointAtPercentDistance = (t, n) => { let r = e.distance(t), i = n * r / r; return { x: i * t.b.x + (1 - i) * t.a.x, y: i * t.b.y + (1 - i) * t.a.y } }, e.distance = t => dn.distance(t.a, t.b), e })(), Z = { equals: function (e, t) { return e === t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height }, atOrigin: e => ({ ...e, x: 0, y: 0 }), fromTwoPoints: (e, t) => ({ x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), width: Math.abs(e.x - t.x), height: Math.abs(e.y - t.y) }), fromRect: e => ({ x: e.left, y: e.top, width: e.right - e.left, height: e.bottom - e.top }), multiply: (e, t) => ({ x: e.x * t, y: e.y * t, width: e.width * t, height: e.height * t }), divide: (e, t) => Z.multiply(e, 1 / t), offset: (e, t) => { let n = typeof t.x == "number" ? t.x : 0, r = typeof t.y == "number" ? t.y : 0; return { ...e, x: e.x + n, y: e.y + r } }, inflate: (e, t) => { if (t === 0) return e; let n = 2 * t; return { x: e.x - t, y: e.y - t, width: e.width + n, height: e.height + n } }, pixelAligned: e => { let t = Math.round(e.x), n = Math.round(e.y), r = Math.round(e.x + e.width), i = Math.round(e.y + e.height), o = Math.max(r - t, 0), s = Math.max(i - n, 0); return { x: t, y: n, width: o, height: s } }, halfPixelAligned: e => { let t = Math.round(e.x * 2) / 2, n = Math.round(e.y * 2) / 2, r = Math.round((e.x + e.width) * 2) / 2, i = Math.round((e.y + e.height) * 2) / 2, o = Math.max(r - t, 1), s = Math.max(i - n, 1); return { x: t, y: n, width: o, height: s } }, round: (e, t = 0) => { let n = gu(e.x, t), r = gu(e.y, t), i = gu(e.width, t), o = gu(e.height, t); return { x: n, y: r, width: i, height: o } }, roundToOutside: e => { let t = Math.floor(e.x), n = Math.floor(e.y), r = Math.ceil(e.x + e.width), i = Math.ceil(e.y + e.height), o = Math.max(r - t, 0), s = Math.max(i - n, 0); return { x: t, y: n, width: o, height: s } }, minX: e => e.x, maxX: e => e.x + e.width, minY: e => e.y, maxY: e => e.y + e.height, positions: e => ({ minX: e.x, midX: e.x + e.width / 2, maxX: Z.maxX(e), minY: e.y, midY: e.y + e.height / 2, maxY: Z.maxY(e) }), center: e => ({ x: e.x + e.width / 2, y: e.y + e.height / 2 }), boundingRectFromPoints: e => { let t = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0; for (let o = 0; o < e.length; o++) { let s = e[o]; t = Math.min(t, s.x), n = Math.max(n, s.x), r = Math.min(r, s.y), i = Math.max(i, s.y) } return { x: t, y: r, width: n - t, height: i - r } }, fromPoints: e => { let [t, n, r, i] = e, { x: o, y: s } = t, a = dn.distance(t, n), l = dn.distance(t, i); return { x: o, y: s, width: a, height: l } }, merge: (...e) => { let t = { x: Math.min(...e.map(Z.minX)), y: Math.min(...e.map(Z.minY)) }, n = { x: Math.max(...e.map(Z.maxX)), y: Math.max(...e.map(Z.maxY)) }; return Z.fromTwoPoints(t, n) }, intersection: (e, t) => { let n = Math.max(e.x, t.x), r = Math.min(e.x + e.width, t.x + t.width), i = Math.max(e.y, t.y), o = Math.min(e.y + e.height, t.y + t.height); return { x: n, y: i, width: r - n, height: o - i } }, points: e => [{ x: Z.minX(e), y: Z.minY(e) }, { x: Z.minX(e), y: Z.maxY(e) }, { x: Z.maxX(e), y: Z.minY(e) }, { x: Z.maxX(e), y: Z.maxY(e) }], pointsAtOrigin: e => [{ x: 0, y: 0 }, { x: e.width, y: 0 }, { x: e.width, y: e.height }, { x: 0, y: e.height }], transform: (e, t) => { let { x: n, y: r } = t.transformPoint({ x: e.x, y: e.y }), { x: i, y: o } = t.transformPoint({ x: e.x + e.width, y: e.y }), { x: s, y: a } = t.transformPoint({ x: e.x + e.width, y: e.y + e.height }), { x: l, y: c } = t.transformPoint({ x: e.x, y: e.y + e.height }), u = Math.min(n, i, s, l), f = Math.max(n, i, s, l) - u, d = Math.min(r, o, a, c), p = Math.max(r, o, a, c) - d; return { x: u, y: d, width: f, height: p } }, containsPoint: (e, t) => !(t.x < Z.minX(e) || t.x > Z.maxX(e) || t.y < Z.minY(e) || t.y > Z.maxY(e) || isNaN(e.x) || isNaN(e.y)), containsRect: (e, t) => { for (let n of Z.points(t)) if (!Z.containsPoint(e, n)) return !1; return !0 }, toCSS: e => ({ display: "block", transform: `translate(${e.x}px, ${e.y}px)`, width: `${e.width}px`, height: `${e.height}px` }), inset: (e, t) => ({ x: e.x + t, y: e.y + t, width: Math.max(0, e.width - 2 * t), height: Math.max(0, e.height - 2 * t) }), intersects: (e, t) => !(t.x >= Z.maxX(e) || Z.maxX(t) <= e.x || t.y >= Z.maxY(e) || Z.maxY(t) <= e.y), overlapHorizontally: (e, t) => { let n = Z.maxX(e), r = Z.maxX(t); return n > t.x && r > e.x }, overlapVertically: (e, t) => { let n = Z.maxY(e), r = Z.maxY(t); return n > t.y && r > e.y }, doesNotIntersect: (e, t) => t.find(n => Z.intersects(n, e)) === void 0, isEqual: (e, t) => Z.equals(e, t), cornerPoints: e => { let t = e.x, n = e.x + e.width, r = e.y, i = e.y + e.height; return [{ x: t, y: r }, { x: n, y: r }, { x: n, y: i }, { x: t, y: i }] }, midPoints: e => { let t = e.x, n = e.x + e.width / 2, r = e.x + e.width, i = e.y, o = e.y + e.height / 2, s = e.y + e.height; return [{ x: n, y: i }, { x: r, y: o }, { x: n, y: s }, { x: t, y: o }] }, pointDistance: (e, t) => { let n = 0, r = 0; return t.x < e.x ? n = e.x - t.x : t.x > Z.maxX(e) && (n = t.x - Z.maxX(e)), t.y < e.y ? r = e.y - t.y : t.y > Z.maxY(e) && (r = t.y - Z.maxY(e)), dn.distance({ x: n, y: r }, { x: 0, y: 0 }) }, fromAny: (e, t = { x: 0, y: 0, width: 0, height: 0 }) => ({ x: e.x || t.x, y: e.y || t.y, width: e.width || t.width, height: e.height || t.height }), delta: (e, t) => { let n = { x: Z.minX(e), y: Z.minY(e) }, r = { x: Z.minX(t), y: Z.minY(t) }; return { x: n.x - r.x, y: n.y - r.y } }, withMinSize: (e, t) => { let { width: n, height: r } = t, i = e.width - n, o = e.height - r; return { width: Math.max(e.width, n), height: Math.max(e.height, r), x: e.width < n ? e.x + i / 2 : e.x, y: e.height < r ? e.y + o / 2 : e.y } }, anyPointsOutsideRect: (e, t) => { let n = Z.minX(e), r = Z.minY(e), i = Z.maxX(e), o = Z.maxY(e); for (let s of t) if (s.x < n || s.x > i || s.y < r || s.y > o) return !0; return !1 }, edges: e => { let [t, n, r, i] = Z.cornerPoints(e); return [En(t, n), En(n, r), En(r, i), En(i, t)] }, rebaseRectOnto: (e, t, n, r) => { let i = { ...e }; switch (n) { case "bottom": case "top": switch (r) { case "start": i.x = t.x; break; case "center": i.x = t.x + t.width / 2 - e.width / 2; break; case "end": i.x = t.x + t.width - e.width; break; default: xe(r) }break; case "left": i.x = t.x - e.width; break; case "right": i.x = t.x + t.width; break; default: xe(n) }switch (n) { case "left": case "right": switch (r) { case "start": i.y = t.y; break; case "center": i.y = t.y + t.height / 2 - e.height / 2; break; case "end": i.y = t.y + t.height - e.height; break; default: xe(r) }break; case "top": i.y = t.y - e.height; break; case "bottom": i.y = t.y + t.height; break; default: xe(n) }return i } }; var zk = { quickfix: e => ((e.widthType === 2 || e.heightType === 2) && (e.aspectRatio = null), J(e.aspectRatio) && (e.left && e.right && (e.widthType = 0), e.top && e.bottom && (e.heightType = 0), e.left && e.right && e.top && e.bottom && (e.bottom = !1), e.widthType !== 0 && e.heightType !== 0 && (e.heightType = 0)), e.left && e.right && ((e.fixedSize || e.widthType === 2 || J(e.maxWidth)) && (e.right = !1), e.widthType = 0), e.top && e.bottom && ((e.fixedSize || e.heightType === 2 || J(e.maxHeight)) && (e.bottom = !1), e.heightType = 0), e) }; function Bu(e) { if (typeof e == "string") { let t = e.trim(); if (t === "auto") return 2; if (t.endsWith("fr")) return 3; if (t.endsWith("%")) return 1; if (t.endsWith("vw") || t.endsWith("vh")) return 4 } return 0 } var $k = { fromProperties: e => { let { left: t, right: n, top: r, bottom: i, width: o, height: s, centerX: a, centerY: l, aspectRatio: c, autoSize: u } = e, f = zk.quickfix({ left: J(t) || Nn(t), right: J(n) || Nn(n), top: J(r) || Nn(r), bottom: J(i) || Nn(i), widthType: Bu(o), heightType: Bu(s), aspectRatio: c || null, fixedSize: u === !0 }), d = null, p = null, y = 0, g = 0; if (f.widthType !== 0 && typeof o == "string") { let m = parseFloat(o); o.endsWith("fr") ? (y = 3, d = m) : o === "auto" ? y = 2 : (y = 1, d = m / 100) } else o !== void 0 && typeof o != "string" && (d = it.getNumber(o)); if (f.heightType !== 0 && typeof s == "string") { let m = parseFloat(s); s.endsWith("fr") ? (g = 3, p = m) : s === "auto" ? g = 2 : (g = 1, p = parseFloat(s) / 100) } else s !== void 0 && typeof s != "string" && (p = it.getNumber(s)); let b = .5, h = .5; return a && (b = parseFloat(a) / 100), l && (h = parseFloat(l) / 100), { left: f.left ? it.getNumber(t) : null, right: f.right ? it.getNumber(n) : null, top: f.top ? it.getNumber(r) : null, bottom: f.bottom ? it.getNumber(i) : null, widthType: y, heightType: g, width: d, height: p, aspectRatio: f.aspectRatio || null, centerAnchorX: b, centerAnchorY: h } }, toSize: (e, t, n, r) => { let i = null, o = null, s = t?.sizing ? it.getNumber(t?.sizing.width) : null, a = t?.sizing ? it.getNumber(t?.sizing.height) : null, l = mS(e.left, e.right); if (s && J(l)) i = s - l; else if (n && e.widthType === 2) i = n.width; else if (J(e.width)) switch (e.widthType) { case 0: i = e.width; break; case 3: i = r ? r.freeSpaceInParent.width / r.freeSpaceUnitDivisor.width * e.width : null; break; case 1: case 4: s && (i = s * e.width); break; case 2: break; default: xe(e.widthType) }let c = mS(e.top, e.bottom); if (a && J(c)) o = a - c; else if (n && e.heightType === 2) o = n.height; else if (J(e.height)) switch (e.heightType) { case 0: o = e.height; break; case 3: o = r ? r.freeSpaceInParent.height / r.freeSpaceUnitDivisor.height * e.height : null; break; case 1: case 4: a && (o = a * e.height); break; case 2: break; default: xe(e.heightType) }return UO(i, o, e, { height: a ?? 0, width: s ?? 0 }, t?.viewport) }, toRect: (e, t = null, n = null, r = !1, i = null) => { let o = e.left || 0, s = e.top || 0, { width: a, height: l } = $k.toSize(e, t, n, i), c = t?.positioning ?? null, u = c ? it.getNumber(c.width) : null, f = c ? it.getNumber(c.height) : null; e.left !== null ? o = e.left : u && e.right !== null ? o = u - e.right - a : u && (o = e.centerAnchorX * u - a / 2), e.top !== null ? s = e.top : f && e.bottom !== null ? s = f - e.bottom - l : f && (s = e.centerAnchorY * f - l / 2); let d = { x: o, y: s, width: a, height: l }; return r ? Z.pixelAligned(d) : d } }, NO = 200, HO = 200; function zu(e, t, n, r) { if (typeof t == "string") { if (t.endsWith("%") && n) switch (e) { case "maxWidth": case "minWidth": return parseFloat(t) / 100 * n.width; case "maxHeight": case "minHeight": return parseFloat(t) / 100 * n.height; default: break }if (t.endsWith("vh") && r) switch (e) { case "maxWidth": case "minWidth": return parseFloat(t) / 100 * r.width; case "maxHeight": case "minHeight": return parseFloat(t) / 100 * r.height; default: break }return parseFloat(t) } return t } function jO(e, t, n, r) { return t.minHeight && (e = Math.max(zu("minHeight", t.minHeight, n, r), e)), t.maxHeight && (e = Math.min(zu("maxHeight", t.maxHeight, n, r), e)), e } function WO(e, t, n, r) { return t.minWidth && (e = Math.max(zu("minWidth", t.minWidth, n, r), e)), t.maxWidth && (e = Math.min(zu("maxWidth", t.maxWidth, n, r), e)), e } function UO(e, t, n, r, i) { let o = WO(J(e) ? e : NO, n, r, i), s = jO(J(t) ? t : HO, n, r, i); return J(n.aspectRatio) && n.aspectRatio > 0 && (J(n.left) && J(n.right) ? s = o / n.aspectRatio : J(n.top) && J(n.bottom) ? o = s * n.aspectRatio : n.widthType !== 0 ? s = o / n.aspectRatio : o = s * n.aspectRatio), { width: o, height: s } } function mS(e, t) { return !J(e) || !J(t) ? null : e + t } function GO(e) { return typeof e.right == "string" || typeof e.bottom == "string" || typeof e.left == "string" && (!e.center || e.center === "y") || typeof e.top == "string" && (!e.center || e.center === "x") } function Za(e) { return !e._constraints || GO(e) ? !1 : e._constraints.enabled } function qO(e) { let { size: t } = e, { width: n, height: r } = e; return J(t) && (n === void 0 && (n = t), r === void 0 && (r = t)), J(n) && J(r) ? { width: n, height: r } : null } function XO(e) { let t = qO(e); if (t === null) return null; let { left: n, top: r } = e; return J(n) && J(r) ? { x: n, y: r, ...t } : null } function $a(e, t, n = !0) { if (e.positionFixed || e.positionAbsolute) return null; let r = t === 1 || t === 2; if (!Za(e) || r) return XO(e); let i = YO(e), o = KO(t), s = o ? { sizing: o, positioning: o, viewport: null } : null; return $k.toRect(i, s, null, n, null) } function YO(e) { let { left: t, right: n, top: r, bottom: i, center: o, _constraints: s, size: a } = e, { width: l, height: c } = e; l === void 0 && (l = a), c === void 0 && (c = a); let { aspectRatio: u, autoSize: f } = s, d = zk.quickfix({ left: J(t), right: J(n), top: J(r), bottom: J(i), widthType: Bu(l), heightType: Bu(c), aspectRatio: u || null, fixedSize: f === !0 }), p = null, y = null, g = 0, b = 0; if (d.widthType !== 0 && typeof l == "string") { let v = parseFloat(l); l.endsWith("fr") ? (g = 3, p = v) : l === "auto" ? g = 2 : (g = 1, p = v / 100) } else l !== void 0 && typeof l != "string" && (p = l); if (d.heightType !== 0 && typeof c == "string") { let v = parseFloat(c); c.endsWith("fr") ? (b = 3, y = v) : c === "auto" ? b = 2 : (b = 1, y = parseFloat(c) / 100) } else c !== void 0 && typeof c != "string" && (y = c); let h = .5, m = .5; return (o === !0 || o === "x") && (d.left = !1, typeof t == "string" && (h = parseFloat(t) / 100)), (o === !0 || o === "y") && (d.top = !1, typeof r == "string" && (m = parseFloat(r) / 100)), { left: d.left ? t : null, right: d.right ? n : null, top: d.top ? r : null, bottom: d.bottom ? i : null, widthType: g, heightType: b, width: p, height: y, aspectRatio: d.aspectRatio || null, centerAnchorX: h, centerAnchorY: m, minHeight: e.minHeight, maxHeight: e.maxHeight, minWidth: e.minWidth, maxWidth: e.maxWidth } } var Nk = x.createContext({ parentSize: 0 }); function KO(e) { return e === 0 || e === 1 || e === 2 ? null : e } function Ja() { return x.useContext(Nk).parentSize } function Hk(e) { return typeof e == "object" } var QO = e => { let t = Ja(), { parentSize: n, children: r } = e, i = x.useMemo(() => ({ parentSize: n }), [ZO(n), JO(n)]); return t === 1 ? r ? k(He, { children: r }) : null : k(Nk.Provider, { value: i, children: r }) }; function ZO(e) { return Hk(e) ? e.width : e } function JO(e) { return Hk(e) ? e.height : e } function eD(e, t) { return k(QO, { parentSize: t, children: e }) } function tD(e) { let t = Ja(); return $a(e, t, !0) } function jk({ width: e, height: t }) { return e === "auto" || e === "min-content" || t === "auto" || t === "min-content" } var nD = (e => (e.Boolean = "boolean", e.Number = "number", e.String = "string", e.RichText = "richtext", e.FusedNumber = "fusednumber", e.Enum = "enum", e.SegmentedEnum = "segmentedenum", e.Color = "color", e.Image = "image", e.ResponsiveImage = "responsiveimage", e.File = "file", e.ComponentInstance = "componentinstance", e.Array = "array", e.EventHandler = "eventhandler", e.Transition = "transition", e.BoxShadow = "boxshadow", e.Link = "link", e.Date = "date", e.Object = "object", e.Font = "font", e.PageScope = "pagescope", e.ScrollSectionRef = "scrollsectionref", e.CustomCursor = "customcursor", e.Border = "border", e.Cursor = "cursor", e.Padding = "padding", e.BorderRadius = "borderradius", e.CollectionReference = "collectionreference", e.MultiCollectionReference = "multicollectionreference", e))(nD || {}), fm; function rD() { if (fm !== void 0) return fm; let e = document.createElement("div"); Object.assign(e.style, { position: "absolute", display: "flex", flexDirection: "column", rowGap: "1px" }), e.appendChild(document.createElement("div")), e.appendChild(document.createElement("div")), document.body.appendChild(e); let t = e.scrollHeight === 1; return e.parentNode && e.parentNode.removeChild(e), fm = t, t } var to = "flexbox-gap-not-supported", gS = !1; function WH() { gS || (gS = !0, !rD() && document.body.classList.add(to)) } var iD = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`, oD = `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`, sD = `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`, aD = `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`, lD = `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, cD = `
a[data-framer-page-link-current],
a[data-framer-page-link-current] span:not([data-text-fill]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, uD = `
a[data-framer-page-link-current]:hover,
a[data-framer-page-link-current]:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`, fD = `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`, dD = `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`, hD = `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`, pD = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`, mD = `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
    --framer-font-open-type-features: normal;
}
`, gD = `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`, vD = `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`, yD = `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`, bD = `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "\u2022";
}
`, xD = ['[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }', mD, pD, iD, oD, sD, aD, lD, cD, uD, fD, dD, hD, gD, vD, yD, bD], wD = [`
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `, `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-blockquote-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-text-transform, none));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-text-decoration, none));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
            text-align: var(--framer-blockquote-text-alignment, var(--framer-text-alignment, start));
            -webkit-text-stroke-width: var(--framer-text-stroke-width, initial);
            -webkit-text-stroke-color: var(--framer-text-stroke-color, initial);
            -moz-font-feature-settings: var(--framer-font-open-type-features, initial);
            -webkit-font-feature-settings: var(--framer-font-open-type-features, initial);
            font-feature-settings: var(--framer-font-open-type-features, initial);
            text-wrap: var(--framer-text-wrap-override, var(--framer-text-wrap));
        }
    `, `
        .framer-fit-text .framer-text {
            white-space: nowrap;
            white-space-collapse: preserve;
        }
    `, `
        strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold, var(--framer-font-family-bold));
            font-style: var(--framer-blockquote-font-style-bold, var(--framer-font-style-bold));
            font-weight: var(--framer-blockquote-font-weight-bold, var(--framer-font-weight-bold, bolder));
        }
    `, `
        em.framer-text {
            font-family: var(--framer-blockquote-font-family-italic, var(--framer-font-family-italic));
            font-style: var(--framer-blockquote-font-style-italic, var(--framer-font-style-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-italic, var(--framer-font-weight-italic));
        }
    `, `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold-italic, var(--framer-font-family-bold-italic));
            font-style: var(--framer-blockquote-font-style-bold-italic, var(--framer-font-style-bold-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-bold-italic, var(--framer-font-weight-bold-italic, bolder));
        }
    `, `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        blockquote.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-blockquote-paragraph-spacing, var(--framer-paragraph-spacing, 0));
        }
    `, `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `, `
        .framer-text[data-text-fill] {
            display: inline-block;
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / -2));
        }
    `, `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
        }
    `, `
        blockquote.framer-text {
            margin-block-start: initial;
            margin-block-end: initial;
            margin-inline-start: initial;
            margin-inline-end: initial;
            unicode-bidi: initial;
        }
    `, `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
        }
    `, `
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text:hover,
        code.framer-text a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        .framer-image.framer-text {
            display: block;
            max-width: 100%;
            height: auto;
        }
    `, `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
            --framer-font-open-type-features: normal;
        }
    `, `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `, `
        ul.framer-text,
        ol.framer-text {
            display: table;
            width: 100%;
        }
    `, `
        li.framer-text {
            display: table-row;
            counter-increment: list-item;
            list-style: none;
        }
    `, `
        ol.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: counter(list-item, var(--list-style-type)) ".";
            white-space: nowrap;
        }
    `, `
        ul.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: "\u2022";
        }
    `, `
        .framer-text-module[style*="aspect-ratio"] > :first-child {
            width: 100%;
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] {
                position: relative;
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] > :first-child {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
            }
        }
    `], SD = new Set, dm; function Wk(e, t, n = SD) { if (!(!e || n.has(e) || typeof document > "u")) { if (n.add(e), !t) { if (!dm) { let r = document.createElement("style"); if (r.setAttribute("type", "text/css"), r.setAttribute("data-framer-css", "true"), !document.head) { console.warn("not injecting CSS: the document is missing a <head> element"); return } if (document.head.appendChild(r), r.sheet) dm = r.sheet; else { console.warn("not injecting CSS: injected <style> element does not have a sheet", r); return } } t = dm } try { t.insertRule(e, t.cssRules.length) } catch { } } } var kD = ["[data-framer-component-type] { position: absolute; }"], CD = `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`, TD = `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`, ED = `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`, RD = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    text-decoration: var(--text-decoration);
    line-height: var(--line-height);
}`, PD = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration);
    --line-height: var(--framer-line-height);
}`, _D = `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration));
}`, FD = `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`, ID = `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`, LD = ['[data-framer-component-type="Text"] { cursor: inherit; }', "[data-framer-component-text-autosized] * { white-space: pre; }", CD, TD, ED, RD, PD, _D, FD, ID], MD = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`, OD = (() => [`[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`, `.${to} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`])(), DD = (() => `
.${to} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`)(), AD = (() => `
.${to}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${to}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`)(), VD = (() => `
.${to}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${to}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`)(), BD = (() => [MD, DD, ...OD, AD, VD])(), zD = [`
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`], $D = ['[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }', '[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }'], ND = ['[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }', '[data-framer-component-type="NativeScroll"] > * { position: relative; }', '[data-framer-component-type="NativeScroll"].direction-both { overflow-x: scroll; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: scroll; overflow-y: hidden; }', '[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }', '[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }', '[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }'], HD = ['[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }'], jD = ['[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }'], WD = ['[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }'], UD = ['[data-framer-cursor="pointer"] { cursor: pointer; }', '[data-framer-cursor="grab"] { cursor: grab; }', '[data-framer-cursor="grab"]:active { cursor: grabbing; }'], GD = ['[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }', "[data-framer-generated] * { pointer-events: unset }"], qD = [`[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`], XD = ['[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }', '[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }'], hm = "--framer-will-change-override", YD = "(background: -webkit-named-image(i))", KD = "(grid-template-rows: subgrid)", QD = e => e ? [`body { ${hm}: none; }`, `@supports ${YD} and (not ${KD}) { body { ${hm}: transform; } }`] : [`body { ${hm}: none; }`], ZD = e => e ? GD : [], JD = [".svgContainer svg { display: block; }"], Uk = e => [...QD(e), ...kD, ...LD, ...wD, ...xD, ...BD, ...zD, ...$D, ...ND, ...jD, ...HD, ...WD, ...UD, ...ZD(e), ...JD, ...qD, ...XD], eA = Uk(!1), tA = Uk(!0), vS = !1; function el() { if (vS) return; vS = !0; let e = le.current() === le.preview ? tA : eA; for (let t of e) Wk(t, void 0, void 0) } function Si(e) { return typeof e == "function" } function ef(e) { return typeof e == "boolean" } function ce(e) { return typeof e == "string" } function Ve(e) { return Number.isFinite(e) } function tl(e) { return Array.isArray(e) } function Te(e) { return e !== null && typeof e == "object" && !tl(e) } function Je(e) { return typeof e > "u" } function oe(e) { return e === null } function os(e) { return e == null } function ag(e) { return e instanceof Date && !isNaN(e.getTime()) } function nA(e) { return Te(e) || Si(e) } var yS = "optional"; function rA(e) { return !!e && yS in e && e[yS] === !0 } function iA(e) { try { switch (e.type) { case "string": case "collectionreference": case "multicollectionreference": case "color": case "date": case "link": case "boxshadow": case "padding": case "borderradius": return ce(e.defaultValue) ? e.defaultValue : void 0; case "boolean": return ef(e.defaultValue) ? e.defaultValue : void 0; case "enum": return Je(e.defaultValue) ? void 0 : e.options.includes(e.defaultValue) ? e.defaultValue : void 0; case "fusednumber": case "number": return Ve(e.defaultValue) ? e.defaultValue : void 0; case "transition": return Te(e.defaultValue) ? e.defaultValue : void 0; case "border": return Te(e.defaultValue) ? e.defaultValue : void 0; case "font": return Te(e.defaultValue) ? e.defaultValue : void 0; case "object": { let t = Te(e.defaultValue) ? e.defaultValue : {}; return Te(e.controls) && Gk(t, e.controls), t } case "array": return tl(e.defaultValue) ? e.defaultValue : void 0; case "file": case "image": case "richtext": case "pagescope": case "eventhandler": case "segmentedenum": case "responsiveimage": case "componentinstance": case "scrollsectionref": case "customcursor": case "cursor": return; default: return } } catch { return } } function Gk(e, t) { for (let n in t) { let r = t[n]; if (!r) continue; let i = e[n]; if (!Je(i) || rA(r)) continue; let o = iA(r); Je(o) || (e[n] = o) } } function oA(e) { if (Te(e.defaultProps)) return e.defaultProps; let t = {}; return e.defaultProps = t, t } function sA(e, t) { if (!nA(e)) return; let n = oA(e); Gk(n, t) } function UH(e, t) { Object.assign(e, { propertyControls: t }), sA(e, t) } function aA(e) { return e.propertyControls } var et = e => e; function lA(e) { let t = Object.create(Object.prototype); return n => (t[n] === void 0 && (t[n] = e(n)), t[n]) } var cA = /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/, uA = lA(e => cA.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91), bS = e => () => { za(e) }, fA = () => () => { }, dA = { useImageSource(e) { return e.src ?? "" }, useImageElement(e, t, n) { let r = new Image; return r.src = ut.useImageSource(e, t, n), e.srcSet && (r.srcset = e.srcSet), r }, canRenderOptimizedCanvasImage() { return !1 } }, hA = !1, pA = { get(e, t, n) { return Reflect.has(e, t) ? Reflect.get(e, t, n) : ["getLogger"].includes(String(t)) ? fA() : bS(hA ? `${String(t)} is not available in this version of Framer.` : `${String(t)} is only available inside of Framer. https://www.framer.com/`) } }, ut = new Proxy(dA, pA); function mA(e, t, n = 1) { let { width: r, height: i } = t, o = e.pixelWidth ?? e.intrinsicWidth ?? 0, s = e.pixelHeight ?? e.intrinsicHeight ?? 0; if (r < 1 || i < 1 || o < 1 || s < 1) return; r *= n, i *= n; let a = r / i, l = o / s; switch (e.fit) { case "fill": return l > a ? s / i : o / r; case "fit": case "stretch": return Math.max(o / r, s / i) } } function xS(e, t) { return t && Math.max(1, e) > t ? "pixelated" : "auto" } var wS = { position: "absolute", borderRadius: "inherit", top: 0, right: 0, bottom: 0, left: 0 }, gA = { backgroundRepeat: "repeat", backgroundPosition: "left top", backgroundSize: "126px auto", backgroundImage: "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTI2IiBoZWlnaHQ9IjEyNiI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0xMjYgMHYyMS41ODRMMjEuNTg0IDEyNkgwdi0xNy41ODVMMTA4LjQxNSAwSDEyNlptMCAxMDguNDE0VjEyNmgtMTcuNTg2TDEyNiAxMDguNDE0Wm0wLTg0djM5LjE3MUw2My41ODUgMTI2SDI0LjQxNEwxMjYgMjQuNDE0Wm0wIDQydjM5LjE3TDEwNS41ODQgMTI2aC0zOS4xN0wxMjYgNjYuNDE0Wk0xMDUuNTg2IDAgMCAxMDUuNTg2VjY2LjQxNUw2Ni40MTUgMGgzOS4xNzFabS00MiAwTDAgNjMuNTg2VjI0LjQxNUwyNC40MTUgMGgzOS4xNzFabS00MiAwTDAgMjEuNTg2VjBoMjEuNTg2WiIvPjwvZGVmcz48dXNlIHhsaW5rOmhyZWY9IiNhIiBmaWxsPSIjODg4IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)", opacity: .2 }; function vA(e) { switch (e) { case "fit": return "contain"; case "stretch": return "fill"; default: return "cover" } } function qk(e, t) { let n = e ?? "center", r = t ?? "center"; return n === "center" && r === "center" ? "center" : n + " " + r } function yA(e, t) { if (!t) return "auto"; let n = le.current() === le.canvas ? ft.devicePixelRatio : 1, r = mA(e, t, n); return le.current() === le.canvas ? xS(1, r) : xS(Vu.zoom, r) } function lg(e, t) { return { display: "block", width: "100%", height: "100%", borderRadius: "inherit", objectPosition: qk(e.positionX, e.positionY), objectFit: vA(e.fit), imageRendering: yA(e, t) } } function bA({ image: e, containerSize: t, nodeId: n, alt: r }) { let i = ut.useImageSource(e, t, n), o = lg(e, t), s = x.useRef(null); return k("img", { ref: s, decoding: "async", loading: e.loading, sizes: e.sizes, srcSet: e.srcSet, src: i, alt: r ?? e.alt, style: o }) } function xA({ image: e, containerSize: t, nodeId: n }) { let r = x.useRef(null), i = ut.useImageElement(e, t, n), o = lg(e, t); return x.useLayoutEffect(() => { let s = r.current; if (s !== null) return s.appendChild(i), () => { s.removeChild(i) } }, [i]), Object.assign(i.style, o), k("div", { ref: r, style: { display: "contents", borderRadius: "inherit" } }) } function wA({ nodeId: e, image: t, containerSize: n }) { let r = x.useRef(null), i = ut.useImageSource(t, n, e); return x.useLayoutEffect(() => { let o = r.current; if (o === null) return; let s = lg(t, n); ut.renderOptimizedCanvasImage(o, i, s, e) }, [e, t, i, n]), k("div", { ref: r, style: { display: "contents", borderRadius: "inherit" } }) } function Xk({ layoutId: e, image: t, ...n }) { e && (e = e + "-background"); let r = { ...wS, ...gA }, i = null; if (ce(t.src)) if (t.fit === "tile" && t.pixelWidth && t.pixelHeight) { let o = Ve(t.backgroundSize) ? t.backgroundSize : 1, s = { width: Math.round(o * t.pixelWidth), height: Math.round(o * t.pixelHeight) }, a = ut.useImageSource(t, s); r.backgroundImage = `url(${a})`, r.backgroundRepeat = "repeat", r.backgroundPosition = qk(t.positionX, t.positionY), r.opacity = void 0, r.border = 0, r.backgroundSize = `${(o * (t.pixelWidth / 2)).toFixed(2)}px auto`, i = null } else le.current() !== le.canvas ? i = k(bA, { image: t, ...n }) : ut.canRenderOptimizedCanvasImage(ut.useImageSource(t)) ? i = k(wA, { image: t, ...n }) : i = k(xA, { image: t, ...n }); return k(vn.div, { layoutId: e, style: i ? wS : r, "data-framer-background-image-wrapper": !0, children: i }) } var SA = "src", Ki = { isImageObject: function (e) { return !e || typeof e == "string" ? !1 : SA in e } }; function kA(e, t) { let { _forwardedOverrideId: n, _forwardedOverrides: r, id: i } = t, o = n ?? i, s = r && o ? r[o] : void 0; return s && typeof s == "string" && (e = { ...e, src: s }), e } function CA(e) { let { background: t, image: n } = e; if (n !== void 0 && t && !Ki.isImageObject(t)) return; let r = null; if (ce(n) ? r = { alt: "", src: n } : r = it.get(t, null), !!Ki.isImageObject(r)) return kA(r, e) } function TA(e, t, n = !0) { let { borderWidth: r, borderStyle: i, borderColor: o } = e; if (!r) return; let s, a, l, c; if (typeof r == "number" ? s = a = l = c = r : (s = r.top || 0, a = r.bottom || 0, l = r.left || 0, c = r.right || 0), !(s === 0 && a === 0 && l === 0 && c === 0)) { if (n && s === a && s === l && s === c) { t.border = `${s}px ${i} ${o}`; return } t.borderStyle = e.borderStyle, t.borderColor = e.borderColor, t.borderTopWidth = `${s}px`, t.borderBottomWidth = `${a}px`, t.borderLeftWidth = `${l}px`, t.borderRightWidth = `${c}px` } } function EA(e) { let t = e.layoutId ? `${e.layoutId}-border` : void 0; if (!e.borderWidth) return null; let n = { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, borderRadius: "inherit", pointerEvents: "none" }; return e.border ? (n.border = e.border, k(vn.div, { style: n })) : (TA(e, n, !1), k(vn.div, { "data-frame-border": !0, style: n, layoutId: t })) } function nl(e) { return e && e !== "search" && e !== "slot" && e !== "template" ? vn[e] : vn.div } var RA = Jn(Jm(), 1), Rn = typeof Ne < "u" ? Ne : void 0, ki = () => typeof document == "object"; var PA = () => Rn && /Chrome/.test(Rn.userAgent) && /Google Inc/.test(Rn.vendor) && !LA(), _A = () => Rn && /Safari/.test(Rn.userAgent) && /Apple Computer/.test(Rn.vendor), FA = () => Rn && /Firefox\/\d+\.\d+$/.test(Rn.userAgent), IA = () => Rn && /FramerX/.test(Rn.userAgent), LA = () => Rn && /Edg\//.test(Rn.userAgent); var MA = () => RA.default.env.NODE_ENV === "test"; var OA = PA(); function Yk(e) { let t = {}; return !OA || le.current() !== le.canvas || ((e === !0 || e === "x") && (t["data-framer-layout-hint-center-x"] = !0), (e === !0 || e === "y") && (t["data-framer-layout-hint-center-y"] = !0)), t } function cg(e) { return e.replace(/^id_/, "").replace(/\\/g, "") } function DA(e, t) { if (!t && (t = e.children, !t)) return { props: e, children: t }; let n = e._forwardedOverrides; return n ? (t = x.Children.map(t, r => x.isValidElement(r) ? x.cloneElement(r, { _forwardedOverrides: n }) : r), { props: e, children: t }) : { props: e, children: t } } function tf(e) { return (t, n) => e === !0 ? `translate(-50%, -50%) ${n}` : e === "x" ? `translateX(-50%) ${n}` : e === "y" ? `translateY(-50%) ${n}` : n || "none" } function rl(e, { specificLayoutId: t, postfix: n } = {}) { let { name: r, layoutIdKey: i, duplicatedFrom: o, __fromCodeComponentNode: s = !1, drag: a } = e, { getLayoutId: l, enabled: c } = V(is); return ae(() => { if (!c) return e.layoutId; let u = t || e.layoutId; if (!u && (a || !i || s)) return; let f = u || l({ id: i, name: r, duplicatedFrom: o }); if (f) return n ? `${f}-${n}` : f }, [c]) } var Kk = typeof document < "u" ? tt : z, us = x.createContext(!1); function nf() { let [e, t] = x.useState(0); return x.useCallback(() => t(n => n + 1), []) } var AA = (() => YL().ResizeObserver)(); var VA = class { constructor() { T(this, "sharedResizeObserver"), T(this, "callbacks", new WeakMap); let e = ft.ResizeObserver ?? AA; this.sharedResizeObserver = new e(this.updateResizedElements.bind(this)) } updateResizedElements(e) { for (let t of e) { let n = this.callbacks.get(t.target); n && n(t.contentRect) } } observeElementWithCallback(e, t) { this.sharedResizeObserver.observe(e), this.callbacks.set(e, t) } unobserve(e) { this.sharedResizeObserver.unobserve(e), this.callbacks.delete(e) } }, bu = (() => ki() ? new VA : void 0)(); function BA(e) { let t = nf(); z(() => { let n = e?.current; if (n) return bu?.observeElementWithCallback(e.current, t), () => { bu?.unobserve(n) } }, [e, t]) } var zA = "data-framer-size-compatibility-wrapper"; function $A(e) { return [...e.firstElementChild && e.firstElementChild.hasAttribute(zA) ? e.firstElementChild.children : e.children].filter(Qk).map(Zk) } function Qk(e) { return e instanceof HTMLBaseElement || e instanceof HTMLHeadElement || e instanceof HTMLLinkElement || e instanceof HTMLMetaElement || e instanceof HTMLScriptElement || e instanceof HTMLStyleElement || e instanceof HTMLTitleElement ? !1 : e instanceof HTMLElement || e instanceof SVGElement } function Zk(e) { if (!(e instanceof HTMLElement) || e.children.length === 0 || e.style.display !== "contents") return e; let t = [...e.children].find(Qk); return t ? Zk(t) : e } function rf(e, t, n = () => [], r = {}) { let { id: i, visible: o, _needsMeasure: s } = e, { skipHook: a = !1 } = r, l = !!V(us), c = le.current() === le.canvas; Kk(() => { !c || l || a || t.current && i && o && s && ut.queueMeasureRequest(cg(i), t.current, n(t.current)) }) } function NA(e) { let t = e.closest("[data-framer-component-container]"); t && ut.queueMeasureRequest(cg(t.id), t, $A(t)) } var no = Object.keys; function Na(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function SS(e) { return Na(e, "equals") ? typeof e.equals == "function" : !1 } function ug(e, t) { return e === t ? !0 : e !== e && t !== t } function HA(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!ug(e[r], t[r])) return !1; return !0 } function jA(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!of(e[r], t[r], !0)) return !1; return !0 } function WA(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!ug(r, t.get(n))) return !1; return !0 } function UA(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!of(r, t.get(n), !0)) return !1; return !0 } function GA(e, t) { if (e.size !== t.size) return !1; for (let n of e.keys()) if (!t.has(n)) return !1; return !0 } function qA(e, t) { let n = no(e); if (n.length !== no(t).length) return !1; for (let r of n) { if (!Na(t, r)) return !1; if (!(r === "_owner" && Na(e, "$$typeof") && e.$$typeof) && !ug(e[r], t[r])) return !1 } return !0 } function XA(e, t) { let n = no(e); if (n.length !== no(t).length) return !1; for (let r of n) { if (!Na(t, r)) return !1; if (!(r === "_owner" && Na(e, "$$typeof") && e.$$typeof) && !of(e[r], t[r], !0)) return !1 } return !0 } function of(e, t, n) { if (e === t) return !0; if (!e || !t) return e !== e && t !== t; let r = typeof e; if (r !== typeof t || r !== "object") return !1; let o = Array.isArray(e), s = Array.isArray(t); if (o && s) return n ? jA(e, t) : HA(e, t); if (o !== s) return !1; let a = e instanceof Map, l = t instanceof Map; if (a && l) return n ? UA(e, t) : WA(e, t); if (a !== l) return !1; let c = e instanceof Set, u = t instanceof Set; if (c && u) return GA(e, t); if (c !== u) return !1; let f = e instanceof Date, d = t instanceof Date; if (f && d) return e.getTime() === t.getTime(); if (f !== d) return !1; let p = e instanceof RegExp, y = t instanceof RegExp; return p && y ? e.toString() === t.toString() : p !== y ? !1 : SS(e) && SS(t) ? e.equals(t) : n ? XA(e, t) : qA(e, t) } function qe(e, t, n = !0) { try { return of(e, t, n) } catch (r) { if (r instanceof Error && /stack|recursion/iu.exec(r.message)) return console.warn("Warning: isEqual does not handle circular references.", r.name, r.message), !1; throw r } } var Jk = "0.000001px", pm = (() => ` translateZ(${Jk})`)(), eC = (() => IA() || _A() || MA())(); function YA(e) { e.willChange = "transform"; let t = le.current() === le.canvas; eC && t && (e.translateZ = Jk) } function fg(e) { e.willChange = "transform", KA(e, !0) } function KA(e, t) { let n = le.current() === le.canvas; if (!eC || !n) return; let r = ce(e.transform) && e.transform || ""; t ? r.includes(pm) || (e.transform = r + pm) : e.transform = r.replace(pm, "") } function tC(e, t, n, r = !0) { if (!e) return; let i = et(e.style), o = n || i[t], s = () => { i[t] = o }; i[t] = null, r ? Promise.resolve().then(s) : setTimeout(s, 0) } var Ru = (() => { class e extends Re { constructor() { super(...arguments), T(this, "layerElement", null), T(this, "setLayerElement", n => { this.layerElement = n }) } static applyWillChange(n, r, i) { n.willChangeTransform && (i ? YA(r) : fg(r)) } shouldComponentUpdate(n, r) { return n._needsMeasure || this.state !== r || !qe(this.props, n) } componentDidUpdate(n) { et(this.props).clip && et(this.props).radius === 0 && et(n).radius !== 0 && tC(this.layerElement, "overflow", "hidden", !1) } } return T(e, "defaultProps", {}), e })(); function QA(e, t) { if (e.size < t) return; let r = Math.round(Math.random()); for (let i of e.keys()) (++r & 1) !== 1 && e.delete(i) } function ZA(e, t, n, r) { let i = t.get(n); if (i) return i; QA(t, e); let o = r(n); return t.set(n, o), o } var nC = e => { let t = 0, n, r; if (e.length === 0) return t; for (n = 0; n < e.length; n++)r = e.charCodeAt(n), t = (t << 5) - t + r, t |= 0; return t }, dg = { hueRotate: (e, t) => G.toHslString(G.hueRotate(G(e), t)), setAlpha: (e, t) => G.toRgbString(G.alpha(G(e), t)), getAlpha: e => { let t = sg(e); return t ? t.a : 1 }, multiplyAlpha: (e, t) => G.toRgbString(G.multiplyAlpha(G(e), t)), toHex: e => G.toHexString(G(e)).toUpperCase(), toRgb: e => G.toRgb(G(e)), toRgbString: e => G.toRgbString(G(e)), toHSV: e => G.toHsv(G(e)), toHSL: e => G.toHsl(G(e)), toHslString: e => G.toHslString(G(e)), toHsvString: e => G.toHsvString(G(e)), hsvToHSLString: e => G.toHslString(G(vu(e.h, e.s, e.v, e.a))), hsvToHex: e => G.toHexString(G(vu(e.h, e.s, e.v, e.a))).toUpperCase(), hsvToRgbString: e => G.toRgbString(G(vu(e.h, e.s, e.v, e.a))), hsvToString: e => vu(e.h, e.s, e.v), rgbaToString: e => G.toRgbString(G(e)), rgbToHexString: e => G.toHexString(G(e)), hslToString: e => G.toHslString(G(e)), hslToRgbString: e => G.toRgbString(G(e)), toColorPickerSquare: e => G.toRgbString(G({ h: e, s: 1, l: .5, a: 1 })), isValid: e => G(e).isValid !== !1, equals: (e, t) => (typeof e == "string" && (e = G(e)), typeof t == "string" && (t = G(t)), G.equal(e, t)), toHexOrRgbaString: e => { let t = G(e); return t.a !== 1 ? G.toRgbString(t) : G.toHexString(t) } }, JA = /var\(.+\)/, eV = new Map; function tV(e, t) { let n = [e, t]; return JA.test(e) ? e : ZA(1e3, eV, n, () => dg.multiplyAlpha(e, t)) } function il(e, t = 1) { let n; return "stops" in e ? n = e.stops : n = [{ value: e.start, position: 0 }, { value: e.end, position: 1 }], t === 1 ? n : n.map(r => ({ ...r, value: tV(r.value, t) })) } function rC(e, t) { let n = 0; return il(e, t).forEach(r => { n ^= nC(r.value) ^ r.position }), n } var nV = ["stops"]; function iC(e) { return e && nV.every(t => t in e) } var rV = ["start", "end"]; function oC(e) { return e && rV.every(t => t in e) } var iV = ["angle", "alpha"], Ha = { isLinearGradient: e => e && iV.every(t => t in e) && (oC(e) || iC(e)), hash: e => e.angle ^ rC(e, e.alpha), toCSS: (e, t) => { let n = il(e, e.alpha), r = t !== void 0 ? t : e.angle, i = n.map(o => `${o.value} ${o.position * 100}%`); return `linear-gradient(${r}deg, ${i.join(", ")})` } }, oV = ["widthFactor", "heightFactor", "centerAnchorX", "centerAnchorY", "alpha"], ja = { isRadialGradient: e => e && oV.every(t => t in e) && (oC(e) || iC(e)), hash: e => e.centerAnchorX ^ e.centerAnchorY ^ e.widthFactor ^ e.heightFactor ^ rC(e, e.alpha), toCSS: e => { let { alpha: t, widthFactor: n, heightFactor: r, centerAnchorX: i, centerAnchorY: o } = e, s = il(e, t), a = s.map((l, c) => { let u = s[c + 1], f = l.position === 1 && u?.position === 1 ? l.position - 1e-4 : l.position; return `${l.value} ${f * 100}%` }); return `radial-gradient(${n * 100}% ${r * 100}% at ${i * 100}% ${o * 100}%, ${a.join(", ")})` } }; function sV({ background: e, backgroundColor: t }, n) { t ? typeof t == "string" || hS(t) ? n.backgroundColor = t : G.isColorObject(e) && (n.backgroundColor = e.initialValue || G.toRgbString(e)) : e && (e = it.get(e, null), typeof e == "string" || hS(e) ? n.background = e : Ha.isLinearGradient(e) ? n.background = Ha.toCSS(e) : ja.isRadialGradient(e) ? n.background = ja.toCSS(e) : G.isColorObject(e) && (n.backgroundColor = e.initialValue || G.toRgbString(e))) } function ye(e, t, n, r) { if (r === void 0 && (r = t), e[t] !== void 0) { n[r] = e[t]; return } } function aV(e) { return e ? e.left !== void 0 && e.right !== void 0 : !1 } function lV(e) { return e ? e.top !== void 0 && e.bottom !== void 0 : !1 } function cV(e) { if (!e) return {}; let t = {}; return e.preserve3d === !0 ? t.transformStyle = "preserve-3d" : e.preserve3d === !1 && (t.transformStyle = "flat"), e.backfaceVisible === !0 ? t.backfaceVisibility = "visible" : e.backfaceVisible === !1 && (t.backfaceVisibility = "hidden"), t.backfaceVisibility && (t.WebkitBackfaceVisibility = t.backfaceVisibility), e.perspective !== void 0 && (t.perspective = t.WebkitPerspective = e.perspective), e.__fromCanvasComponent || (e.center === !0 ? (t.left = "50%", t.top = "50%") : e.center === "x" ? t.left = "50%" : e.center === "y" && (t.top = "50%")), ye(e, "size", t), ye(e, "width", t), ye(e, "height", t), ye(e, "minWidth", t), ye(e, "minHeight", t), ye(e, "top", t), ye(e, "right", t), ye(e, "bottom", t), ye(e, "left", t), ye(e, "position", t), ye(e, "overflow", t), ye(e, "opacity", t), (!e._border || !e._border.borderWidth) && ye(e, "border", t), ye(e, "borderRadius", t), ye(e, "radius", t, "borderRadius"), ye(e, "color", t), ye(e, "shadow", t, "boxShadow"), ye(e, "x", t), ye(e, "y", t), ye(e, "z", t), ye(e, "rotate", t), ye(e, "rotateX", t), ye(e, "rotateY", t), ye(e, "rotateZ", t), ye(e, "scale", t), ye(e, "scaleX", t), ye(e, "scaleY", t), ye(e, "skew", t), ye(e, "skewX", t), ye(e, "skewY", t), ye(e, "originX", t), ye(e, "originY", t), ye(e, "originZ", t), sV(e, t), t } function uV(e) { for (let t in e) if (t === "drag" || t.startsWith("while") || typeof et(e)[t] == "function" && t.startsWith("on") && !t.includes("Animation")) return !0; return !1 } var kS = ["onClick", "onDoubleClick", "onMouse", "onMouseDown", "onMouseUp", "onTapDown", "onTap", "onTapUp", "onPointer", "onPointerDown", "onPointerUp", "onTouch", "onTouchDown", "onTouchUp"], fV = (() => new Set([...kS, ...kS.map(e => `${e}Capture`)]))(); function dV(e) { if (e.drag) return "grab"; for (let t in e) if (fV.has(t)) return "pointer" } var mm = "overflow"; function hV(e) { return CS(e) ? !0 : e.style ? !!CS(e.style) : !1 } function CS(e) { return mm in e && (e[mm] === "scroll" || e[mm] === "auto") } function sC(e) { let { left: t, top: n, bottom: r, right: i, width: o, height: s, center: a, _constraints: l, size: c, widthType: u, heightType: f, positionFixed: d, positionAbsolute: p } = e, y = Tt(e.minWidth), g = Tt(e.minHeight), b = Tt(e.maxWidth), h = Tt(e.maxHeight); return { top: Tt(n), left: Tt(t), bottom: Tt(r), right: Tt(i), width: Tt(o), height: Tt(s), size: Tt(c), center: a, _constraints: l, widthType: u, heightType: f, positionFixed: d, positionAbsolute: p, minWidth: y, minHeight: g, maxWidth: b, maxHeight: h } } var TS = { x: 0, y: 0, width: 200, height: 200 }; function pV(e) { x.useInsertionEffect(() => { el() }, []); let t = !!V(us), { style: n, _initialStyle: r, __fromCanvasComponent: i, size: o } = e, s = sC(e), a = tD(s), l = { display: "block", flex: n?.flex ?? "0 0 auto", userSelect: le.current() !== le.preview ? "none" : void 0 }; e.__fromCanvasComponent || (l.backgroundColor = e.background === void 0 ? "rgba(0, 170, 255, 0.3)" : void 0); let c = !uV(e) && !e.__fromCanvasComponent && !hV(e), u = e.style ? !("pointerEvents" in e.style) : !0; c && u && (l.pointerEvents = "none"); let d = x.Children.count(e.children) > 0 && x.Children.toArray(e.children).every(h => typeof h == "string" || typeof h == "number") && { display: "flex", alignItems: "center", justifyContent: "center", textAlign: "center" }, p = cV(e); o === void 0 && !i && (aV(p) || (l.width = TS.width), lV(p) || (l.height = TS.height)), s.minWidth !== void 0 && (l.minWidth = s.minWidth), s.minHeight !== void 0 && (l.minHeight = s.minHeight); let y = {}; Za(s) && a && !jk(e) && (y = { left: a.x, top: a.y, width: a.width, height: a.height, right: void 0, bottom: void 0 }), Object.assign(l, d, r, p, y, n), Object.assign(l, { overflowX: l.overflowX ?? l.overflow, overflowY: l.overflowY ?? l.overflow, overflow: void 0 }), Ru.applyWillChange(e, l, !0); let g = l; l.transform || (g = { x: 0, y: 0, ...l }); let b = le.current() === le.canvas; return e.positionSticky ? (!b || t) && (g.position = "sticky", g.willChange = "transform", g.zIndex = 1, g.top = e.positionStickyTop, g.right = e.positionStickyRight, g.bottom = e.positionStickyBottom, g.left = e.positionStickyLeft) : b && (e.positionFixed || e.positionAbsolute) && (g.position = "absolute"), "rotate" in g && g.rotate === void 0 && delete g.rotate, [g, a] } var mV = new Set(["width", "height", "opacity", "overflow", "radius", "background", "color", "x", "y", "z", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "skew", "skewX", "skewY", "originX", "originY", "originZ"]); function gV(e) { let t = {}; for (let n in e) (po(n) || uA(n)) && !mV.has(n) ? t[n] = et(e)[n] : (n === "positionTransition" || n === "layoutTransition") && (t.layout = !0, typeof et(e)[n] != "boolean" && !e.transition && (t.transition = et(e)[n])); return t } function vV(e) { return "data-framer-name" in e } var yV = Oe(function (t, n) { let { name: r, center: i, border: o, _border: s, __portal: a } = t, { props: l, children: c } = DA(t), u = gV(l), f = rl(t), d = dV(t), p = D(null), y = n ?? p, g = { "data-framer-component-type": t.componentType ?? "Frame", "data-framer-cursor": d, "data-framer-highlight": d === "pointer" ? !0 : void 0, "data-layoutid": f, "data-framer-offset-parent-id": et(t)["data-framer-offset-parent-id"] }; !vV(t) && r && (et(g)["data-framer-name"] = r); let [b, h] = pV(l), m = sC(l), v = jk(m); i && !(h && !v && Za(m)) ? (u.transformTemplate || (u.transformTemplate = tf(i)), Object.assign(g, Yk(i))) : u.transformTemplate || (u.transformTemplate = void 0), rf(t, y); let w = CA(t), C = !!V(us), S = bV(l, m, h, C), R = eD(ue(He, { children: [w ? k(Xk, { alt: t.alt ?? "", image: w, containerSize: h ?? void 0, nodeId: t.id && cg(t.id), layoutId: f }) : null, c, k(EA, { ...s, border: o, layoutId: f })] }), S), E = nl(t.as), { size: L, radius: F, shadow: N } = b; return L !== void 0 && (delete b.size, b.height === void 0 && (b.height = L), b.width === void 0 && (b.width = L)), F !== void 0 && (delete b.radius, b.borderRadius = F), N !== void 0 && (delete b.shadow, b.boxShadow = N), ue(E, { ...g, ...u, layoutId: f, style: b, ref: y, children: [R, a] }) }), Pu = Oe(function (t, n) { let { visible: r = !0 } = t; return r ? k(yV, { ...t, ref: n }) : null }); function bV(e, t, n, r) { if (r) return n ? { width: n.width, height: n.height } : 1; let { _usesDOMRect: i } = e, { widthType: o = 0, heightType: s = 0, width: a, height: l } = t; return n && !i ? n : o === 0 && s === 0 && typeof a == "number" && typeof l == "number" ? { width: a, height: l } : i || e.positionFixed || e.positionAbsolute ? 2 : 0 } var hg = "__LAYOUT_TREE_ROOT", aC = x.createContext({ schedulePromoteTree: () => { }, scheduleProjectionDidUpdate: () => { }, initLead: () => { } }), xV = class extends Re { constructor() { super(...arguments), T(this, "shouldAnimate", !1), T(this, "transition"), T(this, "lead"), T(this, "follow"), T(this, "scheduledPromotion", !1), T(this, "scheduledDidUpdate", !1), T(this, "scheduleProjectionDidUpdate", () => { this.scheduledDidUpdate = !0 }), T(this, "schedulePromoteTree", (e, t, n) => { this.follow = this.lead, this.shouldAnimate = n, this.lead = e, this.transition = t, this.scheduledPromotion = !0 }), T(this, "initLead", (e, t) => { this.follow = this.lead, this.lead = e, this.follow && t && (this.follow.layoutMaybeMutated = !0) }), T(this, "sharedLayoutContext", { schedulePromoteTree: this.schedulePromoteTree, scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate, initLead: this.initLead }) } getSnapshotBeforeUpdate() { var e; if (!this.scheduledPromotion || !this.lead || !this.follow) return null; let t = !!((e = this.lead) != null && e.layoutMaybeMutated) && !this.shouldAnimate; return this.lead.projectionNodes.forEach(n => { var r; n?.promote({ needsReset: t, transition: this.shouldAnimate ? this.transition : void 0, preserveFollowOpacity: n.options.layoutId === hg && !((r = this.follow) != null && r.isExiting) }) }), this.shouldAnimate ? this.follow.layoutMaybeMutated = !0 : this.scheduleProjectionDidUpdate(), this.lead.layoutMaybeMutated = !1, this.transition = void 0, this.scheduledPromotion = !1, null } componentDidUpdate() { var e, t; if (!this.lead) return null; this.scheduledDidUpdate && ((t = (e = this.lead.rootProjectionNode) == null ? void 0 : e.root) == null || t.didUpdate(), this.scheduledDidUpdate = !1) } render() { return k(aC.Provider, { value: this.sharedLayoutContext, children: this.props.children }) } }, wV = { width: "100%", height: "100%", backgroundColor: "none" }; function SV(e) { return k(vn.div, { layoutId: hg, style: wV, children: e.children }) } var kV = class { constructor(e) { T(this, "sharedIntersectionObserver"), T(this, "callbacks", new WeakMap), document && (this.sharedIntersectionObserver = new IntersectionObserver(this.resizeObserverCallback.bind(this), e)) } resizeObserverCallback(e, t) { for (let n of e) { let r = this.callbacks.get(n.target); r && r([n], t) } } observeElementWithCallback(e, t) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.observe(e), this.callbacks.set(e, t)) } unobserve(e) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.unobserve(e), this.callbacks.delete(e)) } get root() { var e; return (e = this.sharedIntersectionObserver) == null ? void 0 : e.root } }, CV = x.createContext(new Map); function TV(e, t, n) { if (typeof IntersectionObserver > "u") return; let r = Qt(() => `${n.rootMargin}`), i = x.useContext(CV), { enabled: o } = n; x.useEffect(() => { var s; let a = e.current; if (!o || !a) return; let l = i.get(r); if (!l || l.root !== ((s = n.root) == null ? void 0 : s.current)) { let { root: c, ...u } = n; l = new kV({ ...u, root: c?.current }), i.set(r, l) } return l.observeElementWithCallback(a, t), () => l?.unobserve(a) }, [o]) } var EV = new Array(100).fill(void 0).map((e, t) => t * .01), RV = x.createContext(null); function PV(e, t, n) { let r = x.useRef({ isInView: !1, hasAnimatedOnce: !1 }), { enabled: i, animateOnce: o, threshold: s, rootMargin: a = "0px 0px 0px 0px" } = n, l = x.useCallback(([c]) => { if (!c) return; let { isInView: u, hasAnimatedOnce: f } = r.current, d = FV(c, s?.y ?? 0); if (d && !u) { if (o && f) return; r.current.hasAnimatedOnce = !0, r.current.isInView = !0, t(!0); return } if (!d && u) { if (r.current.isInView = !1, o) return; t(!1); return } }, [o, s?.y, t]); TV(e, l, { threshold: EV, rootMargin: a, enabled: i ?? !0 }) } function _V(e, t) { return t.height === 0 ? 0 : e.height / Math.min(t.height, ft.innerHeight) } function FV({ boundingClientRect: e, intersectionRect: t, isIntersecting: n }, r) { return e.height === 0 ? n : n && _V(t, e) >= r } var xj = Jn(Qu(), 1); var Sj = Jn(Qu(), 1); var ES = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Ar = Symbol("private"), gm = (() => { function e(t = {}, n = !1, r = !0) { let i = { [Ar]: { makeAnimatables: n, observeAnimatables: r, observers: new Ok, reset() { for (let s in o) if (ES(o, s)) { let a = ES(t, s) ? et(t)[s] : void 0; a !== void 0 ? o[s] = a : delete o[s] } }, transactions: new Set } }, o = new Proxy(i, LV); return Object.assign(o, t), o } return e.resetObject = t => t[Ar].reset(), e.addObserver = (t, n) => t[Ar].observers.add(n), e })(), IV = class { constructor() { T(this, "set", (e, t, n, r) => { if (t === Ar) return !1; let i = e[Ar], o, s; if (Nn(n) ? (o = n, s = o.get()) : s = n, i.makeAnimatables && typeof n != "function" && typeof n != "object" && !o && (o = it(n)), i.observeAnimatables && o) { let u = i.transactions; o.onUpdate({ update: (f, d) => { d && u.add(d), i.observers.notify({ value: r }, d) }, finish: f => { u.delete(f) && i.observers.finishTransaction(f) } }) } let a = !1, l = !0, c = et(e)[t]; if (c !== void 0) { Nn(c) ? (l = c.get() !== s, c.set(s)) : (l = c !== s, et(e)[t] = s); let u = s !== null && typeof s == "object"; (Array.isArray(s) || u) && (l = !0), a = !0 } else o && (n = o), a = Reflect.set(e, t, n); return l && i.observers.notify({ value: r }), a }), T(this, "get", (e, t, n) => { if (t === Ar) return et(e)[t]; let r = Reflect.get(e, t, n); return typeof r == "function" ? r.bind(n) : r }) } deleteProperty(e, t) { let n = Reflect.deleteProperty(e, t); return e[Ar].observers.notify({ value: e }), n } ownKeys(e) { let t = Reflect.ownKeys(e), n = t.indexOf(Ar); return n !== -1 && t.splice(n, 1), t } getOwnPropertyDescriptor(e, t) { if (t !== Ar) return Reflect.getOwnPropertyDescriptor(e, t) } }, LV = new IV; var MV = "opacity"; function OV(e) { return MV in e } function DV(e, t) { if (!OV(e)) return; let n = it.getNumber(e.opacity); n !== 1 && (t.opacity = n) } function AV(e) { let t = []; if (e && e.length) { let n = e.map(r => `drop-shadow(${r.x}px ${r.y}px ${r.blur}px ${r.color})`); t.push(...n) } return t } function lC(e, t) { if (!e.shadows || e.shadows.length === 0) return; let n = e.shadows.map(r => `${r.x}px ${r.y}px ${r.blur}px ${r.color}`).join(", "); n && (t.textShadow = n) } function VV(e, t) { let n = []; J(e.brightness) && n.push(`brightness(${e.brightness / 100})`), J(e.contrast) && n.push(`contrast(${e.contrast / 100})`), J(e.grayscale) && n.push(`grayscale(${e.grayscale / 100})`), J(e.hueRotate) && n.push(`hue-rotate(${e.hueRotate}deg)`), J(e.invert) && n.push(`invert(${e.invert / 100})`), J(e.saturate) && n.push(`saturate(${e.saturate / 100})`), J(e.sepia) && n.push(`sepia(${e.sepia / 100})`), J(e.blur) && n.push(`blur(${e.blur}px)`), e.dropShadows && n.push(...AV(e.dropShadows)), n.length !== 0 && (t.filter = t.WebkitFilter = n.join(" ")) } function BV(e, t) { J(e.backgroundBlur) && (t.backdropFilter = t.WebkitBackdropFilter = `blur(${e.backgroundBlur}px)`) } function pg(e, t) { BV(e, t), VV(e, t) } var zV = class extends Re { constructor() { super(...arguments), T(this, "layoutMaybeMutated"), T(this, "projectionNodes", new Map), T(this, "rootProjectionNode"), T(this, "isExiting"), T(this, "shouldPreserveFollowOpacity", e => e.options.layoutId === hg && !this.props.isExiting), T(this, "switchLayoutGroupContext", { register: e => this.addChild(e), deregister: e => this.removeChild(e), transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0, shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity }) } componentDidMount() { this.props.isLead && this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout) } shouldComponentUpdate(e) { let { isLead: t, isExiting: n, isOverlayed: r, animatesLayout: i, transition: o, sharedLayoutContext: s } = e; if (this.isExiting = n, t === void 0) return !0; let a = !this.props.isLead && !!t, l = this.props.isExiting && !n, c = a || l, u = !!this.props.isLead && !t, f = this.props.isOverlayed !== r; return (c || u) && this.projectionNodes.forEach(d => d?.willUpdate()), c ? s.schedulePromoteTree(this, o, !!i) : f && s.scheduleProjectionDidUpdate(), !!c && !!i } addChild(e) { let t = e.options.layoutId; t && (this.projectionNodes.set(t, e), this.setRootChild(e)) } setRootChild(e) { if (!this.rootProjectionNode) return this.rootProjectionNode = e; this.rootProjectionNode = this.rootProjectionNode.depth < e.depth ? this.rootProjectionNode : e } removeChild(e) { let t = e.options.layoutId; t && this.projectionNodes.delete(t) } render() { return k(Dl.Provider, { value: this.switchLayoutGroupContext, children: this.props.children }) } }, $V = e => { let t = x.useContext(aC); return k(zV, { ...e, sharedLayoutContext: t }) }, cC = x.createContext(!0); function Mj() { return V(cC) } function NV() { return new Map } function HV() { return Qt(NV) } var uC = ke({ register: () => { }, deregister: () => { } }), jV = ({ isCurrent: e, isOverlayed: t, children: n }) => { let r = HV(), i = se(a => { if (r.has(a)) { console.warn("NavigationTargetWrapper: already registered"); return } r.set(a, void 0) }, [r]), o = se(a => { let l = r.get(a); l?.(), r.delete(a) }, [r]), s = D({ register: i, deregister: o }).current; return z(() => (r.forEach((a, l) => { let c = l(e, t); r.set(l, Si(c) ? c : void 0) }), () => { r.forEach((a, l) => { a && (a(), r.set(l, void 0)) }) }), [e, t, r]), k(uC.Provider, { value: s, children: n }) }; function fC(e, t = []) { let { register: n, deregister: r } = V(uC); z(() => { if (e) return n(e), () => r(e) }, [n, r, ...t]) } var vm = x.memo(function ({ isLayeredContainer: t, isCurrent: n, isPrevious: r, isOverlayed: i = !1, visible: o, transitionProps: s, children: a, backdropColor: l, onTapBackdrop: c, backfaceVisible: u, exitBackfaceVisible: f, animation: d, exitAnimation: p, instant: y, initialProps: g, exitProps: b, position: h = { top: 0, right: 0, bottom: 0, left: 0 }, withMagicMotion: m, index: v, areMagicMotionLayersPresent: w, id: C, isInitial: S }) { let R = hb(), E = V(go), { persistLayoutIdCache: L } = V(is), F = D({ wasCurrent: void 0, wasPrevious: !1, wasBeingRemoved: !1, wasReset: !0, origins: RS({}, g, s) }), N = D(null), A = E !== null && !E.isPresent; n && F.current.wasCurrent === void 0 && L(), z(() => { if (t || !R) return; if (A) { F.current = { ...F.current, wasBeingRemoved: A }; return } let { wasPrevious: pe, wasCurrent: ie } = F.current, ht = n && !ie || !A && F.current.wasBeingRemoved && n, Fe = r && !pe, Lt = RS(F.current.origins, g, s), Se = F.current.wasReset; ht || Fe ? (R.stop(), R.start({ zIndex: v, ...Lt, ...s }), Se = !1) : Se === !1 && (R.stop(), R.set({ zIndex: v, ...Qi, opacity: 0 }), Se = !0), F.current = { wasCurrent: !!n, wasPrevious: !!r, wasBeingRemoved: !1, wasReset: Se, origins: Lt } }, [n, r, A]); let K = y ? { type: !1 } : "velocity" in d ? { ...d, velocity: 0 } : d, U = y ? { type: !1 } : p || d, H = { ...h }; (H.left === void 0 || H.right === void 0) && (H.width = "auto"), (H.top === void 0 || H.bottom === void 0) && (H.height = "auto"); let ee = (PS(s) || PS(g)) && (t || n || r) ? 1200 : void 0, te = { ...Qi, ...F.current.origins }, q = t ? { initial: { ...te, ...g }, animate: { ...te, ...s, transition: K }, exit: { ...te, ...b, transition: d } } : { animate: R, exit: { ...te, ...b, transition: U } }, ne = !(A || w === !1), be = !!n && ne; return ue(Pu, { "data-framer-component-type": "NavigationContainerWrapper", width: "100%", height: "100%", style: { position: "absolute", transformStyle: "flat", backgroundColor: "transparent", overflow: "hidden", zIndex: t || A || n && m ? v : void 0, pointerEvents: void 0, visibility: o ? "visible" : "hidden", perspective: ee }, children: [t && k(Pu, { width: "100%", height: "100%", "data-framer-component-type": "NavigationContainerBackdrop", transition: d, initial: { opacity: y && o ? 1 : 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, backgroundColor: l || "transparent", onTap: A ? void 0 : c }), k(Pu, { ...H, ...q, transition: { default: K, originX: { type: !1 }, originY: { type: !1 }, originZ: { type: !1 } }, backgroundColor: "transparent", backfaceVisible: A ? f : u, "data-framer-component-type": "NavigationContainer", "data-framer-is-current-navigation-target": !!n, style: { pointerEvents: void 0, opacity: n && S || t || n && m ? 1 : 0 }, "data-is-present": ne ? void 0 : !1, ref: N, children: k(RV.Provider, { value: N, children: k(cC.Provider, { value: be, children: k(jV, { isCurrent: be, isOverlayed: i, children: k($V, { isLead: n, animatesLayout: !!m, transition: K, isExiting: !ne, isOverlayed: i, id: C, children: a }) }) }) }) })] }) }, WV); function WV(e, t) { return !(t.isCurrent === void 0 || e.isCurrent !== t.isCurrent || e.isPrevious !== t.isPrevious || t.isCurrent && e.isOverlayed !== t.isOverlayed) } function RS(e, t, n) { let r = { ...e }; return t && (J(t.originX) && (r.originX = t.originX), J(t.originY) && (r.originY = t.originY), J(t.originZ) && (r.originZ = t.originZ)), n && (J(n.originX) && (r.originX = n.originX), J(n.originY) && (r.originY = n.originY), J(n.originZ) && (r.originZ = n.originZ)), r } function PS(e) { var t, n, r; if (!e || !("rotateX" in e || "rotateY" in e || "z" in e)) return !1; let o = e.rotateX !== 0 || e.rotateY !== 0 || e.z !== 0, s = ((t = e?.transition) == null ? void 0 : t.rotateX.from) !== 0 || ((n = e?.transition) == null ? void 0 : n.rotateY.from) !== 0 || ((r = e?.transition) == null ? void 0 : r.z.from) !== 0; return o || s } var Qi = { x: 0, y: 0, z: 0, rotate: 0, rotateX: 0, rotateY: 0, rotateZ: 0, scale: 1, scaleX: 1, scaleY: 1, scaleZ: 1, skew: 0, skewX: 0, skewY: 0, originX: .5, originY: .5, originZ: 0, opacity: 1 }, UV = class { constructor() { T(this, "warning", () => { za("The Navigator API is only available inside of Framer: https://www.framer.com/") }), T(this, "goBack", () => this.warning()), T(this, "instant", () => this.warning()), T(this, "fade", () => this.warning()), T(this, "push", () => this.warning()), T(this, "modal", () => this.warning()), T(this, "overlay", () => this.warning()), T(this, "flip", () => this.warning()), T(this, "customTransition", () => this.warning()), T(this, "magicMotion", () => this.warning()) } }, GV = new UV, qV = ke(GV), ct = { Fade: { exit: { opacity: 0 }, enter: { opacity: 0 } }, PushLeft: { exit: { x: "-30%" }, enter: { x: "100%" } }, PushRight: { exit: { x: "30%" }, enter: { x: "-100%" } }, PushUp: { exit: { y: "-30%" }, enter: { y: "100%" } }, PushDown: { exit: { y: "30%" }, enter: { y: "-100%" } }, Instant: { animation: { type: !1 }, enter: { opacity: 0 } }, Modal: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { center: !0 }, enter: { opacity: 0, scale: 1.2 } }, OverlayLeft: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { right: 0, top: 0, bottom: 0 }, enter: { x: "100%" } }, OverlayRight: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { left: 0, top: 0, bottom: 0 }, enter: { x: "-100%" } }, OverlayUp: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { bottom: 0, left: 0, right: 0 }, enter: { y: "100%" } }, OverlayDown: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { top: 0, left: 0, right: 0 }, enter: { y: "-100%" } }, FlipLeft: { backfaceVisible: !1, exit: { rotateY: -180 }, enter: { rotateY: 180 } }, FlipRight: { backfaceVisible: !1, exit: { rotateY: 180 }, enter: { rotateY: -180 } }, FlipUp: { backfaceVisible: !1, exit: { rotateX: 180 }, enter: { rotateX: -180 } }, FlipDown: { backfaceVisible: !1, exit: { rotateX: -180 }, enter: { rotateX: 180 } }, MagicMotion: { withMagicMotion: !0 } }; function XV(e) { switch (e && e.appearsFrom ? e.appearsFrom : "right") { case "right": return ct.PushLeft; case "left": return ct.PushRight; case "bottom": return ct.PushUp; case "top": return ct.PushDown } } function YV(e) { switch (e && e.appearsFrom ? e.appearsFrom : "bottom") { case "right": return ct.OverlayLeft; case "left": return ct.OverlayRight; case "bottom": return ct.OverlayUp; case "top": return ct.OverlayDown } } function KV(e) { switch (e && e.appearsFrom ? e.appearsFrom : "bottom") { case "right": return ct.FlipLeft; case "left": return ct.FlipRight; case "bottom": return ct.FlipUp; case "top": return ct.FlipDown } } var QV = () => ({ current: -1, previous: -1, currentOverlay: -1, previousOverlay: -1, visualIndex: 0, overlayItemId: 0, historyItemId: 0, history: [], overlayStack: [], containers: {}, containerIndex: {}, containerVisualIndex: {}, containerIsRemoved: {}, transitionForContainer: {}, previousTransition: null }); function _S(e, t) { switch (t.type) { case "addOverlay": return JV(e, t.transition, t.component); case "removeOverlay": return e3(e); case "add": return dC(e, t.key, t.transition, t.component); case "remove": return hC(e); case "update": return ZV(e, t.key, t.component); case "back": return t3(e); case "forward": return n3(e); default: return } } function ZV(e, t, n) { return { ...e, containers: { ...e.containers, [t]: n } } } function JV(e, t, n) { let r = e.overlayStack[e.currentOverlay]; if (r && r.component === n) return; let i = e.overlayItemId + 1, o = [...e.overlayStack, { key: `stack-${i}`, component: n, transition: t }]; return { ...e, overlayStack: o, overlayItemId: i, currentOverlay: Math.max(0, Math.min(e.currentOverlay + 1, o.length - 1)), previousOverlay: e.currentOverlay } } function e3(e) { return { ...e, overlayStack: [], currentOverlay: -1, previousOverlay: e.currentOverlay } } function dC(e, t, n, r) { e.containers[t] || (e.containers[t] = r), e.history = e.history.slice(0, e.current + 1), e.visualIndex = Math.max(e.history.length, 0); let i = e.history[e.history.length - 1], o = i && i.key === t; if (e.overlayStack = [], o && e.currentOverlay > -1) return { ...e, currentOverlay: -1, previousOverlay: e.currentOverlay }; if (o) return; let s = e.containerVisualIndex[t], a = e.containerIsRemoved[t], l = i?.key && n.withMagicMotion ? s3(t, s, a, e.history) : !0; e.history.push({ key: t, transition: n, visualIndex: l ? Math.max(e.visualIndex, 0) : e.containerVisualIndex[t] }); let c = e.current + 1, u = e.current; for (let y in e.containerIndex) e.containerIndex[y] === c && (e.containerIndex[y] = o3(y, e.history)); e.containerIndex[t] = c; let { containerVisualIndex: f, containerIsRemoved: d } = r3(e, t, l), p = pC(c, u, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: c, previous: u, containerVisualIndex: f, containerIsRemoved: d, transitionForContainer: p, previousTransition: null, currentOverlay: -1, historyItemId: e.historyItemId + 1, previousOverlay: e.currentOverlay } } function t3(e) { let t = { ...e.containers }, n = hC(e); if (n) return n.containers = t, n } function n3(e) { let t = e.history[e.current + 1]; if (!t) return; let { key: n, transition: r, component: i } = t, o = [...e.history], s = dC(e, n, r, i); if (s) return s.history = o, s } function hC(e) { let t = [...e.history.slice(0, e.current + 1)]; if (t.length === 1) return; let n = t.pop(); if (!n) return; let r = t[t.length - 1]; $(r, "The navigation history must have at least one component"), e.containerIndex[r.key] = t.length - 1, t.every(d => d.key !== n.key) && delete e.containers[n.key]; let o = e.current - 1, s = e.current, { containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u } = i3(e, r, n), f = pC(o, s, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: o, previous: s, containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u, transitionForContainer: f } } function r3(e, t, n) { let r = { containerVisualIndex: { ...e.containerVisualIndex }, containerIsRemoved: { ...e.containerIsRemoved } }; if (n) r.containerVisualIndex[t] = e.history.length - 1, r.containerIsRemoved[t] = !1; else { let i = e.containerVisualIndex[t]; for (let [o, s] of Object.entries(e.containerVisualIndex)) i !== void 0 && s > i && (r.containerIsRemoved[o] = !0) } return r } function i3(e, t, n) { let r = [t.key, n.key], i = e.history[e.history.length - 2], o = e.previousTransition === null ? null : { ...e.previousTransition }, s = { containerIsRemoved: { ...e.containerIsRemoved }, containerVisualIndex: { ...e.containerVisualIndex }, previousTransition: o, visualIndex: e.visualIndex }; i && r.push(i.key); let a = e.containerVisualIndex[t.key], l = e.containerVisualIndex[n.key], c = a !== void 0 && l !== void 0 && a <= l || t.visualIndex !== void 0 && t.visualIndex < e.history.length - 1, u = t.visualIndex; return c ? (s.containerIsRemoved[n.key] = !0, s.containerVisualIndex[t.key] = u !== void 0 ? u : e.history.length - 1) : (s.visualIndex = e.visualIndex + 1, s.containerVisualIndex[t.key] = e.visualIndex + 1), n.transition.withMagicMotion && (s.previousTransition = n.transition || null), e.containerIsRemoved[t.key] = !1, s } function o3(e, t) { var n; for (let r = t.length; r > t.length; r--)if (((n = t[r]) == null ? void 0 : n.key) === e) return r; return -1 } function pC(e, t, n, r, i) { let o = { ...i }; for (let [s, a] of Object.entries(r)) { let l = a3(a, { current: e, previous: t, history: n }); l && (o[s] = l) } return o } function s3(e, t, n, r) { return n || t === void 0 ? !0 : t === 0 ? !1 : r.slice(t, r.length).findIndex(s => s.key === e) > -1 ? !0 : !(r.slice(0, t - 1).findIndex(s => s.key === e) > -1) } function a3(e, t) { let { current: n, previous: r, history: i } = t; if (!(e !== n && e !== r)) { if (e === n && n > r) { let o = i[e]; return xu("enter", o?.transition.enter, o?.transition.animation) } if (e === r && n > r) { let o = i[e + 1]; return xu("exit", o?.transition.exit, o?.transition.animation) } if (e === n && n < r) { let o = i[e + 1]; return xu("enter", o?.transition.exit, o?.transition.animation) } if (e === r && n < r) { let o = i[e]; return xu("exit", o?.transition.enter, o?.transition.animation) } } } var l3 = no(Qi); function xu(e, t, n) { let r = {}, i = {}; return l3.forEach(o => { r[o] = Qi[o], i[o] = { ...n, from: Qi[o] } }), t && Object.keys(t).forEach(o => { if (t[o] === void 0) return; let s = t[o], a = typeof t[o] == "string" ? `${et(Qi)[o]}%` : et(Qi)[o]; et(r)[o] = e === "enter" ? a : s, i[o] = { ...n, from: e === "enter" ? s : a, velocity: 0 } }), { ...r, transition: { ...i } } } var c3 = x.createContext(void 0); var mC = x.createContext(void 0), u3 = (() => { var e, t, n, r, i, o, s, a, l; return t = class extends Re { constructor(c) { var u; super(c), tn(this, n), tn(this, i), tn(this, a), tn(this, e, null), T(this, "state", QV()), tn(this, s, b => { if (!this.props.enabled && this.state.history.length > 0) return; let h = _S(this.state, b); if (!h) return; let { skipLayoutAnimation: m } = this.props, v = h.history[h.current], w = b.type === "add" && b.transition.withMagicMotion || b.type === "forward" && v?.transition.withMagicMotion || b.type === "remove" && !!h.previousTransition, C = () => { var S; this.setState(h), v?.key && ((S = this.context) == null || S.call(this, v.key)) }; m && !w ? m(C) : C() }), T(this, "goBack", () => { var b; if (!Wt(this, i, o).call(this)) return ed(this, e, ((b = globalThis.event) == null ? void 0 : b.timeStamp) || null), this.state.currentOverlay !== -1 ? fe(this, s).call(this, { type: "removeOverlay" }) : fe(this, s).call(this, { type: "remove" }) }); let f = this.props.children; if (!f || !Eu(f) || !Tu(f)) return; let d = { ...ct.Instant }, y = { type: "add", key: ((u = f.key) == null ? void 0 : u.toString()) || `stack-${this.state.historyItemId + 1}`, transition: d, component: f }, g = _S(this.state, y); g && (this.state = g) } componentDidMount() { var c; let u = this.state.history[this.state.current]; u && ((c = this.context) == null || c.call(this, u.key)) } UNSAFE_componentWillReceiveProps(c) { var u; let f = c.children; if (!Eu(f) || !Tu(f)) return; let d = (u = f.key) == null ? void 0 : u.toString(); d && (this.state.history.length === 0 ? Wt(this, a, l).call(this, f, ct.Instant) : fe(this, s).call(this, { type: "update", key: d, component: f })) } componentWillUnmount() { var c, u; (u = (c = this.props).resetProjection) == null || u.call(c) } instant(c) { Wt(this, a, l).call(this, c, ct.Instant, void 0) } fade(c, u) { Wt(this, a, l).call(this, c, ct.Fade, u) } push(c, u) { Wt(this, a, l).call(this, c, XV(u), u) } modal(c, u) { Wt(this, a, l).call(this, c, ct.Modal, u) } overlay(c, u) { Wt(this, a, l).call(this, c, YV(u), u) } flip(c, u) { Wt(this, a, l).call(this, c, KV(u), u) } magicMotion(c, u) { Wt(this, a, l).call(this, c, ct.MagicMotion, u) } customTransition(c, u) { Wt(this, a, l).call(this, c, u) } render() { var c, u, f, d, p; let y = Wt(this, n, r).call(this, { overCurrentContext: !1 }), g = Wt(this, n, r).call(this, { overCurrentContext: !0 }), b = f3(g), h = g.current > -1, m = this.state.history.length === 1, v = []; for (let [C, S] of Object.entries(this.state.containers)) { let R = this.state.containerIndex[C]; $(R !== void 0, "Container's index must be registered"); let E = this.state.containerVisualIndex[C]; $(E !== void 0, "Container's visual index must be registered"); let L = this.state.containerIsRemoved[C], F = this.state.history[R], N = this.state.transitionForContainer[C], A = R === this.state.current, K = R === this.state.previous, U = A ? !1 : L, H = ((c = F?.transition) == null ? void 0 : c.withMagicMotion) || A && !!this.state.previousTransition; v.push(k(vm, { id: C, index: E, isInitial: m, isCurrent: A, isPrevious: K, isOverlayed: h, visible: A || K, position: (u = F?.transition) == null ? void 0 : u.position, instant: IS(R, y), transitionProps: N, animation: FS(R, y), backfaceVisible: y3(R, y), exitAnimation: (f = F?.transition) == null ? void 0 : f.animation, exitBackfaceVisible: (d = F?.transition) == null ? void 0 : d.backfaceVisible, exitProps: (p = F?.transition) == null ? void 0 : p.enter, withMagicMotion: H, areMagicMotionLayersPresent: U ? !1 : void 0, children: k(SV, { children: LS({ component: S, transition: F?.transition }) }) }, C)) } let w = this.state.overlayStack.map((C, S) => k(vm, { isLayeredContainer: !0, isCurrent: S === this.state.currentOverlay, position: C.transition.position, initialProps: v3(S, g), transitionProps: b3(S, g), instant: IS(S, g, !0), animation: FS(S, g), exitProps: C.transition.enter, visible: x3(S, g), backdropColor: m3(C.transition), backfaceVisible: g3(S, g), onTapBackdrop: w3(C.transition, this.goBack), index: this.state.current + 1 + S, children: LS({ component: C.component, transition: C.transition }) }, C.key)); return k(Pu, { "data-framer-component-type": "NavigationRoot", top: 0, left: 0, width: "100%", height: "100%", position: "relative", style: { overflow: "hidden", backgroundColor: "unset", pointerEvents: void 0, ...this.props.style }, children: k(qV.Provider, { value: this, children: ue(mC.Provider, { value: m, children: [k(vm, { isLayeredContainer: !0, position: void 0, initialProps: {}, instant: !1, transitionProps: d3(b), animation: h3(b), backfaceVisible: p3(b), visible: !0, backdropColor: void 0, onTapBackdrop: void 0, index: 0, children: k(IO, { children: k(xV, { children: k(Hd, { presenceAffectsLayout: !1, children: v }) }) }) }), k(Hd, { children: w })] }) }) }) } }, e = new WeakMap, n = new WeakSet, r = function (c) { let { current: u, previous: f, currentOverlay: d, previousOverlay: p } = this.state; return c.overCurrentContext ? { current: d, previous: p, history: this.state.overlayStack } : { current: u, previous: f, history: this.state.history } }, i = new WeakSet, o = function () { return globalThis.event ? fe(this, e) === globalThis.event.timeStamp : !1 }, s = new WeakMap, a = new WeakSet, l = function (c, u, f) { var d, p; if (Wt(this, i, o).call(this) || (ed(this, e, ((d = globalThis.event) == null ? void 0 : d.timeStamp) || null), !c || !Eu(c) || !Tu(c))) return; let y = { ...u, ...f }; if (!!y.overCurrentContext) return fe(this, s).call(this, { type: "addOverlay", transition: y, component: c }); let b = ((p = c.key) == null ? void 0 : p.toString()) || `stack-${this.state.historyItemId + 1}`; fe(this, s).call(this, { type: "add", key: b, transition: y, component: c }) }, T(t, "defaultProps", { enabled: !0 }), T(t, "contextType", c3), t })(), gC = { stiffness: 500, damping: 50, restDelta: 1, type: "spring" }; function f3(e) { let t, n; return e.current !== -1 ? t = e.history[e.current] : n = e.history[e.previous], { currentOverlayItem: t, previousOverlayItem: n } } function d3({ currentOverlayItem: e }) { return e && e.transition.exit } function h3({ currentOverlayItem: e, previousOverlayItem: t }) { return e && e.transition.animation ? e.transition.animation : t && t.transition.animation ? t.transition.animation : gC } function p3({ currentOverlayItem: e, previousOverlayItem: t }) { return e ? e.transition.backfaceVisible : t && t.transition.backfaceVisible } function m3(e) { if (e.backdropColor) return e.backdropColor; if (e.overCurrentContext) return "rgba(4,4,15,.4)" } function g3(e, t) { let { current: n, history: r } = t; if (e === n) { let i = r[e]; return i && i.transition ? i.transition.backfaceVisible : !0 } else if (e < n) { let i = r[e + 1]; return i && i.transition ? i.transition.backfaceVisible : !0 } else { let i = r[e]; return i && i.transition ? i.transition.backfaceVisible : !0 } } function v3(e, t) { let n = t.history[e]; if (n) return n.transition.enter } function y3(e, t) { var n, r, i, o; let { current: s, previous: a, history: l } = t; return e === a && s > a || e === s && s < a ? (r = (n = l[e + 1]) == null ? void 0 : n.transition) == null ? void 0 : r.backfaceVisible : (o = (i = l[e]) == null ? void 0 : i.transition) == null ? void 0 : o.backfaceVisible } function b3(e, t) { let { current: n, history: r } = t; if (e !== n) if (e < n) { let i = r[e + 1]; if (i && i.transition) return i.transition.exit } else { let i = r[e]; if (i && i.transition) return i.transition.enter } } function FS(e, t) { let { current: n, previous: r, history: i } = t, o = r > n ? r : n; if (e < o) { let s = i[e + 1]; if (s && s.transition.animation) return s.transition.animation } else if (e !== o) { let s = i[e]; if (s && s.transition.animation) return s.transition.animation } else { let s = i[e]; if (s?.transition.animation) return s.transition.animation } return gC } function IS(e, t, n) { let { current: r, previous: i, history: o } = t; return !!(n && o.length > 1 || e !== i && e !== r || r === i) } function x3(e, t) { let { current: n, previous: r } = t; return e > n && e > r ? !1 : e === n } function LS(e) { return x.Children.map(e.component, n => { var r; if (!Eu(n) || !Tu(n) || !n.props) return n; let i = { style: n.props.style ?? {} }, o = (r = e?.transition) == null ? void 0 : r.position, s = !o || o.left !== void 0 && o.right !== void 0, a = !o || o.top !== void 0 && o.bottom !== void 0, l = "style" in n.props ? Te(n.props.style) : !0; return s && ("width" in n.props && (i.width = "100%"), l && (i.style.width = "100%")), a && ("height" in n.props && (i.height = "100%"), l && (i.style.height = "100%")), x.cloneElement(n, i) }) } function w3(e, t) { if (e.goBackOnTapOutside !== !1) return t } function S3(e) { let t = gb(), n = Gd(); return x.useInsertionEffect(() => { el() }, []), k(u3, { ...e, resetProjection: t, skipLayoutAnimation: n, children: e.children }) } var zj = Jn(Qu(), 1); var Wj = Jn(Jm(), 1); function k3(e, t) { let n, r = (...o) => { ft.clearTimeout(n), n = ft.setTimeout(e, t, ...o) }, i = () => { ft.clearTimeout(n) }; return r.cancel = i, r } function $u(...e) { return e.filter(Boolean).join(" ") } var C3 = (() => { function e(t = {}) { let n = gm(t, !1, !1); return e.addData(n), n } return e._stores = [], e.addData = t => { e._stores.push(t) }, e.reset = () => { e._stores.forEach(t => gm.resetObject(t)) }, e.addObserver = (t, n) => gm.addObserver(t, n), e })(), ym = C3; var T3 = { update: 0 }, E3 = x.createContext({ update: NaN }); var R3 = class extends Re { constructor() { super(...arguments), T(this, "observers", []), T(this, "state", T3), T(this, "taskAdded", !1), T(this, "frameTask", () => { this.setState({ update: this.state.update + 1 }), this.taskAdded = !1 }), T(this, "observer", () => { this.taskAdded || (this.taskAdded = !0, Vk.addFrameTask(this.frameTask)) }) } componentWillUnmount() { this.observers.map(e => e()), ym.reset() } render() { let { children: e } = this.props; return this.observers.map(t => t()), this.observers = [], ym._stores.forEach(t => { let n = ym.addObserver(t, this.observer); this.observers.push(n) }), k(E3.Provider, { value: { ...this.state }, children: e }) } }, g8 = Jn(Qu(), 1); var vC = "__framer__", P3 = (() => vC.length)(); function _3(e) { if (e.startsWith(vC)) return e.substr(P3) } var hr = ["opacity", "x", "y", "scale", "rotate", "rotateX", "rotateY", "skewX", "skewY", "transformPerspective"], Nu = e => ({ x: Ue(e?.x ?? 0), y: Ue(e?.y ?? 0), opacity: Ue(e?.opacity ?? 1), scale: Ue(e?.scale ?? 1), rotate: Ue(e?.rotate ?? 0), rotateX: Ue(e?.rotateX ?? 0), rotateY: Ue(e?.rotateY ?? 0), skewX: Ue(e?.skewX ?? 0), skewY: Ue(e?.skewY ?? 0), transformPerspective: Ue(e?.transformPerspective ?? 0) }), Qe = { x: 0, y: 0, scale: 1, opacity: 1, rotate: 0, rotateX: 0, rotateY: 0, skewX: 0, skewY: 0, transformPerspective: 0 }; function yC(e) { return e in Qe } function bC(e, t) { let n = Qt(() => ({ values: Nu(t ? e : void 0) })); return x.useEffect(() => { if (!t) for (let r of hr) { let i = Qe[r]; Je(i) || n.values[r].set(i) } }, [n, t]), n } var F3 = new Set(["loopEffectEnabled", "loopTransition", "loop", "loopRepeatType", "loopRepeatDelay"]), I3 = () => { let e = D(); return z(() => () => { clearTimeout(e.current) }, []), async t => new Promise(n => { e.current = setTimeout(() => { n(!0) }, t * 1e3) }) }; function L3({ loopEffectEnabled: e, loopRepeatDelay: t, loopTransition: n, loopRepeatType: r, loop: i }) { let o = Li(), s = Qt(() => ({ values: Nu() })), a = x.useRef(!1), l = I3(), c = async () => { if (!i) return; let d = n || void 0, p = a.current && r === "mirror", y = p ? Qe : i, g = p ? i : Qe; return a.current = !a.current, Promise.all(hr.map(b => { if (!(o && b !== "opacity")) return s.values[b].set(g[b] ?? Qe[b]), new Promise(h => { let m = { ...d, onComplete: () => h() }; nr(s.values[b], y[b] ?? g[b], m) }) })) }, u = async () => { e && (await c(), await l(t ?? 0), await u()) }, f = se(() => { hr.forEach(d => { s.values[d].stop() }), hr.forEach(d => { s.values[d].set(Qe[d]) }), a.current = !1 }, [s]); return x.useEffect(() => (e && i ? u() : f(), () => f()), [e]), s } function M3(e, t, n, r, i) { let o = n / 100 - 1, s = i ? (t - r) * o : 0, a = -e * o; return s + a } var O3 = new Set(["speed", "adjustPosition", "offset", "parallaxTransformEnabled"]); function D3(e, t, n) { let { speed: r = 100, offset: i = 0, adjustPosition: o = !1, parallaxTransformEnabled: s } = e, a = x.useRef(null), l = Li(), c = x.useCallback(y => a.current === null || r === 100 ? 0 : M3(y, a.current, r, i, o), [a, r, i, o]); x.useLayoutEffect(() => { Y.read(() => { var y, g; a.current = ((g = (y = t.current) == null ? void 0 : y.getBoundingClientRect()) == null ? void 0 : g.top) ?? 0 }), Y.update(() => { f.set(c(u.get())), o && d.set(n ?? "initial") }) }, [t, a, o]); let { scrollY: u } = sb(), f = At(u, c), d = tr(o && a.current === null ? "hidden" : n), p = tr(0); return { values: { y: l || !s ? p : f }, style: s ? { visibility: d } : void 0 } } function A3(e) { if (!(ce(e) || !Te(e))) return e?.transition } async function bm(e, t, n, r, i, o) { let s = A3(e); return Promise.all(hr.map(a => new Promise(l => { if (n && a !== "opacity") return l(); let c = t.values[a]; c.stop(); let u = Te(e) ? e?.[a] ?? Qe[a] : Qe[a]; if (De(u) && (u = u.get()), !Ve(u)) return l(); let f = kr.get(r.current); f && f.setBaseTarget(a, u); let d; if (ce(i) && !c?.hasAnimated && ft.MotionHandoffAnimation) { let p = ft.MotionHandoffAnimation(i, a, Y); p && (d = p) } o ? c.set(u) : nr(c, u, { ...s, velocity: 0, startTime: d, onComplete: () => l() }) }))) } var V3 = new Set(["presenceInitial", "presenceAnimate", "presenceExit"]); function B3({ initial: e, animate: t, exit: n, presenceInitial: r, presenceAnimate: i, presenceExit: o }, s, a, l, c) { let u = r ?? e, f = i ?? t, d = o ?? n, [p, y] = Ld(), g = D({ lastPresence: !1, lastAnimate: f, hasMounted: !1, running: !1 }), b = Qt(() => { let m = u ?? l; if (!Te(m)) return { values: Nu() }; let v = {}; for (let w in m) { let C = Te(m) ? m[w] : void 0; Ve(C) && (v[w] = C) } return { values: Nu(v) } }); tt(() => { let { hasMounted: m } = g.current; if (m && f) return; let v = kr.get(s.current); if (v) { Object.assign(g.current, { hasMounted: !0 }); for (let w in b.values) { if (!yC(w)) continue; let C = l?.[w]; v.setBaseTarget(w, Ve(C) ? C : Qe[w]) } } }, [f]); let h = Li(); return tt(() => { if (!a) { y?.(); return } if (p !== g.current.lastPresence) Object.assign(g.current, { lastPresence: p }), p ? u && f && (Object.assign(g.current, { running: !0 }), bm(f, b, h, s, c).then(() => Object.assign(g.current, { running: !1 }))) : d ? (Object.assign(g.current, { running: !0 }), bm(d, b, h, s, c).then(() => Object.assign(g.current, { running: !1 })).then(() => y())) : y(); else { let { lastAnimate: m, running: v } = g.current; if (!!qe(f, m) || !f) return; Object.assign(g.current, { lastAnimate: f }), bm(f, b, h, s, c, !v).then(() => Object.assign(g.current, { running: !1 })) } }), b } function z3(e, t) { let n = 0, r = e; for (; r && r !== t && r instanceof HTMLElement;)n += r.offsetTop, r = r.offsetParent; return n } var $3 = 1; function xC(e, t = 0, n) { var r; let i = [], o = []; for (let s = e.length; s >= 0; s--) { let { ref: a, offset: l } = e[s] ?? {}; if (!a || !a.current) continue; let u = z3(a.current, document.documentElement) - $3 - (l ?? 0) - t, f = ((r = a.current) == null ? void 0 : r.clientHeight) ?? 0, d = i[i.length - 1], p = Math.max(u + f, 0); i.push(u), o.unshift(Math.max(u, 0), d === void 0 ? p : Math.min(p, Math.max(d - 1, 0))), n?.(s) } return o } function N3(e, t = 0) { return e < t ? "up" : "down" } var H3 = 4; function j3(e, t, n = {}) { let { direction: r, target: i } = e ?? {}, { repeat: o = !0, enabled: s = !0 } = n; x.useEffect(() => { if (!r || !s) return; let a, l = 0, c, u; return wo(({ y: f }) => { if (!o && u === i || f.current > f.scrollLength || f.current < 0) return; let d = N3(f.current, a); a = f.current; let p = d !== c; if (c = d, p) l = f.current; else { if (Math.abs(f.current - l) < H3) return; let g = d === r ? i : void 0; g !== u && t(g), u = g } }) }, [r, o, i, s, t]) } var W3 = new Set(["threshold", "animateOnce", "opacity", "targetOpacity", "x", "y", "scale", "transition", "rotate", "rotateX", "rotateY", "perspective", "enter", "exit", "animate", "styleAppearEffectEnabled", "targets", "scrollDirection"]), U3 = ["animate", "animate"], MS = { inputRange: [], outputRange: [] }; function G3(e, t, n) { let r = xC(e, t), i = [...U3], o = r[0]; if (!Ve(o)) return MS; if (o > 1 && (r.unshift(0, o - 1), i.unshift("initial", "initial")), n) { let s = r.length - 1, a = r[s]; if (!Ve(a)) return MS; r.push(a + 1), i.push("exit") } return { inputRange: r, outputRange: i } } function xm(e) { return { x: e?.x ?? Qe.x, y: e?.y ?? Qe.y, scale: e?.scale ?? Qe.scale, opacity: e?.opacity ?? Qe.opacity, transformPerspective: e?.transformPerspective ?? Qe.transformPerspective, rotate: e?.rotate ?? Qe.rotate, rotateX: e?.rotateX ?? Qe.rotateX, rotateY: e?.rotateY ?? Qe.rotateY, skewX: e?.skewX ?? Qe.skewX, skewY: e?.skewY ?? Qe.skewY, transition: e?.transition ?? void 0 } } function q3({ opacity: e, targetOpacity: t, perspective: n, enter: r, exit: i, animate: o, ...s }) { return x.useMemo(() => ({ initial: r ?? xm({ ...s, opacity: e ?? t ?? 1, transformPerspective: n }), animate: o ?? xm({ opacity: t }), exit: i ?? xm() }), [o, s, r, i, e, t, n]) } function X3(e, t) { let n = Li(), r = q3(e), i = e.styleAppearEffectEnabled, o = bC(i ? r.initial : r.animate, i), s = x.useRef({ isPlaying: !1, scheduledAppearState: void 0, lastAppearState: !e.styleAppearEffectEnabled }), a = x.useRef(), l = x.useCallback(async ({ transition: d, ...p }, y) => { let g = d ?? r.animate.transition ?? e.transition; await a.current, a.current = Promise.all(hr.map(b => { y && o.values[b].set(r.initial[b] ?? Qe[b]); let h = p[b] ?? Qe[b], m = kr.get(t.current); return m && typeof h != "object" && m.setBaseTarget(b, h), new Promise(v => { if (n && b !== "opacity") Ve(h) && o.values[b].set(h), v(); else { let w = { restDelta: b === "scale" ? .001 : void 0, ...g, onComplete: () => v() }; nr(o.values[b], h, w) } }) })) }, []), c = e.animateOnce && s.current.lastAppearState === !0, u = !e.targets && e.styleAppearEffectEnabled && !e.scrollDirection && !c; PV(t, d => { let { isPlaying: p, lastAppearState: y } = s.current; if (p) { s.current.scheduledAppearState = d; return } s.current.scheduledAppearState = void 0, s.current.lastAppearState = d, y !== d && l(d ? r.animate : r.exit, d) }, { enabled: u, animateOnce: !!e.animateOnce, threshold: { y: e.threshold } }); let f = e.targets && i && !e.scrollDirection; return x.useEffect(() => { if (!f) return; let d = { initial: !0 }, p = "initial"; return wo(({ y }) => { let { targets: g } = e; if (!g || !g[0] || g[0].ref && !g[0].ref.current) return; let { inputRange: b, outputRange: h } = G3(g, (e.threshold ?? 0) * y.containerLength, !!e.exit); if (b.length === 0 || b.length !== h.length) return; let m = Bs(y.current, b, h); if (e.animateOnce && d[m] || (d[m] = !0, p === m)) return; p = m; let v = et(r)[m]; v && l(v) }) }, [f]), j3(e.scrollDirection, d => l(d ?? r.animate), { enabled: i, repeat: !e.animateOnce }), o } var Y3 = new Set(["transformViewportThreshold", "styleTransformEffectEnabled", "transformTargets", "spring", "transformTrigger"]), K3 = (e, t) => { var n; let r = (n = e?.[0]) == null ? void 0 : n.target; return t ? { opacity: r?.opacity ?? 1 } : r }, wC = () => ({ opacity: [], x: [], y: [], scale: [], rotate: [], rotateX: [], rotateY: [], skewX: [], skewY: [], transformPerspective: [] }); function Q3(e, t) { let n = x.useRef({}); x.useEffect(() => { if (t !== void 0) for (let r of no(e)) { let i = e[r]; i.attach((o, s) => { let a = n.current[r]; if (a && a.stop(), n.current[r] = Sd({ keyframes: [i.get(), o], velocity: i.getVelocity(), ...t, restDelta: .001, onUpdate: s }), !We.isProcessing) { let l = performance.now() - We.timestamp; l < 40 && (n.current[r].time = l / 1e3) } return i.get() }) } }, [JSON.stringify(t)]) } function Z3(e, t) { let n = wC(); return { inputRange: xC(e, t, i => { var o, s, a; let l = (o = e[i - 1]) == null ? void 0 : o.target, c = (s = e[i]) == null ? void 0 : s.target; for (let u of hr) (a = n[u]) == null || a.unshift(l?.[u] ?? 0, c?.[u] ?? 0) }), effectKeyOutputRange: n } } function J3(e) { var t; let n = wC(); for (let { target: r } of e) for (let i of hr) (t = n[i]) == null || t.push(r[i]); return n } var OS = [0, 1]; function e5({ transformTrigger: e, styleTransformEffectEnabled: t, transformTargets: n, spring: r, transformViewportThreshold: i = 0 }, o) { let s = Li(), a = bC(K3(n, s), t); return x.useLayoutEffect(() => { if (!(!t || !n)) if (e !== "onScrollTarget") { let l = J3(n); return wo(({ y: c }) => { for (let u of hr) s && u !== "opacity" || OS.length === l[u].length && l[u][0] !== void 0 && a.values[u].set(Bs(c.progress, OS, l[u])) }, e === "onInView" ? { target: o.current ?? void 0, offset: ["start end", "end end"] } : void 0) } else return wo(({ y: l }) => { if (!n[0] || n[0].ref && !n[0].ref.current) return; let { inputRange: c, effectKeyOutputRange: u } = Z3(n, i * l.containerLength); if (c.length !== 0) for (let f of hr) s && f !== "opacity" || c.length === u[f].length && u[f][0] !== void 0 && a.values[f].set(Bs(l.current, c, u[f])) }) }, [s, e, o, i, t, a, n]), Q3(a.values, r), a } var SC = { parallax: O3, styleAppear: W3, styleTransform: Y3, loop: F3, presence: V3 }, t5 = no(SC); function DS(e, t, n) { return !(e in n) && t in n || n[e] === !0 } function n5(e) { let t = { parallax: {}, styleAppear: {}, styleTransform: {}, presence: { animate: e.animate, initial: e.initial, exit: e.exit }, loop: {}, forwardedProps: {} }; for (let n in e) { let r = _3(n); if (r) for (let i of t5) { let o = SC[i]; if (o?.has(r)) { t[i][r] = et(e)[n]; break } } else t.forwardedProps[n] = et(e)[n] } return t.parallax.parallaxTransformEnabled = DS("parallaxTransformEnabled", "speed", t.parallax), t.styleAppear.styleAppearEffectEnabled = DS("styleAppearEffectEnabled", "animateOnce", t.styleAppear), t } var vi = e => e.reduce((t, n) => t += n, 0), AS = e => e.reduce((t, n) => t = t * n, 1), r5 = "current"; function i5(e) { return Te(e) && r5 in e } function o5(e, t) { if (!e || !Te(e)) return t; for (let n in e) { let r = e[n]; !De(r) || !yC(n) || Ve(r.get()) && t[n].push(r) } } function Ia(e) { return ce(e) || Array.isArray(e) } var s5 = e => x.forwardRef((t, n) => { if (t.__withFX) return k(e, { ...t, animate: void 0, initial: void 0, exit: void 0, ref: n }); if (le.current() === le.canvas) { let pe = Ia(t.animate) ? t.animate : void 0, ie = Ia(t.initial) ? t.initial : void 0; return k(e, { ...t, animate: pe, initial: ie, exit: void 0, ref: n }) } let r = x.useRef(null), i = n ?? r, { parallax: o = {}, styleAppear: s = {}, styleTransform: a = {}, presence: l = {}, loop: c = {}, forwardedProps: u } = n5(t), { __targetOpacity: f, __perspectiveFX: d, __smartComponentFX: p = !1 } = t, y = tr(f ?? 1), { values: g } = B3(l, i, p, t.style, t[Ml]), { values: b, style: h } = D3(o, i), { values: m } = e5(a, i), { values: v } = X3(s, i), { values: w } = L3(c), C = x.useMemo(() => ({ scale: [v.scale, w.scale, g.scale, m.scale], opacity: [v.opacity, w.opacity, g.opacity, y, m.opacity], x: [v.x, w.x, g.x, m.x], y: [v.y, w.y, b.y, g.y, m.y], rotate: [v.rotate, w.rotate, g.rotate, m.rotate], rotateX: [v.rotateX, w.rotateX, g.rotateX, m.rotateX], rotateY: [v.rotateY, w.rotateY, g.rotateY, m.rotateY], skewX: [v.skewX, w.skewX, g.skewX, m.skewX], skewY: [v.skewY, w.skewY, g.skewY, m.skewY], transformPerspective: [m.transformPerspective, v.transformPerspective] }), [y, m, b, v, w, g]); o5(t.style, C); let S = At(C.scale, AS), R = At(C.opacity, AS), E = At(C.x, vi), L = At(C.y, vi), F = At(C.rotate, vi), N = At(C.rotateX, vi), A = At(C.rotateY, vi), K = At(C.skewX, vi), U = At(C.skewY, vi), H = At(C.transformPerspective, vi), { drag: W, dragConstraints: ee } = u; BA(W && i5(ee) ? ee : void 0); let te = { opacity: R, scale: S, x: E, y: L, rotate: F, rotateX: N, rotateY: A, skewX: K, skewY: U }; Je(d) && (te.transformPerspective = H); let q = Ia(t.animate) ? t.animate : void 0, ne = Ia(t.initial) ? t.initial : void 0, be = Ia(t.exit) ? t.exit : void 0, re = p && !l.presenceInitial ? { initial: ne, animate: q, exit: be } : {}; return k(e, { ...u, ...re, __withFX: !0, style: { ...t.style, ...h, ...te }, values: g, ref: i }) }); var P8 = s5; function Dm(e, t) { Si(e) ? e(t) : kC(e) && (e.current = t) } function kC(e) { return Te(e) && "current" in e } function VS(e, t) { return { get current() { return e.current }, set current(n) { e.current = n, t(n) } } } function a5(...e) { return t => e.forEach(n => Dm(n, t)) } function sf(e) { let t = Qt(() => l5(e)); return t.useSetup(e), t.cloneAsElement } function l5(e) { let t = { forwardedRef: e, childRef: null, ref: null }; t.ref = BS(t); let n = (s, a) => { if (!t.forwardedRef && t.forwardedRef === s) { t.ref = a; return } let l = !1; t.childRef !== a && (t.childRef = a, l = !0), t.forwardedRef !== s && (t.forwardedRef = s, l = !0), l && (t.ref = BS(t)) }, r = !1; function i(s, a) { if (r) throw new ReferenceError("useCloneChildrenWithPropsAndRef: You should not call cloneChildrenWithPropsAndRef more than once during the render cycle."); return r = !0, qn.count(s) > 1 && e && (t.forwardedRef = void 0, t.ref = t.childRef), qn.map(s, l => { if (Ht(l)) { let c = "ref" in l ? l.ref : void 0; n(t.forwardedRef, c); let u = t.ref !== c ? { ...a, ref: t.ref } : a; return vr(l, u) } return l }) } let o = function (a, l) { return k(He, { children: i(a, l) }) }; return o.cloneAsArray = i, { useSetup: s => { r = !1, n(s, t.childRef) }, cloneAsElement: o } } function BS(e) { if (!e.forwardedRef) return e.childRef; let { forwardedRef: t, childRef: n } = e; return r => { Dm(n, r), Dm(t, r) } } var CC = x.createContext({}); function O8() { return x.useContext(CC) } var D8 = x.forwardRef(({ width: e, height: t, y: n, children: r, ...i }, o) => { let s = x.useMemo(() => ({ width: e, height: t, y: n }), [e, t, n]), a = sf(o); return k(CC.Provider, { value: s, children: a(r, i) }) }), c5 = e => x.forwardRef((t, n) => { let r = rl(t); return k(e, { layoutId: r, ...t, layoutIdKey: void 0, duplicatedFrom: void 0, ref: n }) }), u5 = class extends Re { constructor() { super(...arguments), T(this, "state", { hasError: !1 }) } componentDidCatch(e, t) { var n; let r = t?.componentStack; if (console.error("Error in component (see previous log). This component has been hidden. Please check any custom code or code overrides to fix.", r), this.setState({ hasError: !0 }), typeof I < "u" && Math.random() <= .01) { let i = e instanceof Error && typeof e.stack == "string" ? e.stack : null; (n = I.__framer_events) == null || n.push(["published_site_load_recoverable_error", { message: String(e), stack: i, componentStack: i ? void 0 : r }]) } } render() { let { children: e } = this.props, { hasError: t } = this.state; return t ? null : e } }, f5 = x.forwardRef(({ children: e, layoutId: t, as: n, ...r }, i) => { let o = Qt(() => t ? `${t}-container` : void 0), s = nl(n); return k(s, { layoutId: o, ...r, ref: i, children: k(us.Provider, { value: !0, children: k(MO, { enabled: !1, children: k(nb, { id: t ?? "", inherit: "id", children: k(u5, { children: x.Children.map(e, a => x.isValidElement(a) ? x.cloneElement(a, { layoutId: t }) : a) }) }) }) }) }) }), N8 = c5(f5), d5 = x.createContext(void 0), h5 = (() => { var e; if (!ki()) return new Set; let t = (e = document.querySelector("style[data-framer-css-ssr-minified]")) == null ? void 0 : e.getAttribute("data-framer-components"); return t ? new Set(t.split(" ")) : new Set })(), p5 = "data-framer-css-ssr", TC = (e, t, n) => x.forwardRef((r, i) => {
    let { sheet: o, cache: s } = x.useContext(d5) ?? {}; if (!ki()) {
        let a = Array.isArray(t) ? t.join(`
`) : t; return ue(He, { children: [k("style", { [p5]: !0, "data-framer-component": n, dangerouslySetInnerHTML: { __html: a } }), k(e, { ...r, ref: i })] })
    } return x.useInsertionEffect(() => {
        if (n && h5.has(n)) return; (Array.isArray(t) ? t : t.split(`
`)).forEach(l => l && Wk(l, o, s))
    }, []), k(e, { ...r, ref: i })
}), mg = x.createContext({ onRegisterCursors: () => () => { }, registerCursors: () => { } }), Hu = "framer-cursor-none", Am = "framer-pointer-events-none", m5 = x.memo(function ({ children: t }) { let n = Qt(() => { let i = new Set, o = {}; return { onRegisterCursors: s => (s(o), i.add(s), () => i.delete(s)), registerCursors: s => { let a = {}; for (let l in s) { let c = o[l] ?? s[l]; c && (a[l] = c) } o = a; for (let l of i) l(o) } } }), r = Li(); return ue(mg.Provider, { value: n, children: [t, !r && k(w5, {})] }) }), g5 = (() => TC(m5, [`.${Hu}, .${Hu} * { cursor: none !important; }`, `.${Am}, .${Am} * { pointer-events: none !important; }`]))(), v5 = (() => ({ position: "fixed", top: 0, left: 0, zIndex: 12 + 1, pointerEvents: "none" }))(); function y5(e) { return !(!e || e.placement || e.alignment) } function wu(e) { switch (e) { case "start": return "0%"; case "center": return "-50%"; case "end": return "-100%"; default: xe(e) } } function b5(e, t = "center") { switch (e) { case "top": return `${wu(t)}, -100%`; case "right": return `0%, ${wu(t)}`; case "bottom": return `${wu(t)}, 0%`; case "left": return `-100%, ${wu(t)}`; default: return "-50%, -50%" } } var zS = "data-framer-portal-id"; function $S(e, t) { let n = document.elementFromPoint(e, t); for (; n;) { if (n === document.body) return; let r = n.getAttribute("data-framer-cursor"); if (r) return r; if (n.hasAttribute(zS)) { let i = n.getAttribute(zS); n = n.parentElement, i && (n = document.getElementById(i) ?? n) } else n = n.parentElement } } function x5(e) { for (let t in e) return !1; return !0 } var w5 = x.memo(function () { let { onRegisterCursors: t } = V(mg), n = tr(0), r = tr(0), i = tr(0), o = x.useRef(null), s = x.useRef({ cursors: {}, cursorHash: void 0 }), a = nf(), l = !x5(s.current.cursors); x.useEffect(() => { let S = 0, R = 0; function E() { n.set(S), r.set(R), nr(i, 1, { type: "tween", duration: .2 }) } function L(A) { A.pointerType !== "touch" && (S = A.clientX, R = A.clientY, Y.update(E)) } let F = () => { if (!l) return; let A = $S(S, R); A !== s.current.cursorHash && (s.current.cursorHash = A, Y.update(() => a())) }; Y.read(F, !0); function N(A) { if (A.target === o.current || !o.current) return; let K = new PointerEvent(A.type, { bubbles: !0, cancelable: A.cancelable, pointerType: A.pointerType, pointerId: A.pointerId, composed: A.composed, isPrimary: A.isPrimary, buttons: A.buttons, button: A.button }); Y.update(() => { var U; (U = o.current) == null || U.dispatchEvent(K) }) } return ft.addEventListener("pointermove", L), document.addEventListener("pointerdown", N), document.addEventListener("pointerup", N), () => { ft.removeEventListener("pointermove", L), document.removeEventListener("pointerdown", N), document.removeEventListener("pointerup", N), Dt(F) } }, [i, n, r, l, a]), x.useEffect(() => { function S() { nr(i, 0, { type: "tween", duration: .2 }) } return document.addEventListener("mouseleave", S), ft.addEventListener("blur", S), () => { document.removeEventListener("mouseleave", S), ft.removeEventListener("blur", S) } }, [i]), x.useLayoutEffect(() => { function S(E) { s.current.cursors = E, s.current.cursorHash = $S(n.get(), r.get()), a() } let R = t(S); return () => { R(), document.body.classList.toggle(Hu, !1) } }, [n, r, t, a]); let { cursors: c, cursorHash: u } = s.current, f = u ? c[u] : null, d = y5(f); x.useLayoutEffect(() => { document.body.classList.toggle(Hu, d) }, [d]); let p = f?.component, y = f?.transition ?? { duration: 0 }, g = Wd(n, y), b = Wd(r, y), h = At(() => { var S; return g.get() + (((S = f?.offset) == null ? void 0 : S.x) ?? 0) }), m = At(() => { var S; return b.get() + (((S = f?.offset) == null ? void 0 : S.y) ?? 0) }), v = f?.alignment, w = f?.placement, C = x.useCallback((S, R) => `translate(${b5(w, v)}) ${R}`, [v, w]); return !f || !p ? null : k(p, { transformTemplate: C, style: { ...v5, x: h, y: m, opacity: i }, globalTapTarget: !0, variant: f?.variant, ref: o, className: Am }) }); function q8(e) { let { registerCursors: t } = V(mg), n = Qt(() => e); x.useLayoutEffect(() => { t(n) }, [n, t]) } var S5 = x.createContext(void 0), af = class { constructor(e) { this.resolver = e, T(this, "status") } static is(e) { return e instanceof af } preload() { if (this.status) { let t = this.status; return t.type !== "pending" ? void 0 : t.promise } let e = this.resolver().then(t => { this.status = { type: "fulfilled", value: t } }, t => { this.status = { type: "rejected", error: t } }); return this.status = { type: "pending", promise: e }, e } waitFor() { return this.resolver() } read() { let e = this.status; if (!e) throw new Error("Need to call preload() before read()"); switch (e.type) { case "pending": throw new Error("Need to wait for preload() to resolve"); case "fulfilled": return e.value; case "rejected": throw e.error; default: xe(e) } } }, EC = x.createContext(void 0), J8 = (() => EC.Provider)(), RC = () => x.useContext(EC) ?? {}; function gg(e, t) { return e instanceof HTMLAnchorElement ? e : e instanceof Element ? e === t ? null : gg(e.parentElement, t) : null } function k5({ children: e }) { let { useGranularSuspense: t } = RC(); return t ? k(Fk, { children: e }) : e } function PC(e) { return Oe(function (n, r) { return k(k5, { children: k(e, { ...n, ref: r }) }) }) } var NS = "element", C5 = "collection", T5 = "collectionItemId", E5 = "pathVariables", _C = "framer/page-link,"; function FC(e) { return ce(e) && e.startsWith(`data:${_C}`) } function vg(e) { if (FC(e)) try { let t = new URL(e), n = t.pathname.substring(_C.length), r = t.searchParams, i = r.has(NS) ? r.get(NS) : void 0, o, s = r.get(C5), a = r.get(T5), l = r.get(E5); if (s && a && l) { let c = Object.fromEntries(new URLSearchParams(l).entries()); o = { collection: s, collectionItemId: a, pathVariables: c } } return { target: n === "none" ? null : n, element: i === "none" ? void 0 : i, collectionItem: o } } catch { return } } function R5(e, t, n) { var r; let i = t.getAttribute("data-framer-page-link-target"), o, s; if (i) { o = t.getAttribute("data-framer-page-link-element") ?? void 0; let l = t.getAttribute("data-framer-page-link-path-variables"); l && (s = Object.fromEntries(new URLSearchParams(l).entries())) } else { let l = t.getAttribute("href"); if (!l) return !1; let c = vg(l); if (!c || !c.target) return !1; i = c.target, o = c.element ?? void 0, s = (r = c.collectionItem) == null ? void 0 : r.pathVariables } let a = o ? t.dataset.framerSmoothScroll !== void 0 : void 0; return e(i, o, Object.assign({}, n, s), a), !0 } var P5 = 500, _5 = .9, F5 = 1.7, I5 = 4, L5 = 1 / 0, Qo = new WeakMap, Su = new Set, Zo = new Map; function M5() { var e; let t = Ne.connection || Ne.mozConnection || Ne.webkitConnection || {}, n = Ne.deviceMemory && Ne.deviceMemory > F5, r, i, o; function s() { r = t.effectiveType || "", i = t.saveData || r.includes("2g"), o = r === "3g" || n ? I5 : L5 } (e = t.addEventListener) == null || e.call(t, "change", s), s(); let a = new IntersectionObserver(u, { threshold: _5 }), l = 0; async function c(f, d) { if (i) return; let p = Zo.get(f); if (!p?.size || Su.has(f)) return; ++l, Su.add(f); let y = Mk(f).catch(() => { }); a.unobserve(d), Qo.delete(d); for (let g of p) a.unobserve(g), Qo.delete(g); p.clear(), Zo.delete(f), await y, --l } function u(f) { var d; for (let p of f) { let y = p.target, g = Qo.get(y); if (!g || Su.has(g)) { a.unobserve(y), Qo.delete(y); continue } let b = Zo.get(g), h = ((d = Zo.get(g)) == null ? void 0 : d.size) ?? 0; if (p.isIntersecting) { if (l >= o) continue; b ? b.add(y) : Zo.set(g, new Set([y])), setTimeout(c.bind(void 0, g, y), P5) } else b && b.delete(y), h <= 1 && Zo.delete(g) } } return (f, d) => { if (!Su.has(f)) return Qo.set(d, f), a.observe(d), () => { Qo.delete(d), a.unobserve(d) } } } var O5 = !ig || typeof IntersectionObserver > "u" ? null : M5(), wm = {}, ku = new WeakMap; function IC(e, t, n) { var r, i; let o = (i = (r = ku?.get(n ?? wm)) == null ? void 0 : r.get(e.collectionId)) == null ? void 0 : i.get(e.collectionItemId); if (o) return o; let s = ku.get(n ?? wm) ?? new Map; ku.set(n ?? wm, s); let a = s.get(e.collectionId) ?? new Map; s.set(e.collectionId, a); let l = new af(async () => { try { let c = t[e.collectionId]; if (!c) throw new Error(`Key not found in collection utils for collection id: "${e.collectionId}`); let u = await c(); if (!u) throw new Error("Collection does not contain utility functions"); return await u.getSlugByRecordId(e.collectionItemId, n ?? void 0) } catch (c) { console.warn(`Failed to resolve slug: ${c instanceof Error ? c.message : "Unknown error"}`); return } }); return a.set(e.collectionItemId, l), l } var D5 = "webPageId"; function ju(e) { return !!(e && typeof e == "object" && D5 in e) } function A5(e) { if (!e) return; let t = {}; for (let n in e.pathVariables) { let r = e.pathVariables[n]; r && (t[n] = r) } return t } function Wu(e) { if (!FC(e)) return e; let t = vg(e); if (!t) return; let { target: n, element: r, collectionItem: i } = t; if (n) return { webPageId: n, hash: r ?? void 0, pathVariables: A5(i) } } var LC = /:([a-z]\w*)/gi, V5 = ke(void 0); function MC() { var e; let t = V(V5), n = (e = Qa()) == null ? void 0 : e.pathVariables; return t || n } function OC(e, { webPageId: t, hash: n, pathVariables: r }, i) { if (t !== e.id || n) return !1; if (e.path && e.pathVariables) { let o = Object.assign({}, i, r); for (let [, s] of e.path.matchAll(LC)) if (!s || e.pathVariables[s] !== o[s]) return !1 } return !0 } function yg(e) { return e === void 0 ? !1 : !!(e.startsWith("#") || e.startsWith("/") || e.startsWith(".")) } function B5(e, t) { try { return !!new URL(e).protocol } catch { } return t } function bg(e, t) { return e !== void 0 ? e ? "_blank" : void 0 : t ? void 0 : "_blank" } function _u(e, t = void 0) { let n = yg(e), r = bg(t, n); return { href: B5(e, n) ? e : `https://${e}`, target: r, rel: n ? void 0 : "noopener" } } function DC(e, t, n, r, i) { return async o => { var s, a; if (o.metaKey) return; let l = gg(o.target); if (!l || l.getAttribute("target") === "_blank") return; o.preventDefault(); let c = (s = e.getRoute) == null ? void 0 : s.call(e, t); c && bk(c?.page) && c.page.preload(), (a = e.navigate) == null || a.call(e, t, n, r, i) } } function z5(e, t, n, r) { let i = []; function o(a) { if (!a || !n) return; let l = {}; for (let c in a) { let u = a[c]; $(u, "unresolvedSlug should be defined"); let f = IC(u, n, r), d = f.preload(); if (d) i.push(d); else { let p = f.read(); p && (l[c] = p) } } return l } let s = { path: o(e), hash: o(t) }; if (i.length) throw Promise.allSettled(i); return s } function $5(e, t, n, r, i, o, s, a) { var l; let c = { ...i, ...o, ...a?.path }, u = { ...i, ...s, ...a?.hash }, f = (l = e.getRoute) == null ? void 0 : l.call(e, n), d = Ju(f, { currentRoutePath: t?.path, currentPathVariables: t?.pathVariables, hash: r, pathVariables: c, hashVariables: u, preserveQueryParams: e.preserveQueryParams }), p = d.split("#", 2)[1]; return { routeId: n, route: f, href: d, elementId: p, pathVariables: c } } function N5(e, t, n) { if (!(!e.routes || !e.getRoute || !yg(t))) try { let [i, o] = t.split("#", 2); $(i !== void 0, "A href must have a defined pathname."); let [s] = i.split("?", 2); $(s !== void 0, "A href must have a defined pathname."); let { routeId: a, pathVariables: l } = Lk(e.routes, s), c = e.getRoute(a); if (c) { let u = Object.assign({}, n, l); return { routeId: a, route: c, href: t, elementId: o, pathVariables: u } } } catch { } } function H5(e, t, n, r, i) { let { webPageId: o, hash: s, pathVariables: a, hashVariables: l, unresolvedHashSlugs: c, unresolvedPathSlugs: u } = n, f = z5(u, c, e.collectionUtils, r); return $5(e, t, o, s, i, a, l, f) } function j5(e, t, n, r, i, o) { if (!r) return _u(e, t); let s = N5(n, e, i); if (!s) return _u(e, t); let { routeId: a, route: l, elementId: c, pathVariables: u } = s; if (!l) return _u(e, t); let f = Ju(l, { currentRoutePath: r.path, currentPathVariables: r.pathVariables, hash: c, pathVariables: u, preserveQueryParams: n.preserveQueryParams }), d = bg(t, !0); return { href: f, target: d, onClick: DC(n, a, c, u, o) } } function W5(e, t, n) { var r; if (ce(e)) { let o = yg(e); if (!t.routes || !t.getRoute || !n || !o) return; let [s] = e.split("#", 2); if (s === void 0) return; let [a] = s.split("?", 2); if (a === void 0) return; let { routeId: l } = Lk(t.routes, a); return t.getRoute(l) } let { webPageId: i } = e; return (r = t.getRoute) == null ? void 0 : r.call(t, i) } var rW = PC(Oe(({ children: e, href: t, openInNewTab: n, smoothScroll: r, ...i }, o) => { let s = cs(), a = Qa(), l = MC(), { activeLocale: c } = rg(), u = D(null), f = ae(() => { let y, g = h => { var m; if (h === null) { y?.(), y = void 0; return } let v = ju(t) ? t : Wu(t); if (!v) return; let w = W5(v, s, a); w && (y = (m = O5) == null ? void 0 : m(w, h)) }, b = Ht(e) && "ref" in e; return b && kC(e.ref) ? VS(e.ref, g) : b && Si(e.ref) ? a5(e.ref, g) : VS(u, g) }, [t, s, a, e]), d = sf(o), p = ae(() => { if (!t) return {}; let y = ju(t) ? t : Wu(t); if (!y) return {}; if (ce(y)) return j5(y, n, s, a, l, r); let { routeId: g, href: b, elementId: h, pathVariables: m } = H5(s, a, y, c, l), v = bg(n, !0); return { href: b, target: v, onClick: DC(s, g, h, m, r), "data-framer-page-link-current": a && OC(a, y, l) || void 0 } }, [t, s, c, l, n, a, r]); return d(e, { ...i, ...p, ref: f }) })); function U5(e, t, n, r) { let i = ju(e) ? e : Wu(e); if (!ju(i)) return ce(e) ? _u(e).href : void 0; if (!t.getRoute || !t.currentRouteId) return; let o = t.getRoute(t.currentRouteId), { webPageId: s, hash: a, pathVariables: l, hashVariables: c, unresolvedHashSlugs: u, unresolvedPathSlugs: f } = i, d = t.getRoute(s), p = f || u ? r?.(f, u) : void 0, y = Object.assign({}, t.currentPathVariables, n, l, p?.path), g = Object.assign({}, t.currentPathVariables, n, c, p?.hash); return Ju(d, { currentRoutePath: o?.path, currentPathVariables: t.currentPathVariables, hash: a, pathVariables: y, hashVariables: g, relative: !1, preserveQueryParams: t.preserveQueryParams }) } var G5 = x.createContext(void 0); function q5(e) { return new Promise((t, n) => { try { new URL(e); let r = new Image; r.onload = () => t(), r.onerror = n, r.src = e } catch (r) { n(r) } }) } function X5(e) { return typeof e == "object" && e !== null } function Y5(e, t) { if (t === "") return e; let n = t.split(/[.[\]]+/u).filter(i => i.length > 0), r = e; for (let i of n) { if (!X5(r)) return; r = r[i] } return r } function La(e) { return `${e.credentials}:${e.url}` } var K5 = { status: "loading", data: void 0 }; function Q5(e) { return ce(e) && !isNaN(Number(e)) } function Z5(e, t) { switch (e) { case "string": return ce(t) || Ve(t); case "color": return ce(t); case "boolean": return ef(t); case "number": return Ve(t) || Q5(t); case "link": case "image": return ce(t) && Vm(t); default: { let n = e; return !1 } } } function J5(e, t) { if (e.status === "loading") return t.fallbackValue; if (e.status === "error") throw e.error; let n = Y5(e.data, t.resultKeyPath); if (Je(n)) throw new Error(`Key '${t.resultKeyPath}' not found in response`); if (!Z5(t.resultOutputType, n)) throw new Error(`Resolved value '${n}' is not valid for type '${t.resultOutputType}'`); return n } function Vm(e) { try { return !!new URL(e).protocol } catch { } } function Sm(e, t) { if (le.current() === le.canvas) return !1; let n = t === 0 ? 500 : t * 1e3, r = Date.now(), i = e + n; return r >= i } var HS = () => { }, Or, Bm, Xi, Yi, Oa, yi, Fu = class { constructor() { T(this, "responseValues", new Map), tn(this, Or, new Map), tn(this, Bm, new Set), tn(this, Xi, new Map), tn(this, Yi, new Map), tn(this, Oa, new Map), tn(this, yi, new Map), T(this, "persistCache", k3(() => { let e = {}; for (let [t, n] of this.responseValues) { if (!n || n.status !== "success") continue; let r = fe(this, Xi).get(t); if (!r || r === 0) continue; let i = fe(this, Yi).get(t); i && (i && Sm(i, r) || (e[t] = [i, r, n.data])) } try { localStorage.setItem(Fu.cacheKey, JSON.stringify(e)) } catch { } }, 500)) } unmount() { for (let [e, t] of fe(this, yi)) clearInterval(t), fe(this, yi).delete(e) } stopQueryRefetching(e) { let t = La(e), n = fe(this, yi).get(t); n && (clearInterval(n), fe(this, yi).delete(t)) } startQueryRefetching(e) { let t = La(e), n = fe(this, yi).get(t), r = fe(this, Xi).get(t); if (n || !r) return; let i = ft.setInterval(() => { if (document.visibilityState === "hidden") return; let o = fe(this, Yi).get(t); !r || !o || this.fetchWithCache({ ...e, cacheDuration: r }) }, r); fe(this, yi).set(t, i) } hydrateCache() { try { let e = localStorage.getItem(Fu.cacheKey); if (!e) return; let t = JSON.parse(e); if (typeof t != "object") throw new Error("Invalid cache data"); for (let n in t) { let r = t[n]; if (!Array.isArray(r) || r.length !== 3) throw new Error("Invalid cache data"); let [i, o, s] = r; Sm(i, o) || (fe(this, Yi).set(n, i), fe(this, Xi).set(n, o), this.responseValues.set(n, { status: "success", data: s })) } } catch { try { localStorage.removeItem(Fu.cacheKey) } catch { } } } setResponseValue(e, t) { this.responseValues.set(e, t), this.persistCache(); let n = fe(this, Or).get(e); if (n) for (let r of n) r() } async prefetch(e) { if (!ki() || !Vm(e.url)) return; let t = La(e); fe(this, Bm).add(t), await this.fetchWithCache(e); let n = this.getValue(t); if (!n || n.status === "loading") throw new Error("Unexpected result status for prefetch"); let r = fe(this, Or).get(t); for (let o of r ?? []) o(); let i = J5(n, e); return e.resultOutputType === "image" && ce(i) && await q5(i).catch(HS), i } async fetchWithCache(e) { if (!ki()) return; let t = La(e), n = fe(this, Oa).get(t); if (n) return n; let r = fe(this, Yi).get(t), i = r && Sm(r, e.cacheDuration); if (this.responseValues.has(t) && !i) return; this.responseValues.get(t) || this.setResponseValue(t, K5); let a = (async () => { try { let l = await fetch(e.url, { method: "GET", headers: { "Content-Type": "application/json" }, credentials: e.credentials }); if (!l.ok) { this.setResponseValue(t, { status: "error", error: new Error("Invalid Response Status"), data: void 0 }); return } let c = await l.json(); this.setResponseValue(t, { status: "success", data: c }), fe(this, Yi).set(t, Date.now()) } catch (l) { this.setResponseValue(t, { status: "error", error: l, data: void 0 }) } })(); return fe(this, Oa).set(t, a), a.finally(() => { fe(this, Oa).delete(t) }), a } getValue(e) { return this.responseValues.get(e) } subscribe(e, t) { let { url: n, cacheDuration: r } = e; if (!Vm(n)) return HS; let i = La(e), o = fe(this, Xi).get(i); (!o || r < o) && fe(this, Xi).set(i, r), this.startQueryRefetching(e), this.fetchWithCache(e); let s = fe(this, Or).get(i) ?? new Set; return s.add(t), fe(this, Or).set(i, s), () => { let a = fe(this, Or).get(i); a && (a.delete(t), a.size === 0 && fe(this, Or).delete(i), fe(this, Or).size === 0 && this.stopQueryRefetching(e)) } } }, AC = Fu; Or = new WeakMap; Bm = new WeakMap; Xi = new WeakMap; Yi = new WeakMap; Oa = new WeakMap; yi = new WeakMap; T(AC, "cacheKey", "framer-fetch-client-cache"); var e4 = ke(void 0), t4 = ke(!0), n4 = ({ children: e, client: t }) => { let [n] = Ye(() => t ?? new AC), [r, i] = Ye(!0); return z(() => (n.hydrateCache(), yr(() => { i(!1) }), () => n.unmount()), [n]), k(t4.Provider, { value: r, children: k(e4.Provider, { value: n, children: e }) }) }, r4, i4, o4; r4 = new WeakMap; i4 = new WeakMap; o4 = new WeakMap; function cW({ RootComponent: e, isWebsite: t, routeId: n, framerSiteId: r, pathVariables: i, routes: o, collectionUtils: s, notFoundPage: a, isReducedMotion: l = !1, includeDataObserver: c = !1, localeId: u, locales: f, preserveQueryParams: d }) { let { enableAsyncURLUpdates: p } = RC(); if (x.useEffect(() => { t || Vk.start() }, []), t) return k(J0, { reducedMotion: l ? "user" : "never", children: k(g5, { children: k(G5.Provider, { value: r, children: k(n4, { children: k(nO, { initialRoute: n, initialPathVariables: i, initialLocaleId: u, routes: o, collectionUtils: s, notFoundPage: a, locales: f, defaultPageStyle: { minHeight: "100vh", width: "auto" }, preserveQueryParams: d, enableAsyncURLUpdates: p }) }) }) }) }); { let y = c ? R3 : x.Fragment; return k(y, { children: k(qM, { routes: o, children: k(S3, { children: x.isValidElement(e) ? e : x.createElement(e, { key: n }) }) }) }) } } function s4(e, t, n) { let r = qn.map(e, i => Ht(i) ? vr(i, t) : i); return n ? r : k(He, { children: r }) } var VC = x.createContext(void 0), BC = "ssr-variant"; function jS(e, t, n, r, i, o, s, a) { let l = x.Children.toArray(t), c = l[0]; if (l.length !== 1 || !x.isValidElement(c)) return console.warn("PropertyOverrides: expected exactly one React element for a child", t), s(t, n); let u = [], f = []; for (let [g] of Object.entries(r)) { if (g === i) continue; let b = e[g]; if (!b || !l4(c.props, b)) { f.push(g); continue } let h = WS([g], o); h.length && u.push({ variants: h, propOverrides: b }) } if (u.length === 0) return s(c, n); let d = [i, ...f], p = WS(d, o); p.length && u.unshift({ variants: p }); let y = []; for (let { variants: g, propOverrides: b } of u) { if (a && !g.includes(a)) continue; let h = g.join("+"), m = k(VC.Provider, { value: new Set(g), children: s(c, b ? { ...n, ...b } : n) }, h), v = a4(g, o, r); v.length ? ($(u.length > 1, "Must branch out when there are hiddenClassNames"), m = k("div", { className: `${BC} ${v.join(" ")}`, children: m }, h)) : $(u.length === 1, "Cannot branch out when hiddenClassNames is empty"), y.push(m) } return $(!a || y.length === 1, "Must render exactly one branch when activeVariantId is given"), y } function zC(e) { return e.split("-")[2] } function a4(e, t, n) { let r = []; for (let [i, o] of Object.entries(n)) { let s = t && !t.has(i); e.includes(i) || s || r.push(`hidden-${zC(o)}`) } return r } function WS(e, t) { return t ? e.filter(n => t.has(n)) : e } function l4(e, t) { for (let n of Object.keys(t)) if (!qe(e[n], t[n], !0)) return !0; return !1 } function c4(e, t, n) { return !n || !e ? t : { ...t, ...n[e] } } var u4 = x.forwardRef(function ({ breakpoint: t, overrides: n, children: r, ...i }, o) { let s = sf(o), a = x.useContext(VC), l = WM(), c = Qt(() => l.current ? ki() ? 1 : 2 : 0), u = x.useContext(S5); if (!u) return console.warn("PropertyOverrides is missing GeneratedComponentContext"), s(r, i); let { primaryVariantId: f, variantClassNames: d } = u; switch (c) { case 0: return s(r, c4(t, i, n)); case 1: return jS(n, r, i, d, f, a, s, t); case 2: return jS(n, r, i, d, f, a, s4, void 0); default: xe(c) } }), hW = (() => TC(u4, `.${BC} { display: contents }`, "PropertyOverrides"))(), mW = PC(Oe(function ({ links: t, children: n, ...r }, i) { let o = cs(), { activeLocale: s } = rg(), a = sf(i), l = [], c = t.map(f => U5(f.href, o, f.implicitPathVariables, (d, p) => { function y(g) { let b = {}; for (let h in g) { let m = g[h]; $(o.collectionUtils, "collectionUtils should be defined"), $(m, "unresolvedSlug be defined"); let v = IC(m, o.collectionUtils, s), w = v.preload(); if (w) l.push(w); else { let C = v.read(); C && (b[h] = C) } } return b } return { path: y(d), hash: y(p) } })); if (l.length > 0) throw Promise.allSettled(l); let u = n(c); return a(u, r) })); var f4 = Jn(ZL(), 1); function d4(e) { return { trace(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.trace(...t) }, debug(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.debug(...t) }, info(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.info(...t) }, warn(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.warn(...t) }, error(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.error(...t) } } } function h4(e) { return xg(e) || m4(e) } function p4(e) { return tl(e) && e.every(Te) } function $C(e) { return Te(e) && Si(e.read) && Si(e.preload) } function xg(e) { return p4(e) || $C(e) } function lf(e) { return Te(e) && Te(e.schema) } function wg(e) { return Te(e) && Te(e.collectionByLocaleId) } function m4(e) { return lf(e) || wg(e) } async function US(e, t) { return $C(e) ? (await e.preload(t), e.read(t)) : e } var NC = class { constructor(e, t) { this.collection = e, this.locale = t, T(this, "schema"), T(this, "indexes", []); let n = aA(e); $(n, "Collection does not have properties"); let r = { id: { type: "string", isNullable: !1 } }, i = Object.entries(n); for (let [o, s] of i) s && (r[o] = { type: s.type, isNullable: !0 }); this.schema = r } getDatabaseItem(e, t) { let n = {}; for (let r in this.schema) { let i = e[r]; if (os(i)) continue; let o = this.schema[r]; Je(o) || ($(o.type !== "unknown", "Invalid definition type"), n[r] = { type: o.type, value: i }) } return { pointer: t, data: n } } async resolveRichText(e) { if (af.is(e)) { let t = e.preload(); return t && await t, e.read() } return e } async scanItems() { return (await US(this.collection, this.locale)).map((t, n) => { let r = String(n); return this.getDatabaseItem(t, r) }) } async resolveItems(e) { let t = await US(this.collection, this.locale); return e.map(n => { let r = Number(n), i = t[r]; return $(i, "Can't find collection item"), this.getDatabaseItem(i, n) }) } compareItems(e, t) { return Number(e.pointer) - Number(t.pointer) } }; function wt(e) { switch (e?.type) { case "boolean": return e.value; case "number": case "string": return !!e.value }return !1 } function g4(e) { switch (e?.type) { case "color": return e.value }return null } function Sg(e) { switch (e?.type) { case "date": return e.value; case "number": case "string": { let t = new Date(e.value); return ag(t) ? t.toISOString() : null } }return null } function v4(e) { switch (e?.type) { case "enum": case "string": return e.value }return null } function y4(e) { switch (e?.type) { case "file": return e.value }return null } function b4(e) { switch (e?.type) { case "responsiveimage": return e.value }return null } function x4(e) { switch (e?.type) { case "link": return e.value; case "string": try { let { protocol: t } = new URL(e.value); return t === "http:" || t === "https:" ? e.value : null } catch { return null } }return null } function ol(e) { switch (e?.type) { case "number": case "string": { let t = Number(e.value); return Number.isFinite(t) ? t : null } }return null } function w4(e) { switch (e?.type) { case "richtext": return e.value }return null } function zr(e) { switch (e?.type) { case "string": case "number": return String(e.value) }return null } function S4(e) { switch (e?.type) { case "multicollectionreference": return e.value }return null } var Ee = { cast(e, t) { switch (t.type) { case "boolean": { let n = wt(e); return oe(n) ? null : { type: "boolean", value: n } } case "color": { let n = g4(e); return oe(n) ? null : { type: "color", value: n } } case "date": { let n = Sg(e); return oe(n) ? null : { type: "date", value: n } } case "enum": { let n = v4(e); return oe(n) ? null : { type: "enum", value: n } } case "file": { let n = y4(e); return oe(n) ? null : { type: "file", value: n } } case "link": { let n = x4(e); return oe(n) ? null : { type: "link", value: n } } case "number": { let n = ol(e); return oe(n) ? null : { type: "number", value: n } } case "responsiveimage": { let n = b4(e); return oe(n) ? null : { type: "responsiveimage", value: n } } case "richtext": { let n = w4(e); return oe(n) ? null : { type: "richtext", value: n } } case "string": { let n = zr(e); return oe(n) ? null : { type: "string", value: n } } case "multicollectionreference": { let n = S4(e); return oe(n) ? null : { type: "multicollectionreference", value: n } } case "unknown": return e; default: xe(t, "Unsupported cast") } }, equal(e, t, n) { return e?.type !== t?.type ? !1 : Ma(e, t, n) === 0 }, lessThan(e, t, n) { return e?.type !== t?.type ? !1 : Ma(e, t, n) < 0 }, lessThanOrEqual(e, t, n) { return e?.type !== t?.type ? !1 : Ma(e, t, n) <= 0 }, greaterThan(e, t, n) { return e?.type !== t?.type ? !1 : Ma(e, t, n) > 0 }, greaterThanOrEqual(e, t, n) { return e?.type !== t?.type ? !1 : Ma(e, t, n) >= 0 }, in(e, t) { return e?.type !== "string" || t?.type !== "multicollectionreference" ? !1 : t.value.includes(e.value) }, stringify(e) { if (e === null) return "null"; switch (e.type) { case "boolean": case "number": return String(e.value); case "string": return `'${e.value}'`; case "enum": return `'${e.value}' /* Enum */`; case "color": return `'${e.value}' /* Color */`; case "date": return `'${e.value}' /* Date */`; case "richtext": return "RichText"; case "responsiveimage": return "ResponsiveImage"; case "file": return "File"; case "link": return ce(e.value) ? `'${e.value}' /* Link */` : "Link"; case "multicollectionreference": return `[${e.value.map(t => `'${t}'`).join(", ")}]`; default: xe(e) } } }; function Ma(e, t, n) { if (oe(e) || oe(t)) return $(e === t), 0; switch (e.type) { case "boolean": return $(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "color": return $(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "date": { $(e.type === t.type); let r = new Date(e.value), i = new Date(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "enum": return $(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "file": return $(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "responsiveimage": { $(e.type === t.type); let r = JSON.stringify(e.value), i = JSON.stringify(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "link": { $(e.type === t.type); let r = JSON.stringify(e.value), i = JSON.stringify(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "number": return $(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "richtext": { $(e.type === t.type); let r = e.value, i = t.value; return r < i ? -1 : r > i ? 1 : 0 } case "string": { $(e.type === t.type); let r = e.value, i = t.value; return n.type === 0 && (r = e.value.toLowerCase(), i = t.value.toLowerCase()), r < i ? -1 : r > i ? 1 : 0 } case "multicollectionreference": { $(e.type === t.type); for (let r = 0; r < Math.max(e.value.length, t.value.length); r++) { let i = e.value[r], o = t.value[r]; if (i === void 0) return -1; if (o === void 0) return 1; if (i < o) return -1; if (i > o) return 1 } return 0 } default: xe(e) } } var zm = "index", It = class { static from(e, t) { return dr(e, t, void 0) } }, St = class extends It { constructor(e, t, n) { super(), this.schema = e, this.name = t, this.collection = n, T(this, "definition"), t === zm ? this.definition = { type: "number", isNullable: !1 } : this.definition = e[t] ?? null } stringify() { return this.name } equals(e) { return e instanceof St && qe(this.definition, e.definition) && qe(e.name, this.name) && qe(e.collection, this.collection) } evaluate(e) { let t = this.name; if (Je(e) || t === zm) throw new Error(`Can't evaluate identifier: ${t}`); if (this.collection) { let n = `${this.collection}_${t}`; return e.data[n] ?? e.data[t] ?? null } return e.data[t] ?? null } canEvaluate() { return !1 } }, _e = class extends It { constructor(e, t) { super(), this.definition = e, this.value = t } stringify() { return Ee.stringify(this.value) } static fromNull() { return new _e(null, null) } static fromBoolean(e) { return new _e({ type: "boolean", isNullable: oe(e) }, oe(e) ? null : { type: "boolean", value: e }) } static fromDate(e) { return new _e({ type: "date", isNullable: oe(e) }, oe(e) ? null : { type: "date", value: e }) } static fromEnum(e) { return new _e({ type: "enum", isNullable: oe(e) }, oe(e) ? null : { type: "enum", value: e }) } static fromNumber(e) { return new _e({ type: "number", isNullable: oe(e) }, oe(e) ? null : { type: "number", value: e }) } static fromString(e) { return new _e({ type: "string", isNullable: oe(e) }, oe(e) ? null : { type: "string", value: e }) } static fromMultiCollectionReference(e) { return new _e({ type: "multicollectionreference", isNullable: oe(e) }, oe(e) ? null : { type: "multicollectionreference", value: e }) } equals(e) { return e instanceof _e && qe(this.definition, e.definition) && qe(e.value, this.value) } evaluate() { return this.value } canEvaluate() { return !0 } }, sl = class extends It { constructor(e) { super(), this.argumentExpressions = e, T(this, "collation", { type: 0 }) } getArgumentExpression(e) { let t = this.argumentExpressions[e]; if (Je(t)) throw new Error("Missing argument in function call"); return t } equals(e) { return e instanceof sl && qe(this.constructor, e.constructor) && qe(this.argumentExpressions, e.argumentExpressions) } canEvaluate() { return this.argumentExpressions.every(e => e.canEvaluate()) } }, cf = class extends sl { constructor() { super(...arguments), T(this, "definition", cf.getDefinition()), T(this, "sourceExpression", this.getArgumentExpression(0)), T(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `CONTAINS(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (oe(e) || e.type !== "string" || oe(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.includes(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, uf = class extends sl { constructor() { super(...arguments), T(this, "definition", uf.getDefinition()), T(this, "sourceExpression", this.getArgumentExpression(0)), T(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `STARTS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (oe(e) || e.type !== "string" || oe(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.startsWith(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, ff = class extends sl { constructor() { super(...arguments), T(this, "definition", ff.getDefinition()), T(this, "sourceExpression", this.getArgumentExpression(0)), T(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `ENDS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (oe(e) || e.type !== "string" || oe(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.endsWith(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, Uu = class extends It { constructor(e, t, n) { super(), this.valueExpression = e, this.conditions = t, this.elseExpression = n, T(this, "definition"), T(this, "collation", { type: 0 }); let r = []; for (let { thenExpression: i } of t) r.push(i.definition); n && r.push(n.definition), this.definition = Uu.getDefinition(r) } static getDefinition(e) { let t = null, n = !1; for (let r of e) { if (t ?? (t = r), t && r && t.type !== r.type) throw new Error("Incompatible types in CASE expression"); n || (n = r?.isNullable ?? !0) } return t ? { type: t.type, isNullable: n } : null } stringify() { let e = "CASE"; this.valueExpression && (e += ` ${this.valueExpression.stringify()}`); for (let { whenExpression: t, thenExpression: n } of this.conditions) e += ` WHEN ${t.stringify()} THEN ${n.stringify()}`; return this.elseExpression && (e += ` ELSE ${this.elseExpression.stringify()}`), e += " END", e } equals(e) { return e instanceof Uu && qe(this.valueExpression, e.valueExpression) && qe(this.conditions, e.conditions) && qe(this.elseExpression, e.elseExpression) } evaluate(e) { var t, n; let r = ((t = this.valueExpression) == null ? void 0 : t.evaluate(e)) ?? null; for (let { whenExpression: i, thenExpression: o } of this.conditions) { let s = i.evaluate(e); if (this.valueExpression ? Ee.equal(s, r, this.collation) : wt(s)) return o.evaluate(e) } return ((n = this.elseExpression) == null ? void 0 : n.evaluate(e)) ?? null } canEvaluate() { let e = []; this.valueExpression && e.push(this.valueExpression); for (let t of this.conditions) e.push(t.whenExpression), e.push(t.thenExpression); return this.elseExpression && e.push(this.elseExpression), e.every(t => t.canEvaluate()) } }, k4 = class { constructor(e, t) { this.whenExpression = e, this.thenExpression = t } }, HC = class extends It { constructor(e) { super(), this.valueExpression = e } equals(e) { return e instanceof HC && qe(this.constructor, e.constructor) && qe(this.valueExpression, e.valueExpression) } canEvaluate() { return this.valueExpression.canEvaluate() } }, Wa = class extends HC { constructor() { super(...arguments), T(this, "definition", Wa.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `NOT ${this.valueExpression.stringify()}` } evaluate(e) { let t = this.valueExpression.evaluate(e); return { type: "boolean", value: !wt(t) } } }, Ua = class extends It { constructor(e) { super(), this.operandExpressions = e, T(this, "definition", Ua.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return this.operandExpressions.map(e => e.stringify()).join(" AND ") } equals(e) { return e instanceof Ua && qe(this.constructor, e.constructor) && qe(this.operandExpressions, e.operandExpressions) } canEvaluate() { return this.operandExpressions.every(e => e.canEvaluate()) } }, Ji = class extends Ua { constructor() { super(...arguments), T(this, "operator", "AND") } evaluate(e) { return { type: "boolean", value: this.operandExpressions.every(n => { let r = n.evaluate(e); return wt(r) }) } } }, Aa = class extends Ua { constructor() { super(...arguments), T(this, "operator", "OR") } evaluate(e) { return { type: "boolean", value: this.operandExpressions.some(n => { let r = n.evaluate(e); return wt(r) }) } } }, Hn = class extends It { constructor(e, t) { super(), this.leftExpression = e, this.rightExpression = t, T(this, "definition", Hn.getDefinition()), T(this, "collation", { type: 0 }) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `${this.leftExpression.stringify()} ${this.operator} ${this.rightExpression.stringify()}` } equals(e) { return e instanceof Hn && qe(this.constructor, e.constructor) && qe(this.leftExpression, e.leftExpression) && qe(this.rightExpression, e.rightExpression) } canEvaluate() { return this.leftExpression.canEvaluate() && this.rightExpression.canEvaluate() } }, ss = class extends Hn { constructor() { super(...arguments), T(this, "operator", "=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Ee.equal(t, n, this.collation) } } }, as = class extends Hn { constructor() { super(...arguments), T(this, "operator", "!=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: !Ee.equal(t, n, this.collation) } } }, Ga = class extends Hn { constructor() { super(...arguments), T(this, "operator", "<") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Ee.lessThan(t, n, this.collation) } } }, qa = class extends Hn { constructor() { super(...arguments), T(this, "operator", "<=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Ee.lessThanOrEqual(t, n, this.collation) } } }, Xa = class extends Hn { constructor() { super(...arguments), T(this, "operator", ">") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Ee.greaterThan(t, n, this.collation) } } }, Ya = class extends Hn { constructor() { super(...arguments), T(this, "operator", ">=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Ee.greaterThanOrEqual(t, n, this.collation) } } }, C4 = class extends Hn { constructor() { super(...arguments), T(this, "operator", "in") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Ee.in(t, n) } } }, al = class extends It { constructor(e) { super(), this.valueExpression = e } stringify() { return `CAST(${this.valueExpression.stringify()} AS ${this.dataType})` } equals(e) { return e instanceof al && qe(this.constructor, e.constructor) && qe(this.valueExpression, e.valueExpression) } canEvaluate() { return this.valueExpression.canEvaluate() } }, df = class extends al { constructor() { super(...arguments), T(this, "dataType", "BOOLEAN"), T(this, "definition", df.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } evaluate(e) { let t = this.valueExpression.evaluate(e); return { type: "boolean", value: wt(t) } } }, kg = class extends al { constructor() { super(...arguments), T(this, "dataType", "DATE"), T(this, "definition", kg.getDefinition()) } static getDefinition() { return { type: "date", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = Sg(t); return oe(n) ? null : { type: "date", value: n } } }, Cg = class extends al { constructor() { super(...arguments), T(this, "dataType", "NUMBER"), T(this, "definition", Cg.getDefinition()) } static getDefinition() { return { type: "number", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = ol(t); return oe(n) ? null : { type: "number", value: n } } }, Tg = class extends al { constructor() { super(...arguments), T(this, "dataType", "STRING"), T(this, "definition", Tg.getDefinition()) } static getDefinition() { return { type: "string", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = zr(t); return oe(n) ? null : { type: "string", value: n } } }; function dr(e, t, n) { let r = T4(e, t, n), i = r instanceof _e; if (r.canEvaluate() && !i) { let o = r.evaluate(); return new _e(r.definition, o) } return r } function T4(e, t, n) { switch (e.type) { case "Identifier": return E4(e, t); case "LiteralValue": return R4(e, n); case "FunctionCall": return _4(e, t); case "Case": return F4(e, t, n); case "UnaryOperation": return I4(e, t); case "BinaryOperation": return M4(e, t); case "TypeCast": return j4(e, t); default: throw new Error(`Unsupported expression: ${JSON.stringify(e)}`) } } function E4(e, t) { return new St(t, e.name, e.collection) } function R4(e, t) { var n, r; let i = P4(e.value); switch (t?.type) { case "boolean": { let o = wt(i.value); return _e.fromBoolean(o) } case "date": { let o = Sg(i.value); return _e.fromDate(o) } case "enum": return ((n = i.value) == null ? void 0 : n.type) === "string" ? _e.fromEnum(i.value.value) : i; case "number": { let o = ol(i.value); return _e.fromNumber(o) } case "string": { let o = zr(i.value); return _e.fromString(o) } case "multicollectionreference": if (((r = i.value) == null ? void 0 : r.type) === "multicollectionreference") return _e.fromMultiCollectionReference(i.value.value) }return i } function P4(e) { if (ef(e)) return _e.fromBoolean(e); if (ag(e)) { let t = e.toISOString(); return _e.fromDate(t) } return Ve(e) ? _e.fromNumber(e) : ce(e) ? _e.fromString(e) : tl(e) && e.every(ce) ? _e.fromMultiCollectionReference(e) : _e.fromNull() } function _4(e, t) { let n = e.arguments.map(r => dr(r, t, void 0)); switch (e.functionName) { case "CONTAINS": return new cf(n); case "STARTS_WITH": return new uf(n); case "ENDS_WITH": return new ff(n); default: throw new Error(`Unsupported function name: ${e.functionName}`) } } function F4(e, t, n) { let r = e.value && dr(e.value, t, void 0), i = e.value && Ka(e.value, t), o = e.conditions.map(a => { let l = dr(a.when, t, i), c = dr(a.then, t, n); return new k4(l, c) }), s = e.else && dr(e.else, t, n); return new Uu(r, o, s) } function I4(e, t) { let n = dr(e.value, t, void 0); switch (e.operator) { case "not": return $m(n); default: throw new Error(`Unsupported unary operator: ${e.operator}`) } } function $m(e) { var t; if (e instanceof Wa) { let n = e.valueExpression; return ((t = n.definition) == null ? void 0 : t.type) === "boolean" ? n : new df(n) } if (e instanceof ss) { let { leftExpression: n, rightExpression: r } = e; return new as(n, r) } if (e instanceof as) { let { leftExpression: n, rightExpression: r } = e; return new ss(n, r) } if (e instanceof Ga) { let { leftExpression: n, rightExpression: r } = e; return new Ya(n, r) } if (e instanceof qa) { let { leftExpression: n, rightExpression: r } = e; return new Xa(n, r) } if (e instanceof Xa) { let { leftExpression: n, rightExpression: r } = e; return new qa(n, r) } if (e instanceof Ya) { let { leftExpression: n, rightExpression: r } = e; return new Ga(n, r) } if (e instanceof Ji) { let { operandExpressions: n } = e, r = n.map($m); return new Aa(r) } if (e instanceof Ji) { let { operandExpressions: n } = e, r = n.map($m); return new Ji(r) } return new Wa(e) } function L4(e, t) { if (e.operator !== "in" && e.operator !== "and" && e.operator !== "or") return Ka(e.left, t) || Ka(e.right, t) } function M4(e, t) { let n = L4(e, t), r = dr(e.left, t, n), i = dr(e.right, t, n); switch (e.operator) { case "and": return O4(r, i); case "or": return D4(r, i); case "==": return A4(r, i); case "!=": return V4(r, i); case "<": return B4(r, i); case "<=": return z4(r, i); case ">": return $4(r, i); case ">=": return N4(r, i); case "in": return H4(r, i); default: throw new Error(`Unsupported binary operator: ${e.operator}`) } } function O4(e, t) { let n = []; return e instanceof Ji ? n.push(...e.operandExpressions) : n.push(e), t instanceof Ji ? n.push(...t.operandExpressions) : n.push(t), new Ji(n) } function D4(e, t) { let n = []; return e instanceof Aa ? n.push(...e.operandExpressions) : n.push(e), t instanceof Aa ? n.push(...t.operandExpressions) : n.push(t), new Aa(n) } function A4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new ss(t, e) : new ss(e, t) } function V4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new as(t, e) : new as(e, t) } function B4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new Xa(t, e) : new Ga(e, t) } function z4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new Ya(t, e) : new qa(e, t) } function $4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new Ga(t, e) : new Xa(e, t) } function N4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new qa(t, e) : new Ya(e, t) } function H4(e, t) { return new C4(e, t) } function j4(e, t) { let n = dr(e.value, t, void 0); switch (e.dataType) { case "BOOLEAN": return W4(n); case "DATE": return U4(n); case "NUMBER": return G4(n); case "STRING": return q4(n); default: throw new Error(`Unsupported data type: ${e.dataType}`) } } function W4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "boolean" ? e : new df(e) } function U4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "date" ? e : new kg(e) } function G4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "number" ? e : new Cg(e) } function q4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "string" ? e : new Tg(e) } function Ka(e, t) { switch (e.type) { case "Identifier": return X4(e, t); case "LiteralValue": return; case "FunctionCall": return Y4(e); case "Case": return K4(e, t); case "UnaryOperation": return Q4(e); case "BinaryOperation": return Z4(e); case "TypeCast": return J4(e); default: throw new Error(`Unsupported expression: ${JSON.stringify(e)}`) } } function X4(e, t) { return t[e.name] } function Y4(e) { switch (e.functionName) { case "CONTAINS": return cf.getDefinition(); case "STARTS_WITH": return uf.getDefinition(); case "ENDS_WITH": return ff.getDefinition(); default: throw new Error(`Unsupported function name: ${e.functionName}`) } } function K4(e, t) { let n = []; for (let r of e.conditions) { let i = Ka(r.then, t); Je(i) || n.push(i) } if (e.else) { let r = Ka(e.else, t); Je(r) || n.push(r) } return Uu.getDefinition(n) ?? void 0 } function Q4(e) { switch (e.operator) { case "not": return Wa.getDefinition(); default: throw new Error(`Unsupported unary operator: ${e.operator}`) } } function Z4(e) { switch (e.operator) { case "and": case "or": return Ua.getDefinition(); case "==": case "!=": case "<": case "<=": case ">": case ">=": return Hn.getDefinition(); default: throw new Error(`Unsupported binary operator: ${e.operator}`) } } function J4(e) { switch (e.dataType) { case "BOOLEAN": return df.getDefinition(); case "DATE": return kg.getDefinition(); case "NUMBER": return Cg.getDefinition(); case "STRING": return Tg.getDefinition(); default: throw new Error(`Unsupported data type: ${e.dataType}`) } } function $r(e, t) { return `(self: ${e}ms${t ? `, total: ${t}ms` : ""})` } function jn(e) { return `(items: ${e})` } var Nr = class { constructor() { T(this, "executionTime", 0), T(this, "itemCount", 0) } async execute() { let e = performance.now(), t = await this._execute(); return this.executionTime = performance.now() - e, this.itemCount = t.length, t } }, jC = class extends Nr { constructor(e, t) { super(), this.collection = e, this.alias = t } inspect() { return { label: `ScanCollectionPlan ${$r(this.executionTime)} ${jn(this.itemCount)}` } } async _execute() { let e = await this.collection.scanItems(); return Je(this.alias) ? e : e.map(t => { let n = { ...t.data }, r = Object.entries(n); for (let [i, o] of r) n[`${this.alias}_${i}`] = o; return { pointer: t.pointer, data: n } }) } }, eB = class extends Nr { constructor(e, t, n) { super(), this.leftPlan = e, this.rightPlan = t, this.constraint = n } inspect() { let e = Math.max(this.leftPlan.executionTime ?? 0, this.rightPlan.executionTime ?? 0); return { label: `LeftJoinPlan ${$r(this.executionTime - e, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.leftPlan.inspect(), this.rightPlan.inspect()] } } async _execute() { var e; let t = await this.leftPlan.execute(), n = await this.rightPlan.execute(), r = []; for (let i of t) { let o = !1; for (let s of n) { let a = { pointer: i.pointer, data: { ...i.data, ...s.data } }; (e = this.constraint.evaluate(a)) != null && e.value && (r.push(a), o = !0) } o || r.push(i) } return r } }, Vr = class extends Nr { constructor(e, t) { super(), this.index = e, this.query = t } inspect() { let e = [], t = n => { switch (n.type) { case "All": return n.type; case "Equals": case "NotEquals": case "LessThan": case "GreaterThan": case "Contains": case "StartsWith": case "EndsWith": return `${n.type} ${Ee.stringify(n.value)}`; default: xe(n) } }; for (let n = 0; n < this.index.fields.length; n++) { let r = this.index.fields[n], i = this.query[n]; !r || r.type !== "Identifier" || !i || i.type === "All" || e.push(`${r.name} ${t(i)}`) } return { label: `LookupIndexPlan(${e.join(", ")}) ${$r(this.executionTime)} ${jn(this.itemCount)}` } } async _execute() { return this.index.lookupItems(this.query) } }, tB = class extends Nr { constructor(e) { super(), this.childPlans = e } inspect() { let e = Math.max(...this.childPlans.map(t => t.executionTime ?? 0)); return { label: `UnionPlan ${$r(this.executionTime - e, this.executionTime)} ${jn(this.itemCount)}`, nodes: this.childPlans.map(t => t.inspect()) } } async _execute() { let e = await Promise.all(this.childPlans.map(async n => { let r = await n.execute(); return new Gu(r) })), t; for (let n of e) t ? t = t.union(n) : t = n; return t?.items() ?? [] } }, nB = class extends Nr { constructor(e) { super(), this.childPlans = e } inspect() { let e = Math.max(...this.childPlans.map(t => t.executionTime ?? 0)); return { label: `IntersectionPlan ${$r(this.executionTime - e, this.executionTime)} ${jn(this.itemCount)} ${jn(this.itemCount)}`, nodes: this.childPlans.map(t => t.inspect()) } } async _execute() { let e = await Promise.all(this.childPlans.map(async n => { let r = await n.execute(); return new Gu(r) })), t; for (let n of e) t ? t = t.intersection(n) : t = n; return t?.items() ?? [] } }, rB = class extends Nr { constructor(e, t, n, r) { super(), this.childPlan = e, this.collection = t, this.richTextResolver = n, this.select = r } inspect() { return { label: `ResolveItemsPlan ${$r(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { let e = await this.childPlan.execute(), t = e.map(n => n.pointer); for (let n of e) for (let r of this.select) { if (r.type !== "Identifier") continue; let i = n.data[r.name]; i?.type === "richtext" && this.richTextResolver.resolve(r.name, i.value) } return this.collection.resolveItems(t) } }, WC = class extends Nr { constructor(e, t) { super(), this.childPlan = e, this.filterExpression = t } inspect() { return { label: `FilterItemsPlan(${this.filterExpression.stringify()}) ${$r(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { return (await this.childPlan.execute()).filter(t => { let n = this.filterExpression.evaluate(t); return wt(n) }) } }, iB = class extends Nr { constructor(e, t, n) { super(), this.childPlan = e, this.orderExpressions = t, this.collection = n } inspect() { return { label: `SortItemsPlan(${this.orderExpressions.map(t => `${t.expression.stringify()} ${t.direction.toUpperCase()}`).join(", ")}) ${$r(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { return (await this.childPlan.execute()).sort((t, n) => { let r = { ...t, data: {} }, i = { ...n, data: {} }; for (let { expression: o, direction: s, collation: a } of this.orderExpressions) { let l = s === "asc"; if (o instanceof St && o.name === zm) { let f = this.collection.compareItems(r, i); return l ? f : -f } let c = o.evaluate(t), u = o.evaluate(n); if (!Ee.equal(c, u, a)) { if (Ee.lessThan(c, u, a) || os(c)) return l ? -1 : 1; if (Ee.greaterThan(c, u, a) || os(u)) return l ? 1 : -1; throw new Error("Invalid comparison result.") } } return this.collection.compareItems(r, i) }) } }, oB = class { constructor(e, t, n) { this.expression = e, this.direction = t, this.collation = n } }, sB = class extends Nr { constructor(e, t, n) { super(), this.childPlan = e, this.offsetExpression = t, this.limitExpression = n } inspect() { var e, t; return { label: `SliceItemsPlan(LIMIT ${((e = this.limitExpression) == null ? void 0 : e.stringify()) ?? "Infinity"}, OFFSET ${((t = this.offsetExpression) == null ? void 0 : t.stringify()) ?? "0"}) ${$r(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } getOffset() { var e; let t = (e = this.offsetExpression) == null ? void 0 : e.evaluate(); if (!(os(t) || t.type !== "number")) return t.value } getLimit() { var e; let t = (e = this.limitExpression) == null ? void 0 : e.evaluate(); if (!(os(t) || t.type !== "number")) return t.value } async _execute() { let e = await this.childPlan.execute(), t = this.getOffset() ?? 0, n = this.getLimit() ?? 1 / 0; return e.slice(t, t + n) } }, Gu = class extends Map { constructor(e = []) { super(); for (let t of e) this.set(t.pointer, t) } union(e) { let t = new Gu; for (let [n, r] of this) t.set(n, r); for (let [n, r] of e) t.set(n, r); return t } intersection(e) { let t = new Gu; for (let [n, r] of this) e.has(n) && t.set(n, r); return t } items() { return [...this.values()] } }, aB = class { constructor(e) { this.collections = e, T(this, "cache", new Map) } resolve(e, t) { let n = this.cache.get(e) ?? new Map; this.cache.set(e, n); let r = n.get(t); if (r) return r; for (let i of this.collections) if (e in i.schema) { let o = i.resolveRichText(t); return n.set(t, o), o } throw new Error(`Rich text field not found: ${e}`) } }; function lB(e) { return Te(e) && Si(e.getHash) } function he(e, ...t) { let n = t.map(r => lB(r) ? r.getHash() : JSON.stringify(r)); return `${e}(${n.join(", ")})` } var Eg = class { constructor(e, t) { this.data = e, this.pointer = t, T(this, "cached") } resolve() { return this.cached ?? (this.cached = this.data.resolveRichText(this.pointer)), this.cached } }, ls = "index", UC = class extends Set { merge(e) { for (let t of e) this.add(t) } equals(e) { if (this === e) return !0; if (this.size !== e.size) return !1; for (let t of this) if (!e.has(t)) return !1; return !0 } subsetOf(e) { if (this === e) return !0; if (this.size > e.size) return !1; for (let t of this) if (!e.has(t)) return !1; return !0 } getHash() { let e = []; for (let t of this) e.push(t.id); return e.sort((t, n) => t - n), he(this.name, ...e) } }; var cB = class { constructor(e, t, n) { this.id = e, this.name = t, this.data = n, T(this, "indexes", new fB), T(this, "fields", new de) } }; var uB = class { constructor(e, t, n, r, i, o) { this.id = e, this.data = t, this.collection = n, this.lookupNodes = r, this.constraint = i, this.ordering = o, T(this, "resolvedFields", new de); for (let s in t.schema) for (let a of n.fields) a.name === s && this.resolvedFields.add(a) } }, fB = class extends UC { constructor() { super(...arguments), T(this, "name", "Indexes") } }; var GS = class { constructor(e, t, n, r) { this.id = e, this.name = t, this.definition = n, this.collection = r } getValue(e) { let t = e.data[this.name]; return t?.type === "richtext" ? ($(this.collection, "Rich text field must have a collection"), { type: "richtext", value: new Eg(this.collection.data, t.value) }) : t ?? null } }, de = class extends UC { constructor() { super(...arguments), T(this, "name", "Fields") } }, GC = class { }, fs = { type: 0 }, dt = class extends GC { constructor(e) { super(), this.referencedFields = e } }, dB = { type: 0 }, qC = class { constructor(e, t) { this.when = e, this.then = t } getHash() { return he("CaseCondition", this.when, this.then) } }, hB = class extends dt { constructor(e, t, n) { let r = new de; e && r.merge(e.referencedFields); for (let i of t) r.merge(i.when.referencedFields), r.merge(i.then.referencedFields); n && r.merge(n.referencedFields), super(r), this.input = e, this.conditions = t, this.otherwise = n, T(this, "definition", { type: "unknown", isNullable: !0 }) } getHash() { return he("ScalarCase", this.input, ...this.conditions, this.otherwise) } toString() { let e = "CASE"; this.input && (e = `${e} ${this.input}`); for (let { when: t, then: n } of this.conditions) e = `${e} WHEN ${t} THEN ${n}`; return this.otherwise && (e = `${e} ELSE ${this.otherwise}`), `${e} END` } evaluate(e) { var t, n; let r = ((t = this.input) == null ? void 0 : t.evaluate(e)) ?? null; for (let i of this.conditions) { let o = i.when.evaluate(e); if (this.input ? Ee.equal(r, o, dB) : wt(o)) return i.then.evaluate(e) } return ((n = this.otherwise) == null ? void 0 : n.evaluate(e)) ?? null } }, XC = class { constructor(e, t = "asc") { this.field = e, this.direction = t } getHash() { return he("OrderingField", this.field.id, this.direction) } }, pr = class { constructor(e) { this.ordering = e, T(this, "fields", []), e && this.fields.push(...e.fields) } get length() { return this.fields.length } getHash() { return he("Ordering", ...this.fields) } push(e) { this.fields.push(e) } equals(e) { return this === e ? !0 : this.length !== e.length ? !1 : this.getHash() === e.getHash() } }, Wn = class { constructor(e, t) { this.ordering = e, this.resolvedFields = t } getHash() { return he("RequiredProps", this.ordering, this.resolvedFields) } get isMinimal() { return this.ordering.length === 0 && this.resolvedFields.size === 0 } canProvide(e) { return this.canProvideOrdering(e) && this.canProvideResolvedFields(e) } canProvideOrdering(e) { return this.ordering.length === 0 ? !0 : e.canProvideOrdering(this.ordering) } canProvideResolvedFields(e) { return this.resolvedFields.size === 0 ? !0 : e.canProvideResolvedFields(this.resolvedFields) } }, Nm = class { constructor(e) { this.parent = e, T(this, "node"), T(this, "defaultOrdering", new pr), T(this, "ordering"), T(this, "fields", []), this.defaultOrdering = new pr(e?.defaultOrdering) } takeNode() { let e = this.node; return $(e, "Node is missing"), this.node = void 0, e } setNode(e) { $(!this.node, "Node already set"), this.node = e } setOrdering(e) { this.ordering = e } push() { return new Nm(this) } replace() { return new Nm(this.parent) } addField(e) { if (this.fields.push(e), e.field.name === ls) { let t = new XC(e.field); this.defaultOrdering.push(t) } } addFieldsFromScope(e) { for (let t of e.fields) this.addField(t) } resolveField(e, t) { var n; let r = []; for (let i of this.fields) i.name === e && (t && i.collectionName !== t || r.push(i)); if (r.length === 1) return r[0]; if (r.length > 1) throw new Error("Ambiguous fields"); return (n = this.parent) == null ? void 0 : n.resolveField(e, t) } getRequiredOrdering() { let e = new pr(this.ordering); for (let t of this.defaultOrdering.fields) e.push(t); return e } getRequiredResolvedFields() { let e = new de; for (let { field: t } of this.fields) t.collection && e.add(t); return e } getRequiredProps() { let e = this.getRequiredOrdering(), t = this.getRequiredResolvedFields(); return new Wn(e, t) } getNamedFields() { let e = new Map; for (let { name: t, field: n } of this.fields) e.set(t, n); return e } }, pB = class { constructor(e, t, n) { this.normalizer = e, this.query = t, this.locale = n, T(this, "collectionId", 0), T(this, "indexId", 0), T(this, "fieldId", 0) } build() { let e = new Nm; return this.buildQuery(e, this.query) } buildQuery(e, t) { let n = { type: "Select", ...t }; return this.buildSelect(e, n) } buildSelect(e, t) { let n = this.buildFrom(e, t.from); if (t.where) { let o = n.takeNode(), s = this.buildExpression(n, t.where), a = this.normalizer.newRelationalFilter(o, s); n.setNode(a) } let r = this.buildSelectList(n, t.select); if (t.orderBy) { let o = new pr; for (let s of t.orderBy) { $(s.type === "Identifier", "Unsupported order type"); let a = n.resolveField(s.name, s.collection); if (Je(a)) continue; let l = new XC(a.field, s.direction); o.push(l) } r.setOrdering(o) } let i = r.getRequiredOrdering(); if (t.offset) { let o = r.takeNode(), s = this.buildExpression(e, t.offset), a = this.normalizer.newRelationalOffset(o, s, i); r.setNode(a) } if (t.limit) { let o = r.takeNode(), s = this.buildExpression(e, t.limit), a = this.normalizer.newRelationalLimit(o, s, i); r.setNode(a) } return r } buildSelectList(e, t) { let n = e.push(), r = new de; for (let s of t) { $(s.type === "Identifier", "Unsupported select type"); let a = e.resolveField(s.name, s.collection); Je(a) || (r.add(a.field), n.addField({ ...a, name: s.alias ?? a.name })) } let i = e.takeNode(), o = this.normalizer.newRelationalProject(i, [], r); return n.setNode(o), n } buildFrom(e, t) { switch (t.type) { case "Collection": return this.buildCollection(e, t); case "LeftJoin": return this.buildJoin(e, t); default: xe(t, "Unsupported from type") } } buildCollection(e, t) { let n = e.push(), r = mB(t.data, this.locale), i = t.alias, o = this.collectionId++, s = new cB(o, i, r); for (let [l, c] of Object.entries(r.schema)) { let u = this.fieldId++, f = new GS(u, l, c, s); n.addField({ field: f, name: l, collectionName: i }), s.fields.add(f) } { let l = { type: "number", isNullable: !1 }, c = this.fieldId++, u = new GS(c, ls, l, s); n.addField({ field: u, name: ls, collectionName: i }) } for (let l of r.indexes) { let c = []; for (let y of l.fields) { let g = this.buildExpression(n, y); c.push(g) } let u; l.where && (u = this.buildExpression(n, l.where)); let f = new pr, d = this.indexId++, p = new uB(d, l, s, c, u, f); s.indexes.add(p) } let a = this.normalizer.newRelationalScan(s); return n.setNode(a), n } buildJoin(e, t) { let n = this.buildFrom(e, t.left), r = this.buildFrom(e, t.right), i = e.push(); i.addFieldsFromScope(n), i.addFieldsFromScope(r); let o = this.buildExpression(i, t.constraint), s = n.takeNode(), a = r.takeNode(), l; switch (t.type) { case "LeftJoin": l = this.normalizer.newRelationalLeftJoin(s, a, o); break; default: xe(t.type, "Unsupported join type") }return i.setNode(l), i } buildExpression(e, t) { switch (t.type) { case "Identifier": return this.buildIdentifier(e, t); case "LiteralValue": return this.buildLiteralValue(e, t); case "FunctionCall": return this.buildFunctionCall(e, t); case "Case": return this.buildCase(e, t); case "UnaryOperation": return this.buildUnaryOperation(e, t); case "BinaryOperation": return this.buildBinaryOperation(e, t); case "TypeCast": return this.buildTypeCast(e, t); default: xe(t, "Unsupported expression") } } buildIdentifier(e, t) { let n = e.resolveField(t.name, t.collection); if (n) return this.normalizer.newScalarVariable(n.field); let r = { type: "unknown", isNullable: !0 }; return this.normalizer.newScalarConstant(r, null) } buildLiteralValue(e, t) { let n = gB(t.value), r = { type: "unknown", isNullable: !0 }; return this.normalizer.newScalarConstant(r, n) } buildFunctionCall(e, t) { let n = t.arguments[0]; $(n, "Invalid arguments"); let r = this.buildExpression(e, n), i = t.arguments[1]; $(i, "Invalid arguments"); let o = this.buildExpression(e, i); switch (t.functionName) { case "CONTAINS": return this.normalizer.newScalarContains(r, o); case "STARTS_WITH": return this.normalizer.newScalarStartsWith(r, o); case "ENDS_WITH": return this.normalizer.newScalarEndsWith(r, o); default: throw new Error("Unsupported function name") } } buildCase(e, t) { let n; t.value && (n = this.buildExpression(e, t.value)); let r = t.conditions.map(o => { let s = this.buildExpression(e, o.when), a = this.buildExpression(e, o.then); return new qC(s, a) }), i; return t.else && (i = this.buildExpression(e, t.else)), this.normalizer.newScalarCase(n, r, i) } buildUnaryOperation(e, t) { let n = this.buildExpression(e, t.value); switch (t.operator) { case "not": return this.normalizer.newScalarNot(n); default: xe(t.operator, "Unsupported unary operator") } } buildBinaryOperation(e, t) { let n = this.buildExpression(e, t.left), r = this.buildExpression(e, t.right); switch (t.operator) { case "and": return this.normalizer.newScalarAnd(n, r); case "or": return this.normalizer.newScalarOr(n, r); case "==": return this.normalizer.newScalarEquals(n, r); case "!=": return this.normalizer.newScalarNotEquals(n, r); case "<": return this.normalizer.newScalarLessThan(n, r); case "<=": return this.normalizer.newScalarLessThanOrEqual(n, r); case ">": return this.normalizer.newScalarGreaterThan(n, r); case ">=": return this.normalizer.newScalarGreaterThanOrEqual(n, r); case "in": return this.normalizer.newScalarIn(n, r); default: xe(t.operator, "Unsupported binary operator") } } buildTypeCast(e, t) { let n = this.buildExpression(e, t.value); switch (t.dataType) { case "BOOLEAN": { let r = { type: "boolean", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } case "DATE": { let r = { type: "date", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } case "NUMBER": { let r = { type: "number", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } case "STRING": { let r = { type: "string", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } default: throw new Error("Unsupported data type") } } }; function mB(e, t) { if (xg(e)) return new NC(e, t); if (lf(e)) return e; if (wg(e)) { for (; t;) { let n = e.collectionByLocaleId[t.id]; if (n) return n; t = t.fallback } return e.collectionByLocaleId.default } xe(e, "Unsupported collection type") } function gB(e) { return ef(e) ? { type: "boolean", value: e } : ag(e) ? { type: "date", value: e.toISOString() } : Ve(e) ? { type: "number", value: e } : ce(e) ? { type: "string", value: e } : tl(e) && e.every(ce) ? { type: "multicollectionreference", value: e } : null } function vB() { return 25 } function yB() { return 100 * 125 } var qu = 1e3, kt = class { constructor(e) { this.network = e } static estimate(e, t) { let n = vB(), r = yB(), i = e * n + t / r; return new kt(i) } static max(e, t) { let n = Math.max(e.network, t.network); return new kt(n) } static compare(e, t) { return e.network < t.network ? -1 : e.network > t.network ? 1 : 0 } add(e) { return this.network += e.network, this } toString() { return `${this.network}ms` } }, Un = class extends GC { constructor() { super(...arguments), T(this, "group") } getGroup() { return $(this.group, "Node must be in a group"), this.group } setGroup(e) { $(!this.group, "Node is already in a group"), this.group = e } }, Xu = class extends Un { constructor(e, t) { super(), this.input = e, this.predicate = t, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalFilter", this.inputGroup.id, this.predicate) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering() { return !0 } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); return t.merge(this.predicate.referencedFields), new Wn(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new Xu(n, this.predicate) } async execute() { return (await this.input.execute()).filter(t => { let n = this.predicate.evaluate(t); return wt(n) }) } }, ds = class { constructor() { T(this, "pointers", new Map), T(this, "values", new Map) } getKey() { let e = this.pointers.values(); return Array.from(e).join("-") } addValue(e, t) { this.values.set(e, t) } getValue(e) { return this.values.get(e) ?? null } mergeValues(e) { for (let [t, n] of e.values) this.addValue(t, n) } addPointer(e, t) { this.pointers.set(e, t) } getPointer(e) { return this.pointers.get(e) } mergePointers(e) { for (let [t, n] of e.pointers) this.addPointer(t, n) } merge(e) { this.mergeValues(e), this.mergePointers(e) } }, fr = class { constructor(e, t = []) { this.fields = e, this.tuples = t } push(e) { this.tuples.push(e) } filter(e) { let t = this.tuples.filter(e); return new fr(this.fields, t) } map(e, t) { let n = this.tuples.map(t); return new fr(e, n) } sort(e) { let t = Array.from(this.tuples).sort(e); return new fr(this.fields, t) } slice(e, t) { let n = this.tuples.slice(e, t); return new fr(this.fields, n) } union(e) { let t = new de; for (let i of this.fields) e.fields.has(i) && t.add(i); let n = new Set, r = new fr(t); for (let i of this.tuples) { let o = i.getKey(); n.add(o), r.push(i) } for (let i of e.tuples) { let o = i.getKey(); n.has(o) || r.push(i) } return r } intersection(e) { let t = new de; for (let i of this.fields) e.fields.has(i) && t.add(i); let n = new Set, r = new fr(t); for (let i of this.tuples) { let o = i.getKey(); n.add(o) } for (let i of e.tuples) { let o = i.getKey(); n.has(o) && r.push(i) } return r } }, Tn = class extends Un { constructor(e, t) { super(), this.index = e, this.query = t } getHash() { return he("RelationalIndexLookup", this.index.id, ...this.query) } getOutputFields() { return this.index.collection.fields } canProvideOrdering(e) { return e.equals(this.index.ordering) } canProvideResolvedFields(e) { return e.subsetOf(this.index.resolvedFields) } optimize() { let e = this.query.every(t => t.type === "All"); return kt.estimate(1, e ? 100 * qu : 50 * qu) } getOptimized() { return new Tn(this.index, this.query) } async execute() { let e = this.index, t = e.collection, n = this.getOutputFields(), i = (await e.data.lookupItems(this.query)).map(o => { let s = new ds; for (let a of e.resolvedFields) { let l = a.getValue(o); s.addPointer(t, o.pointer), s.addValue(a, l) } return s }); return new fr(n, i) } }, YC = class extends Un { constructor(e, t) { super(), this.left = e, this.right = t, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalIntersection", this.leftGroup.id, this.rightGroup.id) } getOutputFields() { let e = new de, t = this.leftGroup.relational.outputFields, n = this.rightGroup.relational.outputFields; for (let r of t) n.has(r) && e.add(r); return e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e) { let t = new pr; return new Wn(t, e.resolvedFields) } optimize(e, t) { let n = this.getChildRequiredProps(t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(t), o = e.optimizeGroup(this.rightGroup, i); return kt.max(r, o) } getOptimized(e) { let t = this.getChildRequiredProps(e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(e), i = this.rightGroup.getOptimized(r); return new YC(n, i) } async execute() { let e = await this.left.execute(), t = await this.right.execute(); return e.intersection(t) } }, Yu = class extends Un { constructor(e, t, n) { super(), this.left = e, this.right = t, this.constraint = n, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalLeftJoin", this.leftGroup.id, this.rightGroup.id, this.constraint) } getOutputFields() { let e = new de; return e.merge(this.leftGroup.relational.outputFields), e.merge(this.rightGroup.relational.outputFields), e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e, t) { let n = new de, r = e.relational.outputFields; for (let o of t.resolvedFields) r.has(o) && n.add(o); for (let o of this.constraint.referencedFields) r.has(o) && n.add(o); let i = new pr; return new Wn(i, n) } optimize(e, t) { let n = this.getChildRequiredProps(this.leftGroup, t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(this.rightGroup, t), o = e.optimizeGroup(this.rightGroup, i); return kt.max(r, o) } getOptimized(e) { let t = this.getChildRequiredProps(this.leftGroup, e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(this.rightGroup, e), i = this.rightGroup.getOptimized(r); return new Yu(n, i, this.constraint) } async execute() { let e = await this.left.execute(), t = await this.right.execute(), n = this.getOutputFields(), r = new fr(n); for (let i of e.tuples) { let o = !1; for (let s of t.tuples) { let a = new ds; a.merge(i), a.merge(s); let l = this.constraint.evaluate(a); wt(l) && (r.push(a), o = !0) } o || r.push(i) } return r } }, Rg = class extends Un { constructor(e, t, n) { super(), this.left = e, this.right = t, this.constraint = n, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalRightJoin", this.leftGroup.id, this.rightGroup.id, this.constraint) } getOutputFields() { let e = new de; return e.merge(this.leftGroup.relational.outputFields), e.merge(this.rightGroup.relational.outputFields), e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e, t) { let n = new de, r = e.relational.outputFields; for (let o of t.resolvedFields) r.has(o) && n.add(o); for (let o of this.constraint.referencedFields) r.has(o) && n.add(o); let i = new pr; return new Wn(i, n) } optimize(e, t) { let n = this.getChildRequiredProps(this.leftGroup, t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(this.rightGroup, t), o = e.optimizeGroup(this.rightGroup, i), s = kt.max(r, o); return new kt(0).add(s) } getOptimized(e) { let t = this.getChildRequiredProps(this.leftGroup, e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(this.rightGroup, e), i = this.rightGroup.getOptimized(r); return new Rg(n, i, this.constraint) } async execute() { let e = await this.left.execute(), t = await this.right.execute(), n = this.getOutputFields(), r = new fr(n); for (let i of t.tuples) { let o = !1; for (let s of e.tuples) { let a = new ds; a.merge(i), a.merge(s); let l = this.constraint.evaluate(a); wt(l) && (r.push(a), o = !0) } o || r.push(i) } return r } }, Ku = class extends Un { constructor(e) { super(), this.collection = e } getHash() { return he("RelationalScan", this.collection.id) } getOutputFields() { return this.collection.fields } canProvideOrdering() { return !1 } canProvideResolvedFields(e) { return e.subsetOf(this.collection.fields) } optimize() { return kt.estimate(1, 200 * qu) } getOptimized() { return new Ku(this.collection) } async execute() { let e = this.collection, t = this.getOutputFields(), r = (await e.data.scanItems()).map(i => { let o = new ds; for (let s of t) { let a = s.getValue(i); o.addPointer(e, i.pointer), o.addValue(s, a) } return o }); return new fr(t, r) } }, KC = class extends Un { constructor(e, t) { super(), this.left = e, this.right = t, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalUnion", this.leftGroup.id, this.rightGroup.id) } getOutputFields() { let e = new de, t = this.leftGroup.relational.outputFields, n = this.rightGroup.relational.outputFields; for (let r of t) n.has(r) && e.add(r); return e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e) { let t = new pr; return new Wn(t, e.resolvedFields) } optimize(e, t) { let n = this.getChildRequiredProps(t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(t), o = e.optimizeGroup(this.rightGroup, i); return kt.max(r, o) } getOptimized(e) { let t = this.getChildRequiredProps(e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(e), i = this.rightGroup.getOptimized(r); return new KC(n, i) } async execute() { let e = await this.left.execute(), t = await this.right.execute(); return e.union(t) } }, Hm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarAnd", this.left, this.right) } toString() { return `${this.left} && ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: wt(t) && wt(n) } } }, zn = class extends dt { constructor(e, t) { let n = new de; super(n), this.definition = e, this.value = t } getHash() { return he("ScalarConstant", this.definition, this.value) } toString() { return Ee.stringify(this.value) } evaluate() { return this.value } }, QC = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.source = e, this.target = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarContains", this.source, this.target) } toString() { return `CONTAINS(${this.source}, ${this.target})` } getValue(e, t) { let n = zr(e), r = zr(t); if (oe(n) || oe(r)) return !1; let i = n.toLowerCase(), o = r.toLowerCase(); return i.includes(o) } evaluate(e) { let t = this.source.evaluate(e), n = this.target.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, ZC = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.source = e, this.target = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarEndsWith", this.source, this.target) } toString() { return `ENDS_WITH(${this.source}, ${this.target})` } getValue(e, t) { let n = zr(e), r = zr(t); if (oe(n) || oe(r)) return !1; let i = n.toLowerCase(), o = r.toLowerCase(); return i.endsWith(o) } evaluate(e) { let t = this.source.evaluate(e), n = this.target.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, jm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarEquals", this.left, this.right) } toString() { return `${this.left} == ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Ee.equal(t, n, fs) } } }, Wm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarGreaterThan", this.left, this.right) } toString() { return `${this.left} > ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Ee.greaterThan(t, n, fs) } } }, Um = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarGreaterThanOrEqual", this.left, this.right) } toString() { return `${this.left} >= ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Ee.greaterThanOrEqual(t, n, fs) } } }, Gm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarLessThan", this.left, this.right) } toString() { return `${this.left} < ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Ee.lessThan(t, n, fs) } } }, qm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarLessThanOrEqual", this.left, this.right) } toString() { return `${this.left} <= ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Ee.lessThanOrEqual(t, n, fs) } } }, Xm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarNotEquals", this.left, this.right) } toString() { return `${this.left} != ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: !Ee.equal(t, n, fs) } } }, Ym = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarOr", this.left, this.right) } toString() { return `${this.left} || ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: wt(t) || wt(n) } } }, JC = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.source = e, this.target = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarStartsWith", this.source, this.target) } toString() { return `STARTS_WITH(${this.source}, ${this.target})` } getValue(e, t) { let n = zr(e), r = zr(t); if (oe(n) || oe(r)) return !1; let i = n.toLowerCase(), o = r.toLowerCase(); return i.startsWith(o) } evaluate(e) { let t = this.source.evaluate(e), n = this.target.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, bB = class { constructor(e) { this.normalizer = e, T(this, "memo", this.normalizer.memo) } explore(e) { let t = e.getGroup(); if (e instanceof Yu) { let n = new Rg(e.left, e.right, e.constraint); this.memo.addRelational(n, t) } if (e instanceof Xu) { if (e.predicate instanceof Hm) { let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left), r = this.normalizer.newRelationalFilter(e.input, e.predicate.right), i = new YC(n, r); this.memo.addRelational(i, t) } if (e.predicate instanceof Ym) { let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left), r = this.normalizer.newRelationalFilter(e.input, e.predicate.right), i = new KC(n, r); this.memo.addRelational(i, t) } } if (e instanceof Ku) for (let n of e.collection.indexes) { if (n.constraint) continue; let r = ur(n.lookupNodes.length), i = new Tn(n, r); this.memo.addRelational(i, t) } if (e instanceof Xu) { for (let n of e.inputGroup.nodes) if (n instanceof Ku) for (let r of n.collection.indexes) { if (e.predicate instanceof jm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("Equals")) { let i = ur(r.lookupNodes.length); i[0] = { type: "Equals", value: e.predicate.right.value }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof Xm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("NotEquals")) { let i = ur(r.lookupNodes.length); i[0] = { type: "NotEquals", value: e.predicate.right.value }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof Gm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("LessThan")) { let i = ur(r.lookupNodes.length); i[0] = { type: "LessThan", value: e.predicate.right.value, inclusive: !1 }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof qm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("LessThan")) { let i = ur(r.lookupNodes.length); i[0] = { type: "LessThan", value: e.predicate.right.value, inclusive: !0 }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof Wm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("GreaterThan")) { let i = ur(r.lookupNodes.length); i[0] = { type: "GreaterThan", value: e.predicate.right.value, inclusive: !1 }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof Um && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("GreaterThan")) { let i = ur(r.lookupNodes.length); i[0] = { type: "GreaterThan", value: e.predicate.right.value, inclusive: !0 }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof QC && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof zn && r.data.supportedLookupTypes.includes("Contains")) { let i = ur(r.lookupNodes.length); i[0] = { type: "Contains", value: e.predicate.target.value }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof JC && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof zn && r.data.supportedLookupTypes.includes("StartsWith")) { let i = ur(r.lookupNodes.length); i[0] = { type: "StartsWith", value: e.predicate.target.value }; let o = new Tn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof ZC && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof zn && r.data.supportedLookupTypes.includes("EndsWith")) { let i = ur(r.lookupNodes.length); i[0] = { type: "EndsWith", value: e.predicate.target.value }; let o = new Tn(r, i); this.memo.addRelational(o, t) } } } } }; function ur(e) { let t = { type: "All" }; return new Array(e).fill(t) } var xB = class { constructor(e, t) { this.id = e, this.relational = t, T(this, "nodes", []), T(this, "winners", new Map) } addNode(e) { this.nodes.push(e), e.setGroup(this) } getWinner(e) { let t = e.getHash(), n = this.winners.get(t); if (n) return n; let r = new wB; return this.winners.set(t, r), r } getOptimized(e) { let t = this.getWinner(e); $(t.node, "Group not optimized"); let n = t.node.getOptimized(e); return n.setGroup(this), n } }, wB = class { constructor() { T(this, "node"), T(this, "cost", new kt(1 / 0)) } update(e, t) { kt.compare(t, this.cost) < 0 && (this.node = e, this.cost = t) } }, SB = class { constructor(e) { this.outputFields = e } isCompatible(e) { return this.outputFields.equals(e.outputFields) } }, kB = class { constructor() { T(this, "nodes", new Map), T(this, "groups", []) } addGroup(e) { let t = this.groups.length, n = new xB(t, e); return this.groups.push(n), n } addRelational(e, t) { let n = e.getHash(), r = this.nodes.get(n); if (r) return r; this.nodes.set(n, e); let i = e.getOutputFields(), o = new SB(i); return t ?? (t = this.addGroup(o)), t.addNode(e), $(o.isCompatible(t.relational), "Group has inconsistent relational props"), e } addScalar(e) { let t = e.getHash(), n = this.nodes.get(t); return n || (this.nodes.set(t, e), e) } }, eT = class extends Un { }, tT = class extends eT { constructor(e, t) { super(), this.input = e, this.fields = t, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("EnforcerResolve", this.inputGroup.id, this.fields) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering() { return !0 } canProvideResolvedFields(e) { return e.subsetOf(this.fields) } getInputRequiredProps(e) { let t = new de; return new Wn(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return kt.estimate(0, 100 * qu).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new tT(n, this.fields) } async execute() { let e = await this.input.execute(); $(this.fields.subsetOf(e.fields), "Fields can't be resolved"); let t = new Set; for (let r of this.fields) $(r.collection, "Collection required to resolve field"), t.add(r.collection); for (let r of e.tuples) for (let i of this.fields) { let o = r.getValue(i); o?.type === "richtext" && ($(o instanceof Eg, "Pointer must be wrapped"), o.resolve()) } let n = await Promise.all(Array.from(t).map(async r => { let i = e.tuples.map(s => { let a = s.getPointer(r); return $(a, "Pointer required to resolve field"), a }), o = await r.data.resolveItems(i); return $(o.length === i.length, "Invalid number of items"), [r, o] })); return e.map(e.fields, (r, i) => { let o = new ds; o.merge(r); for (let [s, a] of n) { let l = a[i]; $(l, "Item not found"); let c = r.getPointer(s); $(l.pointer === c, "Pointer mismatch"); for (let u of s.fields) { let f = u.getValue(l); o.addValue(u, f) } } return o }) } }, km = { type: 0 }, nT = class extends eT { constructor(e, t) { super(), this.input = e, this.ordering = t, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("EnforcerSort", this.inputGroup.id, this.ordering) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); for (let { field: r } of this.ordering.fields) r.name !== ls && t.add(r); let n = new pr; return new Wn(n, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new nT(n, this.ordering) } async execute() { return (await this.input.execute()).sort((t, n) => { for (let { field: r, direction: i } of this.ordering.fields) { let o = i === "asc"; if (r.name === ls) { let l = r.collection; $(l, "Collection required for sorting"); let c = t.getPointer(l); $(c, "Pointer required for sorting"); let u = { pointer: c, data: {} }, f = n.getPointer(l); $(f, "Pointer required for sorting"); let d = { pointer: f, data: {} }, p = l.data.compareItems(u, d); return o ? p : -p } let s = t.getValue(r), a = n.getValue(r); if (!Ee.equal(s, a, km)) { if (oe(s) || Ee.lessThan(s, a, km)) return o ? -1 : 1; if (oe(a) || Ee.greaterThan(s, a, km)) return o ? 1 : -1; throw new Error("Invalid comparison") } } return 0 }) } }, rT = class extends Un { constructor(e, t, n) { super(), this.input = e, this.limit = t, this.ordering = n, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalLimit", this.inputGroup.id, this.limit) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); return t.merge(this.limit.referencedFields), new Wn(this.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new rT(n, this.limit, this.ordering) } async execute() { let e = await this.input.execute(), t = this.limit.evaluate(), n = ol(t) ?? 1 / 0; return n === 1 / 0 ? e : e.slice(0, n) } }, iT = class extends Un { constructor(e, t, n) { super(), this.input = e, this.offset = t, this.ordering = n, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalOffset", this.inputGroup.id, this.offset) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); return t.merge(this.offset.referencedFields), new Wn(this.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new iT(n, this.offset, this.ordering) } async execute() { let e = await this.input.execute(), t = this.offset.evaluate(), n = ol(t) ?? 0; return n === 0 ? e : e.slice(n) } }, oT = class extends Un { constructor(e, t, n) { super(), this.input = e, this.projections = t, this.passthrough = n, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalProject", this.inputGroup.id, ...this.projections, this.passthrough) } getOutputFields() { let e = new de; e.merge(this.passthrough); for (let t of this.projections) e.add(t.field); return e } canProvideOrdering() { return !0 } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); for (let n of this.projections) t.merge(n.input.referencedFields); return new Wn(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new oT(n, this.projections, this.passthrough) } async execute() { let e = this.getOutputFields(); return (await this.input.execute()).map(e, n => { let r = new ds; r.mergePointers(n); for (let i of this.passthrough) { let o = n.getValue(i); r.addValue(i, o) } for (let i of this.projections) { let o = i.input.evaluate(n); r.addValue(i.field, o) } return r }) } }, CB = class extends dt { constructor(e, t) { super(e.referencedFields), this.input = e, this.definition = t, $(t.isNullable, "Unsupported non-nullable cast") } getHash() { return he("ScalarCast", this.input, this.definition) } toString() { return `CAST(${this.input} AS ${this.definition.type.toUpperCase()})` } evaluate(e) { let t = this.input.evaluate(e); return Ee.cast(t, this.definition) } }, TB = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarIn", this.left, this.right) } toString() { return `${this.left} IN ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Ee.in(t, n) } } }, qS = class extends dt { constructor(e) { super(e.referencedFields), this.input = e, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarNot", this.input) } toString() { return `NOT ${this.input}` } evaluate(e) { let t = this.input.evaluate(e); return { type: "boolean", value: !wt(t) } } }, EB = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarNotIn", this.left, this.right) } toString() { return `${this.left} NOT IN ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: !Ee.in(t, n) } } }, un = class extends dt { constructor(e) { $(e.name !== ls, "Invalid field name"); let t = new de; t.add(e), super(t), this.field = e, T(this, "definition", this.field.definition) } getHash() { return he("ScalarVariable", this.field.id) } toString() { return `"${this.field.name}" /* ${this.field.id} */` } evaluate(e) { return $(e, "Tuple must be provided"), e.getValue(this.field) } }, RB = class { constructor(e) { this.memo = e } finishRelational(e) { return this.memo.addRelational(e) } newRelationalScan(e) { let t = new Ku(e); return this.finishRelational(t) } newRelationalIndexLookup(e, t) { let n = new Tn(e, t); return this.finishRelational(n) } newRelationalLeftJoin(e, t, n) { let r = new Yu(e, t, n); return this.finishRelational(r) } newRelationalRightJoin(e, t, n) { return this.newRelationalLeftJoin(t, e, n) } newRelationalFilter(e, t) { if (e instanceof Yu && t.referencedFields.subsetOf(e.leftGroup.relational.outputFields)) { let r = this.newRelationalFilter(e.left, t); return this.newRelationalLeftJoin(r, e.right, e.constraint) } if (e instanceof Rg && t.referencedFields.subsetOf(e.rightGroup.relational.outputFields)) { let r = this.newRelationalFilter(e.right, t); return this.newRelationalLeftJoin(e.left, r, e.constraint) } let n = new Xu(e, t); return this.finishRelational(n) } newRelationalProject(e, t, n) { let r = new oT(e, t, n); return this.finishRelational(r) } newRelationalLimit(e, t, n) { let r = new rT(e, t, n); return this.finishRelational(r) } newRelationalOffset(e, t, n) { let r = new iT(e, t, n); return this.finishRelational(r) } finishScalar(e) { let t = e instanceof zn; if (e.referencedFields.size === 0 && !t) { let n = e.evaluate(); return this.newScalarConstant(e.definition, n) } return this.memo.addScalar(e) } removeUnknown(e, t) { if (e.definition.type !== "unknown" || t.type === "unknown") return e; let n = { ...t, isNullable: !0 }; return this.newScalarCast(e, n) } newScalarVariable(e) { let t = new un(e); return this.finishScalar(t) } newScalarConstant(e, t) { let n = new zn(e, t); return this.finishScalar(n) } newScalarNot(e) { if (e instanceof qS) { if (e.input.definition.type === "boolean") return e.input; let n = { type: "boolean", isNullable: !0 }; return this.newScalarCast(e.input, n) } if (e instanceof jm) return this.newScalarNotEquals(e.left, e.right); if (e instanceof Xm) return this.newScalarEquals(e.left, e.right); if (e instanceof Gm) return this.newScalarGreaterThanOrEqual(e.left, e.right); if (e instanceof qm) return this.newScalarGreaterThan(e.left, e.right); if (e instanceof Wm) return this.newScalarLessThanOrEqual(e.left, e.right); if (e instanceof Um) return this.newScalarLessThan(e.left, e.right); if (e instanceof Hm) { let n = this.newScalarNot(e.left), r = this.newScalarNot(e.right); return this.newScalarOr(n, r) } if (e instanceof Ym) { let n = this.newScalarNot(e.left), r = this.newScalarNot(e.right); return this.newScalarAnd(n, r) } let t = new qS(e); return this.finishScalar(t) } newScalarAnd(e, t) { let n = new Hm(e, t); return this.finishScalar(n) } newScalarOr(e, t) { let n = new Ym(e, t); return this.finishScalar(n) } newScalarEquals(e, t) { let n = e instanceof un; if (t instanceof un && !n) return this.newScalarEquals(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new jm(e, t); return this.finishScalar(i) } newScalarNotEquals(e, t) { let n = e instanceof un; if (t instanceof un && !n) return this.newScalarNotEquals(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Xm(e, t); return this.finishScalar(i) } newScalarLessThan(e, t) { let n = e instanceof un; if (t instanceof un && !n) return this.newScalarGreaterThan(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Gm(e, t); return this.finishScalar(i) } newScalarLessThanOrEqual(e, t) { let n = e instanceof un; if (t instanceof un && !n) return this.newScalarGreaterThanOrEqual(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new qm(e, t); return this.finishScalar(i) } newScalarGreaterThan(e, t) { let n = e instanceof un; if (t instanceof un && !n) return this.newScalarLessThan(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Wm(e, t); return this.finishScalar(i) } newScalarGreaterThanOrEqual(e, t) { let n = e instanceof un; if (t instanceof un && !n) return this.newScalarLessThanOrEqual(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Um(e, t); return this.finishScalar(i) } newScalarIn(e, t) { let n = new TB(e, t); return this.finishScalar(n) } newScalarNotIn(e, t) { let n = new EB(e, t); return this.finishScalar(n) } newScalarCase(e, t, n) { if (e) { let i = []; for (let { when: o, then: s } of t) { let a = this.removeUnknown(o, e.definition), l = new qC(a, s); i.push(l) } t = i } let r = new hB(e, t, n); return this.finishScalar(r) } newScalarContains(e, t) { let n = new QC(e, t); return this.finishScalar(n) } newScalarStartsWith(e, t) { let n = new JC(e, t); return this.finishScalar(n) } newScalarEndsWith(e, t) { let n = new ZC(e, t); return this.finishScalar(n) } newScalarCast(e, t) { if (e.definition.type === t.type) return e; let n = new CB(e, t); return this.finishScalar(n) } }, PB = class { constructor(e, t) { this.query = e, this.locale = t, T(this, "memo", new kB), T(this, "normalizer", new RB(this.memo)), T(this, "explorer", new bB(this.normalizer)) } optimize() { let t = new pB(this.normalizer, this.query, this.locale).build(), r = t.takeNode().getGroup(), i = t.getRequiredProps(); this.optimizeGroup(r, i); let o = r.getOptimized(i), s = t.getNamedFields(); return [o, s] } optimizeGroup(e, t) { let n = e.getWinner(t); if (n.node) return n.cost; let r = e.nodes[0]; $(r, "Normalized node not found"), this.createEnforcer(n, r, t); for (let i of e.nodes) { if (t.canProvide(i)) { let o = i.optimize(this, t); n.update(i, o) } t.isMinimal && this.explorer.explore(i) } return n.cost } createEnforcer(e, t, n) { if (n.resolvedFields.size > 0) { let r = new tT(t, n.resolvedFields), i = r.optimize(this, n); e.update(r, i) } if (n.ordering.length > 0) { let r = new nT(t, n.ordering), i = r.optimize(this, n); e.update(r, i) } } }; function _B(e) { return e.collection ? `"${e.collection}"."${e.name}"` : `"${e.name}"` } function FB(e) { return typeof e.value == "string" ? `'${e.value}'` : e.value } function IB(e) { return `${e.functionName}(${e.arguments.map(t => $t(t)).join(", ")})` } function LB(e) { let t = "CASE"; e.value && (t += ` ${$t(e.value)}`); for (let n of e.conditions) t += ` WHEN ${$t(n.when)} THEN ${$t(n.then)}`; return e.else && (t += ` ELSE ${$t(e.else)}`), t += " END", t } function MB(e) { let t = $t(e.value); return `${e.operator.toUpperCase()} ${t}` } function OB(e) { let t = $t(e.left), n = $t(e.right), r = e.operator.toUpperCase(); return `${t} ${r} ${n}` } function DB(e) { return `CAST(${$t(e.value)} as ${e.dataType})` } function $t(e) { switch (e.type) { case "Identifier": return _B(e); case "LiteralValue": return FB(e); case "FunctionCall": return IB(e); case "Case": return LB(e); case "UnaryOperation": return MB(e); case "BinaryOperation": return OB(e); case "TypeCast": return DB(e); default: xe(e) } } function AB(e) { return lf(e.data) ? "Collection" : e.alias ? `"${e.data.displayName}" AS "${e.alias}"` : `"${e.data.displayName}"` } function VB(e) { let t = `${Km(e.left)} LEFT JOIN ${Km(e.right)}`; return e.constraint && (t += ` ON ${$t(e.constraint)}`), t } function Km(e) { switch (e.type) { case "Collection": return AB(e); case "LeftJoin": return VB(e); default: xe(e) } } function BB(e) {
    let t = ""; return e.split(/\s+/u).forEach(r => {
        r !== "" && (["SELECT", "FROM", "WHERE", "ORDER", "LIMIT", "OFFSET"].includes(r) ? t += `
${r}` : ["AND", "OR"].includes(r) ? t += `
	${r}` : t += ` ${r}`)
    }), t.trim()
} function zB(e) { let t = ""; return t += `SELECT ${e.select.map(n => { let r = $t(n); return n.alias ? `${r} AS "${n.alias}"` : r }).join(", ")}`, t += ` FROM ${Km(e.from)}`, e.where && (t += ` WHERE ${$t(e.where)}`), e.orderBy && (t += ` ORDER BY ${e.orderBy.map(n => `${$t(n)} ${n.direction ?? "asc"}`).join(", ")}`), e.limit && (t += ` LIMIT ${$t(e.limit)}`), e.offset && (t += ` OFFSET ${$t(e.offset)}`), BB(t) } var $B = d4("query-engine"); function NB({ data: e }, t) { if (xg(e)) return new NC(e, t); if (lf(e)) return e; if (wg(e)) { for (; t;) { let n = e.collectionByLocaleId[t.id]; if (n) return n; t = t.fallback } return e.collectionByLocaleId.default } xe(e, "Unsupported collection type") } var HB = class {
    constructor() { T(this, "useNewOptimizer", !1) } async query(e, t) { return this.useNewOptimizer || e.from.type !== "Collection" ? this.queryNew(e, t) : this.queryOld(e, t) } async queryNew(e, t) { let n = new PB(e, t), [r, i] = n.optimize(), o = await r.execute(); return await Promise.all(o.tuples.map(async a => { let l = {}; for (let [c, u] of i) { let f = a.getValue(u); l[c] = await this.resolveValue(f) } return l })) } async resolveValue(e) { return e?.type === "richtext" ? ($(e.value instanceof Eg, "Pointer must be wrapped"), e.value.resolve()) : e?.value ?? null } async queryOld(e, t) {
        let [n, r, i] = this.createQueryPlan(e, t), o = await this.executeQueryPlan(r, i, e, n); return $B.debug(`Query:
${zB(e)}

${(0, f4.default)(n.inspect())}`), o
    } buildFrom(e, t, n, r) { switch (e.type) { case "Collection": { let i = NB(e, r); return n.push(i), Object.assign(t, i.schema), new jC(i, e.alias) } case "LeftJoin": { let i = this.buildFrom(e.left, t, n, r), o = this.buildFrom(e.right, t, n, r), s = It.from(e.constraint, t); return new eB(i, o, s) } default: xe(e, "Unsupported data source") } } createQueryPlan(e, t) { var n; let r = {}, i = [], o = this.buildFrom(e.from, r, i, t), [s] = i; $(s, "At least one collection must exist"); let a = new aB(i); if (e.where) { let f = It.from(e.where, r); i.length === 1 ? o = Qm(s, f) : o = new WC(o, f) } let l = (n = e.orderBy) == null ? void 0 : n.map(f => new oB(It.from(f, r), f.direction ?? "asc", { type: 0 })); o = new iB(o, l ?? [], s); let c; e.offset && (c = It.from(e.offset, r)); let u; return e.limit && (u = It.from(e.limit, r)), (c || u) && (o = new sB(o, c, u)), e.select.length > 0 && i.length === 1 && (o = new rB(o, s, a, e.select)), [o, r, a] } async executeQueryPlan(e, t, n, r) { let i = await r.execute(); return Promise.all(i.map(async o => { let s = {}; for (let a of n.select) { let l = It.from(a, e), c = jB(a), u = l.evaluate(o); s[c] = await WB(t, a.type === "Identifier" ? a.name : void 0, u) } return s })) }
}; function jB(e) { if (e.alias) return e.alias; if (e.type === "Identifier") return e.name; throw new Error("Can't serialize expression") } async function WB(e, t, n) { return os(n) ? null : n.type === "richtext" ? ($(ce(t), "Rich text field must be a string"), e.resolve(t, n.value)) : n.value } function Qm(e, t) { if (t instanceof Ji) { let n = t.operandExpressions.map(r => Qm(e, r)); return new nB(n) } if (t instanceof Aa) { let n = t.operandExpressions.map(r => Qm(e, r)); return new tB(n) } return UB(e, t) ?? qB(e, t) } function UB(e, t) { var n, r; if (t instanceof Hn) return Cm(e, t); if (t instanceof sl) return GB(e, t); if (t instanceof St && ((n = t.definition) == null ? void 0 : n.type) === "boolean") { let i = _e.fromBoolean(!0), o = new ss(t, i); return Cm(e, o) } if (t instanceof Wa && t.valueExpression instanceof St && ((r = t.valueExpression.definition) == null ? void 0 : r.type) === "boolean") { let i = _e.fromBoolean(!0), o = new as(t.valueExpression, i); return Cm(e, o) } } function Cm(e, t) { let n = t.leftExpression, r = t.rightExpression; if (r instanceof _e) for (let i of e.indexes) { let o = i.fields[0]; if (Je(o)) continue; let s = It.from(o, e.schema); if (!n.equals(s)) continue; let a = new Array(i.fields.length - 1).fill({ type: "All" }); if (t instanceof ss && i.supportedLookupTypes.includes("Equals")) return new Vr(i, [{ type: "Equals", value: r.evaluate() }, ...a]); if (t instanceof as && i.supportedLookupTypes.includes("NotEquals")) return new Vr(i, [{ type: "NotEquals", value: r.evaluate() }, ...a]); if (t instanceof Ga && i.supportedLookupTypes.includes("LessThan")) return new Vr(i, [{ type: "LessThan", value: r.evaluate(), inclusive: !1 }, ...a]); if (t instanceof qa && i.supportedLookupTypes.includes("LessThan")) return new Vr(i, [{ type: "LessThan", value: r.evaluate(), inclusive: !0 }, ...a]); if (t instanceof Xa && i.supportedLookupTypes.includes("GreaterThan")) return new Vr(i, [{ type: "GreaterThan", value: r.evaluate(), inclusive: !1 }, ...a]); if (t instanceof Ya && i.supportedLookupTypes.includes("GreaterThan")) return new Vr(i, [{ type: "GreaterThan", value: r.evaluate(), inclusive: !0 }, ...a]) } } function GB(e, t) { if (t.argumentExpressions.length !== 2) return; let n = t.argumentExpressions[0], r = t.argumentExpressions[1]; if (!Je(n) && !Je(r) && r instanceof _e) for (let i of e.indexes) { let o = i.fields[0]; if (Je(o)) continue; let s = It.from(o, e.schema); if (!n.equals(s)) continue; let a = new Array(i.fields.length - 1).fill({ type: "All" }); if (t instanceof cf && i.supportedLookupTypes.includes("Contains")) return new Vr(i, [{ type: "Contains", value: r.evaluate() }, ...a]); if (t instanceof uf && i.supportedLookupTypes.includes("StartsWith")) return new Vr(i, [{ type: "StartsWith", value: r.evaluate() }, ...a]); if (t instanceof ff && i.supportedLookupTypes.includes("EndsWith")) return new Vr(i, [{ type: "EndsWith", value: r.evaluate() }, ...a]) } } function qB(e, t) { let n = new jC(e, void 0); return new WC(n, t) } var Iu = "default", XB = new Set([Iu]), Lu, YB = class { constructor() { T(this, "entries", new Map), tn(this, Lu, {}) } set(e, t, n, r) { switch (t) { case "transformTemplate": { $(typeof n == "string", `transformTemplate must be a string, received: ${n}`), this.setHash(e, r, { transformTemplate: n, legacy: !0 }); break } case "initial": case "animate": { $(typeof n == "object", `${t} must be a valid object, received: ${n}`), this.setHash(e, r, { [t]: n, legacy: !0 }); break } default: break } } setHash(e, t = Iu, n) { let r = this.entries.get(e) ?? {}, i = r[t] ?? {}; r[t] = n === null ? null : { ...i, ...n }, this.entries.set(e, r) } variantHash(e, t) { if (e === t?.primaryVariantId) return Iu; let n = fe(this, Lu)[e]; if (n) return n; let r = t?.variantClassNames[e]; return r ? fe(this, Lu)[e] = zC(r) : Iu } setAll(e, t = XB, n, r) { var i; if (n === null) { for (let c of t) this.setHash(e, this.variantHash(c, r), null); return } let o = Si(n.transformTemplate) ? (i = n.transformTemplate) == null ? void 0 : i.call(n, {}, KB) : void 0, s = n.__framer__presenceInitial ?? n.initial, a = n.__framer__presenceAnimate ?? n.animate, l = { initial: Te(s) ? s : void 0, animate: Te(a) ? a : void 0, transformTemplate: ce(o) ? o : void 0 }; for (let c of t) this.setHash(e, this.variantHash(c, r), l) } clear() { this.entries.clear() } toObject() { return Object.fromEntries(this.entries) } }; Lu = new WeakMap; var yW = new YB; var KB = "__Appear_Animation_Transform__"; var bW = "data-framer-appear-id", xW = "data-framer-appear-animation"; function Tm(e, t) { e.forEach(n => clearTimeout(n)), e.clear(), t.forEach(n => n && n("Callback cancelled by variant change")), t.clear() } function XS() { return new Set } function SW(e) { let t = Qt(XS), n = Qt(XS); return fC(() => () => Tm(n, t)), x.useEffect(() => () => Tm(n, t), [t, n]), x.useEffect(() => { Tm(n, t) }, [e, t, n]), x.useRef({ activeVariantCallback: r => (...i) => new Promise((o, s) => { t.add(s), r(...i).then(o) }).catch(() => { }), delay: async (r, i) => { await new Promise(o => n.add(globalThis.setTimeout(() => o(!0), i))), r() } }).current } function QB(e, t, n) { return x.useCallback(r => { var i, o, s; return n ? e ? t ? Object.assign({}, (i = n[e]) == null ? void 0 : i[r], (o = n[t]) == null ? void 0 : o[r]) : ((s = n[e]) == null ? void 0 : s[r]) || {} : {} : {} }, [e, t, n]) } function ZB(e) { for (let [t, n] of Object.entries(e)) if (ft.matchMedia(n).matches) return t } function JB(e) { var t; for (let { hash: n, mediaQuery: r } of e) { if (!r) continue; if (ft.matchMedia(r).matches) return n } return (t = e[0]) == null ? void 0 : t.hash } function TW(e, t, n = !0) { let r = V(mC), i = D(ki() ? ZB(t) ?? e : e), o = D(n && r ? e : i.current), s = nf(), a = mb(), l = se(c => { (c !== i.current || c !== o.current) && a(() => { i.current = o.current = c, yr(() => { s() }) }) }, [a, s]); return Kk(() => { !n || r !== !0 || l(i.current) }, []), z(() => { let c = []; for (let [u, f] of Object.entries(t)) { let d = ft.matchMedia(f), p = y => { y.matches && l(u) }; ez(d, p), c.push([d, p]) } return () => c.forEach(([u, f]) => tz(u, f)) }, [t, l]), [i.current, o.current] } function ez(e, t) { e.addEventListener ? e.addEventListener("change", t) : e.addListener(t) } function tz(e, t) { e.removeEventListener ? e.removeEventListener("change", t) : e.removeListener(t) } function EW(e) { var t, n; let r = JB(e); if (r) for (let i of document.querySelectorAll(".hidden-" + r)) (t = i.parentNode) == null || t.removeChild(i); for (let i of document.querySelectorAll(".ssr-variant:empty")) (n = i.parentNode) == null || n.removeChild(i) } function ll() { return le.current() === le.canvas } function YS(e, t) { if (e[t]) return e[t]; if (!(t in e)) return e.default } function nz(e, t) { if (ll()) return; let r = x.useRef(!0), i = x.useRef(t); fC((o, s) => { let a = o && !s; if (!r.current && a) { let l = YS(i.current, e); l && l() } r.current = a }, []), x.useEffect(() => { if (r.current) { let o = YS(i.current, e); o && o() } }, [e]) } function LW(e) { nz("default", { default: e }) } var rz = class { constructor(e) { this.queryEngine = e, T(this, "cache", new Map) } get(e, t) { let n = sz(e, t), r = this.cache.get(n); if (r) return r; let i = () => this.queryEngine.query(e, t), o = new af(i); return this.cache.set(n, o), o } }, KS = new WeakMap; function iz(e) { let t = KS.get(e); if (t) return t; let n = Math.random().toString(16).slice(2); return KS.set(e, n), n } function oz(e, t) { return Te(t) && t.type === "Collection" && h4(t.data) ? iz(t.data) : t } function sz(e, t) { let n = t?.id ?? "default"; return JSON.stringify(e, oz) + n } function az(e) { throw e } var lz = new HB, cz = new rz(lz); function AW(e) { let { activeLocale: t } = rg(), n = cz.get(e, t), r = n.preload(); return r && az(r), n.read() } function VW(e) { let n = Object.entries(e).filter(([, r]) => !(Je(r) || Te(r))).map(([r, i]) => ({ type: "BinaryOperation", operator: "==", left: { type: "TypeCast", value: { type: "Identifier", name: r }, dataType: "STRING" }, right: { type: "LiteralValue", value: String(i) } })); return n.length === 0 ? { type: "LiteralValue", value: !1 } : n.reduce((r, i) => ({ type: "BinaryOperation", operator: "and", left: r, right: i })) } function QS(e, t) { return `${e}-${t}` } function uz(e, t) { let r = e.indexOf(t) + 1; r >= e.length && (r = 0); let i = e[r]; return $(i !== void 0, "nextVariant should be defined"), i } function fz(e, t) { if (e) { if (t) { let n = e[t]; if (n) return n } return e.default } } function ZS(e, t, n, r, i) { let { hover: o, pressed: s, loading: a, error: l } = e || {}; if (l && i) return "error"; if (a && r) return "loading"; if (s && n) return "pressed"; if (o && t) return "hover" } function dz(e, t) { let n = t[e]; return n || `framer-v-${e}` } function JS(e, t, n) { return e && n.has(e) ? e : t } var hz = Symbol("cycle"); function $W({ variant: e, defaultVariant: t, transitions: n, enabledGestures: r, cycleOrder: i = [], variantProps: o = {}, variantClassNames: s = {} }) { let a = nf(), l = ll(), c = Qt(() => new Set(i)), u = x.useRef({ isHovered: !1, isPressed: !1, isError: !1, hasPressedVariants: !0, baseVariant: JS(e, t, c), lastVariant: e, gestureVariant: void 0, loadedBaseVariant: {}, defaultVariant: t, enabledGestures: r, cycleOrder: i, transitions: n }), f = x.useCallback(E => { let { isHovered: L, isPressed: F, isError: N, enabledGestures: A, defaultVariant: K } = u.current, U = JS(E, K, c), H = ZS(A?.[U], L, F, !1, N), W = H ? QS(U, H) : void 0; return [U, W] }, [c]), d = x.useCallback(({ isHovered: E, isPressed: L, isError: F }) => { E !== void 0 && (u.current.isHovered = E), L !== void 0 && (u.current.isPressed = L), F !== void 0 && (u.current.isError = F); let { baseVariant: N, gestureVariant: A, defaultVariant: K } = u.current, [U, H] = f(N); (U !== N || H !== A) && (u.current.baseVariant = U || K, u.current.gestureVariant = H, a()) }, [f, a]), p = x.useCallback(E => { let { defaultVariant: L, cycleOrder: F, baseVariant: N, gestureVariant: A } = u.current, K = E === hz ? uz(F || [], N || L) : E, [U, H] = f(K); (U !== N || H !== A) && (u.current.isError = !1, u.current.baseVariant = U || L, u.current.gestureVariant = H, a()) }, [f, a]), y = x.useCallback(() => { let { baseVariant: E } = u.current; u.current.loadedBaseVariant[E] = !0, a() }, [a]); if (e !== u.current.lastVariant) { let [E, L] = f(e); u.current.lastVariant = E, (E !== u.current.baseVariant || L !== u.current.gestureVariant) && (u.current.baseVariant = E, u.current.gestureVariant = L) } let { baseVariant: g, gestureVariant: b, defaultVariant: h, enabledGestures: m, isHovered: v, isPressed: w, isError: C, loadedBaseVariant: S } = u.current, R = QB(u.current.baseVariant, u.current.gestureVariant, o); return x.useMemo(() => { var E; let L = []; g !== h && L.push(g); let F = (E = m?.[g]) == null ? void 0 : E.loading, N = !C && !l && !!F && !S[g], A = N ? QS(g, "loading") : b; A && L.push(A); let K = m?.[g], U = { onMouseEnter: () => d({ isHovered: !0 }), onMouseLeave: () => d({ isHovered: !1 }) }; return K?.pressed && Object.assign(U, { onTapStart: () => d({ isPressed: !0 }), onTapCancel: () => d({ isPressed: !1 }), onTap: () => d({ isPressed: !1 }) }), { variants: L, baseVariant: g, gestureVariant: A, isLoading: N, transition: fz(u.current.transitions, g), setVariant: p, setGestureState: d, clearLoadingGesture: y, addVariantProps: R, gestureHandlers: U, classNames: $u(dz(g, s), ZS(K, v, w, N, C)) } }, [g, b, v, w, S, R, p, h, m, d, y, s]) } var pz = x.createContext(void 0), mz = () => x.useContext(pz); var gz = { Arial: { Regular: { selector: "Arial", weight: void 0 }, Black: { selector: "Arial-Black", weight: void 0 }, Narrow: { selector: "Arial Narrow", weight: void 0 }, "Rounded Bold": { selector: "Arial Rounded MT Bold", weight: void 0 } }, Avenir: { Book: { selector: "Avenir", weight: void 0 }, Light: { selector: "Avenir-Light", weight: void 0 }, Medium: { selector: "Avenir-Medium", weight: void 0 }, Heavy: { selector: "Avenir-Heavy", weight: void 0 }, Black: { selector: "Avenir-Black", weight: void 0 } }, "Avenir Next": { Regular: { selector: "Avenir Next", weight: void 0 }, "Ultra Light": { selector: "AvenirNext-UltraLight", weight: void 0 }, Medium: { selector: "AvenirNext-Medium", weight: void 0 }, "Demi Bold": { selector: "AvenirNext-DemiBold", weight: void 0 }, Heavy: { selector: "AvenirNext-Heavy", weight: void 0 } }, "Avenir Next Condensed": { Regular: { selector: "Avenir Next Condensed", weight: void 0 }, "Ultra Light": { selector: "AvenirNextCondensed-UltraLight", weight: void 0 }, Medium: { selector: "AvenirNextCondensed-Medium", weight: void 0 }, "Demi Bold": { selector: "AvenirNextCondensed-DemiBold", weight: void 0 }, Heavy: { selector: "AvenirNextCondensed-Heavy", weight: void 0 } }, Baskerville: { Regular: { selector: "Baskerville", weight: void 0 }, "Semi Bold": { selector: "Baskerville-SemiBold", weight: void 0 } }, "Bodoni 72": { Book: { selector: "Bodoni 72", weight: void 0 }, Oldstyle: { selector: "Bodoni 72 Oldstyle", weight: void 0 }, Smallcaps: { selector: "Bodoni 72 Smallcaps", weight: void 0 } }, Courier: { Regular: { selector: "Courier", weight: void 0 } }, "Courier New": { Regular: { selector: "Courier New", weight: void 0 } }, Futura: { Medium: { selector: "Futura", weight: void 0 }, Condensed: { selector: "Futura-CondensedMedium", weight: void 0 }, "Condensed ExtraBold": { selector: "Futura-CondensedExtraBold", weight: void 0 } }, Georgia: { Regular: { selector: "Georgia", weight: void 0 } }, "Gill Sans": { Regular: { selector: "Gill Sans", weight: void 0 }, Light: { selector: "GillSans-Light", weight: void 0 }, SemiBold: { selector: "GillSans-SemiBold", weight: void 0 }, UltraBold: { selector: "GillSans-UltraBold", weight: void 0 } }, Helvetica: { Regular: { selector: "Helvetica", weight: void 0 }, Light: { selector: "Helvetica-Light", weight: void 0 }, Bold: { selector: "Helvetica-Bold", weight: void 0 }, Oblique: { selector: "Helvetica-Oblique", weight: void 0 }, "Light Oblique": { selector: "Helvetica-LightOblique", weight: void 0 }, "Bold Oblique": { selector: "Helvetica-BoldOblique", weight: void 0 } }, "Helvetica Neue": { Regular: { selector: "Helvetica Neue", weight: void 0 }, UltraLight: { selector: "HelveticaNeue-UltraLight", weight: void 0 }, Thin: { selector: "HelveticaNeue-Thin", weight: void 0 }, Light: { selector: "HelveticaNeue-Light", weight: void 0 }, Medium: { selector: "HelveticaNeue-Medium", weight: void 0 }, Bold: { selector: "HelveticaNeue-Bold", weight: void 0 }, Italic: { selector: "HelveticaNeue-Italic", weight: void 0 }, "UltraLight Italic": { selector: "HelveticaNeue-UltraLightItalic", weight: void 0 }, "Thin Italic": { selector: "HelveticaNeue-ThinItalic", weight: void 0 }, "Light Italic": { selector: "HelveticaNeue-LightItalic", weight: void 0 }, "Medium Italic": { selector: "HelveticaNeue-MediumItalic", weight: void 0 }, "Bold Italic": { selector: "HelveticaNeue-BoldItalic", weight: void 0 }, "Condensed Bold": { selector: "HelveticaNeue-CondensedBold", weight: void 0 }, "Condensed Black": { selector: "HelveticaNeue-CondensedBlack", weight: void 0 } }, "Hoefler Text": { Regular: { selector: "Hoefler Text", weight: void 0 } }, Impact: { Regular: { selector: "Impact", weight: void 0 } }, "Lucida Grande": { Regular: { selector: "Lucida Grande", weight: void 0 } }, Menlo: { Regular: { selector: "Menlo", weight: void 0 } }, Monaco: { Regular: { selector: "Monaco", weight: void 0 } }, Optima: { Regular: { selector: "Optima", weight: void 0 }, ExtraBlack: { selector: "Optima-ExtraBlack", weight: void 0 } }, Palatino: { Regular: { selector: "Palatino", weight: void 0 } }, "SF Pro Display": { Regular: { selector: "__SF-UI-Display-Regular__", weight: 400 }, Ultralight: { selector: "__SF-UI-Display-Ultralight__", weight: 100 }, Thin: { selector: "__SF-UI-Display-Thin__", weight: 200 }, Light: { selector: "__SF-UI-Display-Light__", weight: 300 }, Medium: { selector: "__SF-UI-Display-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Display-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Display-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Display-Heavy__", weight: 800 }, Black: { selector: "__SF-UI-Display-Black__", weight: 900 }, Italic: { selector: "__SF-UI-Display-Italic__", weight: 400 }, "Ultralight Italic": { selector: "__SF-UI-Display-Ultralight-Italic__", weight: 100 }, "Thin Italic": { selector: "__SF-UI-Display-Thin-Italic__", weight: 200 }, "Light Italic": { selector: "__SF-UI-Display-Light-Italic__", weight: 300 }, "Medium Italic": { selector: "__SF-UI-Display-Medium-Italic__", weight: 500 }, "Semibold Italic": { selector: "__SF-UI-Display-Semibold-Italic__", weight: 600 }, "Bold Italic": { selector: "__SF-UI-Display-Bold-Italic__", weight: 700 }, "Heavy Italic": { selector: "__SF-UI-Display-Heavy-Italic__", weight: 800 }, "Black Italic": { selector: "__SF-UI-Display-Black-Italic__", weight: 900 } }, "SF Pro Display Condensed": { Regular: { selector: "__SF-UI-Display-Condensed-Regular__", weight: 400 }, Ultralight: { selector: "__SF-UI-Display-Condensed-Ultralight__", weight: 100 }, Thin: { selector: "__SF-UI-Display-Condensed-Thin__", weight: 200 }, Light: { selector: "__SF-UI-Display-Condensed-Light__", weight: 300 }, Medium: { selector: "__SF-UI-Display-Condensed-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Display-Condensed-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Display-Condensed-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Display-Condensed-Heavy__", weight: 800 }, Black: { selector: "__SF-UI-Display-Condensed-Black__", weight: 900 } }, "SF Pro Text": { Regular: { selector: "__SF-UI-Text-Regular__", weight: 400 }, Light: { selector: "__SF-UI-Text-Light__", weight: 200 }, Medium: { selector: "__SF-UI-Text-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Text-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Text-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Text-Heavy__", weight: 800 }, Italic: { selector: "__SF-UI-Text-Italic__", weight: 400 }, "Light Italic": { selector: "__SF-UI-Text-Light-Italic__", weight: 200 }, "Medium Italic": { selector: "__SF-UI-Text-Medium-Italic__", weight: 500 }, "Semibold Italic": { selector: "__SF-UI-Text-Semibold-Italic__", weight: 600 }, "Bold Italic": { selector: "__SF-UI-Text-Bold-Italic__", weight: 700 }, "Heavy Italic": { selector: "__SF-UI-Text-Heavy-Italic__", weight: 800 } }, "SF Pro Text Condensed": { Regular: { selector: "__SF-UI-Text-Condensed-Regular__", weight: 400 }, Light: { selector: "__SF-UI-Text-Condensed-Light__", weight: 200 }, Medium: { selector: "__SF-UI-Text-Condensed-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Text-Condensed-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Text-Condensed-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Text-Condensed-Heavy__", weight: 800 } }, Tahoma: { Regular: { selector: "Tahoma", weight: void 0 } }, Times: { Regular: { selector: "Times", weight: void 0 } }, "Times New Roman": { Regular: { selector: "Times New Roman", weight: void 0 } }, Trebuchet: { Regular: { selector: "Trebuchet MS", weight: void 0 } }, Verdana: { Regular: { selector: "Verdana", weight: void 0 } } }, vz = { "__SF-Compact-Display-Regular__": "SFCompactDisplay-Regular|.SFCompactDisplay-Regular", "__SF-Compact-Display-Ultralight__": "SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight", "__SF-Compact-Display-Thin__": "SFCompactDisplay-Thin|.SFCompactDisplay-Thin", "__SF-Compact-Display-Light__": "SFCompactDisplay-Light|.SFCompactDisplay-Light", "__SF-Compact-Display-Medium__": "SFCompactDisplay-Medium|.SFCompactDisplay-Medium", "__SF-Compact-Display-Semibold__": "SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold", "__SF-Compact-Display-Heavy__": "SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy", "__SF-Compact-Display-Black__": "SFCompactDisplay-Black|.SFCompactDisplay-Black", "__SF-Compact-Display-Bold__": "SFCompactDisplay-Bold|.SFCompactDisplay-Bold", "__SF-UI-Text-Regular__": ".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText", "__SF-UI-Text-Light__": ".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light", "__SF-UI-Text-Medium__": ".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium", "__SF-UI-Text-Semibold__": ".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold", "__SF-UI-Text-Bold__": ".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold", "__SF-UI-Text-Heavy__": ".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy", "__SF-UI-Text-Italic__": ".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic", "__SF-UI-Text-Light-Italic__": ".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic", "__SF-UI-Text-Medium-Italic__": ".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic", "__SF-UI-Text-Semibold-Italic__": ".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic", "__SF-UI-Text-Bold-Italic__": ".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic", "__SF-UI-Text-Heavy-Italic__": ".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic", "__SF-Compact-Text-Regular__": "SFCompactText-Regular|.SFCompactText-Regular", "__SF-Compact-Text-Light__": "SFCompactText-Light|.SFCompactText-Light", "__SF-Compact-Text-Medium__": "SFCompactText-Medium|.SFCompactText-Medium", "__SF-Compact-Text-Semibold__": "SFCompactText-Semibold|.SFCompactText-Semibold", "__SF-Compact-Text-Bold__": "SFCompactText-Bold|.SFCompactText-Bold", "__SF-Compact-Text-Heavy__": "SFCompactText-Heavy|.SFCompactText-Heavy", "__SF-Compact-Text-Italic__": "SFCompactText-Italic|.SFCompactText-Italic", "__SF-Compact-Text-Light-Italic__": "SFCompactText-LightItalic|.SFCompactText-LightItalic", "__SF-Compact-Text-Medium-Italic__": "SFCompactText-MediumItalic|.SFCompactText-MediumItalic", "__SF-Compact-Text-Semibold-Italic__": "SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic", "__SF-Compact-Text-Bold-Italic__": "SFCompactText-BoldItalic|.SFCompactText-BoldItalic", "__SF-Compact-Text-Heavy-Italic__": "SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic", "__SF-UI-Display-Condensed-Regular__": ".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular", "__SF-UI-Display-Condensed-Ultralight__": ".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight", "__SF-UI-Display-Condensed-Thin__": ".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin", "__SF-UI-Display-Condensed-Light__": ".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light", "__SF-UI-Display-Condensed-Medium__": ".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium", "__SF-UI-Display-Condensed-Semibold__": ".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold", "__SF-UI-Display-Condensed-Bold__": ".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold", "__SF-UI-Display-Condensed-Heavy__": ".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy", "__SF-UI-Display-Condensed-Black__": ".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black", "__SF-UI-Display-Regular__": ".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay", "__SF-UI-Display-Ultralight__": ".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight", "__SF-UI-Display-Thin__": ".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin", "__SF-UI-Display-Light__": ".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light", "__SF-UI-Display-Medium__": ".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium", "__SF-UI-Display-Semibold__": ".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold", "__SF-UI-Display-Bold__": ".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold", "__SF-UI-Display-Heavy__": ".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy", "__SF-UI-Display-Black__": ".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black", "__SF-UI-Display-Italic__": ".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic", "__SF-UI-Display-Ultralight-Italic__": ".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic", "__SF-UI-Display-Thin-Italic__": ".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic", "__SF-UI-Display-Light-Italic__": ".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic", "__SF-UI-Display-Medium-Italic__": ".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic", "__SF-UI-Display-Semibold-Italic__": ".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic", "__SF-UI-Display-Bold-Italic__": ".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic", "__SF-UI-Display-Heavy-Italic__": ".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic", "__SF-UI-Display-Black-Italic__": ".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic", "__SF-UI-Text-Condensed-Regular__": ".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular", "__SF-UI-Text-Condensed-Light__": ".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light", "__SF-UI-Text-Condensed-Medium__": ".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium", "__SF-UI-Text-Condensed-Semibold__": ".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold", "__SF-UI-Text-Condensed-Bold__": ".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold", "__SF-UI-Text-Condensed-Heavy__": ".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy", "__SF-Compact-Rounded-Regular__": "SFCompactRounded-Regular|.SFCompactRounded-Regular", "__SF-Compact-Rounded-Ultralight__": "SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight", "__SF-Compact-Rounded-Thin__": "SFCompactRounded-Thin|.SFCompactRounded-Thin", "__SF-Compact-Rounded-Light__": "SFCompactRounded-Light|.SFCompactRounded-Light", "__SF-Compact-Rounded-Medium__": "SFCompactRounded-Medium|.SFCompactRounded-Medium", "__SF-Compact-Rounded-Semibold__": "SFCompactRounded-Semibold|.SFCompactRounded-Semibold", "__SF-Compact-Rounded-Bold__": "SFCompactRounded-Bold|.SFCompactRounded-Bold", "__SF-Compact-Rounded-Heavy__": "SFCompactRounded-Heavy|.SFCompactRounded-Heavy", "__SF-Compact-Rounded-Black__": "SFCompactRounded-Black|.SFCompactRounded-Black" }, ek = gz; var yz = "System Default", bz = class { constructor() { T(this, "name", "local"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map), T(this, "fontAliasBySelector", new Map), T(this, "fontAliases", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } createFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.addFontFamily(t), t } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } importFonts() { let e = []; for (let r of Object.keys(ek)) { let i = ek[r]; if (!i) continue; let o = this.createFontFamily(r); for (let s of Object.keys(i)) { let a = i[s]; if (!a) continue; let { selector: l, weight: c } = a, u = { variant: s, selector: l, weight: c, family: o }; o.fonts.push(u) } e.push(...o.fonts) } for (let [r, i] of Object.entries(vz)) this.addFontAlias(r, i); let { fontFamily: t, aliases: n } = this.getSystemFontFamily(); this.addFontFamily(t); for (let [r, i] of n) this.addFontAlias(r, i); return e.push(...t.fonts), e } addFontAlias(e, t) { this.fontAliases.set(e, t), this.fontAliasBySelector.set(t, e) } getSystemFontFamily() { let e = "system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif", t = { name: yz, fonts: [], source: this.name }, n = new Map, r = [400, 100, 200, 300, 500, 600, 700, 800, 900], i = ["normal", "italic"]; for (let o of i) for (let s of r) { let a = xz(s, o), l = `__SystemDefault-${s}-${o}__`, c = { variant: a, selector: l, style: o, weight: s, family: t }; t.fonts.push(c), n.set(l, e) } return { fontFamily: t, aliases: n } } getFontAliasBySelector(e) { return this.fontAliasBySelector.get(e) || null } getFontSelectorByAlias(e) { return this.fontAliases.get(e) || null } isFontFamilyAlias(e) { return !!(e && /^__.*__$/u.exec(e)) } }, tk = { 100: "Thin", 200: "Extra Light", 300: "Light", 400: "Normal", 500: "Medium", 600: "Semi Bold", 700: "Bold", 800: "Extra Bold", 900: "Black" }; function xz(e, t) { let n = t === "normal" ? "Regular" : "Italic"; return e === 400 ? n : t !== "normal" ? `${tk[e]} ${n}` : `${tk[e]}` } var wz = Jn(Jm(), 1), ts = "CUSTOM;"; function Sz(e, t) { if (!t) return e.substring(0, e.lastIndexOf(".")); let n = t.font.preferredFamily === "" ? t.font.fontFamily : t.font.preferredFamily, r = t.font.preferredSubFamily === "" ? t.font.fontSubFamily : t.font.preferredSubFamily; return `${n} ${r}` } var kz = class { constructor() { T(this, "name", "custom"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map), T(this, "assetsByFamily", new Map) } importFonts(e) { var t, n; this.fontFamilies.length = 0, this.byFamilyName.clear(), this.assetsByFamily.clear(); let r = []; for (let i of e) { if (!this.isValidCustomFontAsset(i)) continue; let o = Sz(i.name, i.properties), s = this.createFontFamily(o), a = (t = i.properties) == null ? void 0 : t.font.openTypeData, l = { family: s, selector: `${ts}${o}`, variant: this.inferVariantName(o), postscriptName: (n = i.properties) == null ? void 0 : n.font.postscriptName, file: i.url, openTypeFeatures: this.validateOpenTypeData(a) }; s.fonts.push(l), s.owner = i.ownerType === "team" ? "team" : "project", this.assetsByFamily.set(o, i), r.push(...s.fonts) } return r } isValidCustomFontAsset(e) { var t; return !e.mimeType.startsWith("font/") || ((t = e.properties) == null ? void 0 : t.kind) !== "font" || !e.properties.font ? !1 : "fontFamily" in e.properties.font } validateOpenTypeData(e) { if (e && Array.isArray(e)) return e.map(t => { if (this.isOpenTypeFeature(t)) return { tag: t.tag, coverage: t.coverage } }) } isOpenTypeFeature(e) { return !(typeof e != "object" || e === null || !("tag" in e) || typeof e.tag != "string" || "coverage" in e && typeof e.coverage < "u" && !Array.isArray(e.coverage)) } inferVariantName(e) { let t = ["thin", "ultra light", "extra light", "light", "normal", "medium", "semi bold", "bold", "extra bold", "black"], n = [...t.map(s => `${s} italic`), ...t], r = e.toLowerCase(), i = [...r.split(" "), ...r.split("-"), ...r.split("_")], o = n.find(s => i.includes(s) || i.includes(s.replace(/\s+/gu, ""))); return o ? o.replace(/^\w|\s\w/gu, s => s.toUpperCase()) : "Regular" } createFontFamily(e) { let t = this.byFamilyName.get(e); if (t) return t; let n = { source: this.name, name: e, fonts: [] }; return this.addFontFamily(n), n } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } parseSelector(e) { if (!e.startsWith(ts)) return null; let t = e.split(ts); return t[1] === void 0 ? null : { source: "custom", name: t[1] } } getFontBySelector(e, t = !0) { let n = this.parseSelector(e); if (!n || !t && !this.byFamilyName.get(n.name)) return; let r = this.getFontFamilyByName(n.name).fonts; return r.find(o => { var s; return (s = o.file) == null ? void 0 : s.endsWith(".woff2") }) || r[0] } getFontFamilyByName(e) { let t = this.byFamilyName.get(e); if (t) return t; let n = { source: "custom", name: e, fonts: [] }; return n.fonts.push({ selector: `${ts}${e}`, variant: this.inferVariantName(e), family: n }), n } }; function sT(e, t, n) { if (t.length === 0) return {}; let r = n(e); if (!r) return {}; let { weight: i, style: o } = r, s = new Map, a = new Map; t.forEach(f => { let d = ce(f) ? f : f.name.toLocaleLowerCase(), p = n(d); p && (s.set(`${p.weight}-${p.style}`, d), !(p.weight <= i) && (a.has(p.style) || a.set(p.style, d))) }); let l = a.get(o), c = a.get("italic") ?? a.get("oblique"); r.weight <= 300 ? (l = s.get(`400-${o}`) ?? l, c = s.get("400-italic") ?? s.get("400-oblique") ?? c) : r.weight <= 500 ? (l = s.get(`700-${o}`) ?? l, c = s.get("700-italic") ?? s.get("700-oblique") ?? c) : (l = s.get(`900-${o}`) ?? l, c = s.get("900-italic") ?? s.get("900-oblique") ?? c); let u = s.get(`${i}-italic`) ?? s.get(`${i}-oblique`); return { variantBold: l, variantItalic: u, variantBoldItalic: c } } var Cz = ["display", "sans", "serif", "slab", "handwritten", "script"]; function Tz(e) { return e.split(",").map(t => t.trim().toLowerCase()).filter(Ez) } function Ez(e) { return Cz.includes(e) } var Mu = "FS;", aT = { thin: 100, hairline: 100, extralight: 200, light: 300, regular: 400, medium: 500, semibold: 600, bold: 700, extrabold: 800, ultra: 800, black: 900, heavy: 900 }, lT = Object.keys(aT), Rz = (() => new RegExp(`^(?:${[...lT, "italic"].join("|")})`, "u"))(), bi = class { constructor() { T(this, "name", "fontshare"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { let t = e.split(" "), n = lT.find(s => t.includes(s)), r = e.includes("italic") ? "italic" : "normal"; return { weight: n && aT[n] || 400, style: r === "italic" ? r : "normal" } } parseSelector(e) { if (!e.startsWith(Mu)) return null; let t = e.split("-"); if (t.length !== 2) return null; let [n, r] = t; return !n || !r ? null : { name: n.replace(Mu, ""), variant: r, source: this.name } } static createSelector(e, t) { return `${Mu}${e}-${t.toLowerCase()}` } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; for (let n of e) { let r = n.font_styles.filter(i => { let o = i.name.toLowerCase(); return !(!Rz.exec(o) || o.endsWith("wide")) }); for (let i of r) { let { name: o } = n, s = i.name.toLowerCase(), a = this.getFontFamilyByName(o); a || (a = { name: o, fonts: [], source: this.name }, this.addFontFamily(a)); let l = bi.createSelector(o, s), c = bi.parseVariant(s) || { weight: void 0, style: void 0 }, { weight: u, style: f } = c, { variantBold: d, variantBoldItalic: p, variantItalic: y } = sT(s, r, bi.parseVariant), g = { family: a, variant: s, selector: l, selectorBold: d ? bi.createSelector(o, d) : void 0, selectorBoldItalic: p ? bi.createSelector(o, p) : void 0, selectorItalic: y ? bi.createSelector(o, y) : void 0, weight: u, style: f, file: i.file, category: Pz(n.category) }; a.fonts.push(g), t.push(g) } } return t } }; function Pz(e) { let t = { serif: "serif", sans: "sans-serif", slab: "slab", display: "display", handwritten: "handwriting", script: "handwriting" }, n = Tz(e)[0]; return n && t[n] } var _z = "Inter", Fz = "FR;", Iz = { Thin: 100, ExtraLight: 200, Light: 300, "": 400, Medium: 500, SemiBold: 600, Bold: 700, ExtraBold: 800, Black: 900 }, nk = class { constructor() { T(this, "name", "framer"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } static getDraftFontPropertiesBySelector(e) { if (!e.startsWith(Fz) && !e.startsWith(_z)) return null; let t = e.split("-"), [n, r = ""] = t; if (!n) return null; let i = r.includes("Italic") ? "italic" : "normal", o = r.replace("Italic", ""), s = o && Iz[o] || 400; return { family: n, style: i, weight: s, source: "framer", variant: void 0, category: "sans-serif" } } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; return e.forEach(n => { let { familyName: r, ...i } = n, o = this.getFontFamilyByName(r); o || (o = this.addFontFamily(r)); let s = { ...i, family: o }; o.fonts.push(s), t.push(s) }), t } }, Ou = "GF;", xi = class { constructor() { T(this, "name", "google"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { if (e === "regular") return { style: "normal", weight: 400 }; let t = /(\d*)(normal|italic)?/.exec(e); if (!t) return null; let n = parseInt(t[1] || "400"), r = t[2] === "italic" ? "italic" : "normal"; return { weight: n, style: r } } parseSelector(e) { if (!e.startsWith(Ou)) return null; let t = e.split("-"); if (t.length !== 2) return null; let [n, r] = t; return !n || !r ? null : { name: n.replace(Ou, ""), variant: r, source: this.name } } static createSelector(e, t) { return `${Ou}${e}-${t}` } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; return e.forEach(n => { n.variants.forEach(r => { var i; let o = n.family, s = this.getFontFamilyByName(o); s || (s = this.addFontFamily(o)); let a = xi.parseVariant(r) ?? {}, { weight: l, style: c } = a, u = xi.createSelector(o, r), { variantBold: f, variantItalic: d, variantBoldItalic: p } = sT(r, n.variants, xi.parseVariant), y = { family: s, variant: r, selector: u, selectorBold: f ? xi.createSelector(o, f) : void 0, selectorBoldItalic: p ? xi.createSelector(o, p) : void 0, selectorItalic: d ? xi.createSelector(o, d) : void 0, weight: l, style: c, category: Lz(n.category), file: (i = n.files[r]) == null ? void 0 : i.replace("http://", "https://") }; s.fonts.push(y), t.push(y) }) }), t } }; function Lz(e) { let t = { serif: "serif", "sans-serif": "sans-serif", display: "display", handwriting: "handwriting", monospace: "monospace" }; if (e) return t[e] } var Mz = Jn(JL(), 1), rk = 5e3, Oz = 3, cT = class extends Error { constructor(e) { super(e), this.name = "FontLoadingError" } }, Em = new Map, Rm = new Map, Dz = (e, t) => uT(e, t); async function uT(e, t, n = 0) { let { family: r, url: i, stretch: o, unicodeRange: s } = e, a = e.weight || 500, l = e.style || "normal", c = `${r}-${l}-${a}-${i}`; if (!Em.has(c) || n > 0) { let u = new FontFace(r, `url(${i})`, { weight: ce(a) ? a : a?.toString(), style: l, stretch: o, unicodeRange: s }), f = u.load().then(() => (t.fonts.add(u), fT(r, l, a))).catch(d => { if (d.name !== "NetworkError") throw d; if (n < Oz) return uT(e, t, n + 1); throw new cT(`Font loading failed after ${n} retries due to network error: ${JSON.stringify({ family: r, style: l, weight: a, url: i, stretch: o, unicodeRange: s })}`) }); Em.set(c, f) } await Em.get(c) } async function fT(e, t, n) { let r = `${e}-${t}-${n}`; if (!Rm.has(r)) { let o = new Mz.default(e, { style: t, weight: n }).load(null, rk); Rm.set(r, o) } try { await Rm.get(r) } catch { throw new cT(`Failed to check if font is ready (${rk}ms timeout exceeded): ${JSON.stringify({ family: e, style: t, weight: n })}`) } } var Az = class { constructor() { T(this, "enabled", !1), T(this, "bySelector", new Map), T(this, "getGoogleFontsListPromise"), T(this, "getFontshareFontsListPromise"), T(this, "loadedSelectors", new Set), T(this, "local"), T(this, "google"), T(this, "fontshare"), T(this, "framer"), T(this, "custom"), this.local = new bz, this.google = new xi, this.fontshare = new bi, this.framer = new nk, this.custom = new kz, this.bySelector = new Map, this.importLocalFonts() } addFont(e) { this.bySelector.set(e.selector, e) } getAvailableFonts() { return Array.from(this.bySelector.values()) } importLocalFonts() { for (let e of this.local.importFonts()) this.addFont(e), this.loadFont(e) } async importGoogleFonts() { if (!this.getGoogleFontsListPromise) { this.getGoogleFontsListPromise = ut.fetchGoogleFontsList(); let e = await this.getGoogleFontsListPromise; for (let t of this.google.importFonts(e)) this.addFont(t) } return this.getGoogleFontsListPromise } async importFontshareFonts() { if (!this.getFontshareFontsListPromise) { this.getFontshareFontsListPromise = ut.fetchFontshareFontsList(); let e = await this.getFontshareFontsListPromise; for (let t of this.fontshare.importFonts(e)) this.addFont(t) } return this.getFontshareFontsListPromise } importFramerFonts(e) { this.framer.importFonts(e).forEach(t => { this.addFont(t) }) } importCustomFonts(e) { this.bySelector.forEach((t, n) => { n.startsWith(ts) && this.bySelector.delete(n) }); for (let t of this.custom.importFonts(e)) this.addFont(t) } getFontFamily(e) { return this[e.source].getFontFamilyByName(e.name) } getFontBySelector(e, t = !0) { if (e) return e.startsWith(ts) ? this.custom.getFontBySelector(e, t) : this.bySelector.get(e) } getDraftPropertiesBySelector(e) { let t = this.getFontBySelector(e); if (t) return { style: t.style, weight: t.weight, variant: t.variant, family: t.family.name, source: t.family.source, category: t.category }; let n = this.google.parseSelector(e); if (n) { let o = xi.parseVariant(n.variant); if (o) return { style: o.style, weight: o.weight, variant: n.variant, family: n.name, source: "google", category: void 0 } } let r = this.fontshare.parseSelector(e); if (r) { let o = bi.parseVariant(r.variant); if (o) return { style: o.style, weight: o.weight, variant: r.variant, family: r.name, source: "fontshare", category: void 0 } } let i = nk.getDraftFontPropertiesBySelector(e); return i || null } isSelectorLoaded(e) { return this.loadedSelectors.has(e) } async loadFont(e) { if (this.isSelectorLoaded(e.selector)) return 0; let t = e.family.source; switch (t) { case "local": return this.loadedSelectors.add(e.selector), 1; case "framer": return wz.default.env.NODE_ENV !== "test" && await fT(e.family.name, e.style, e.weight), this.loadedSelectors.add(e.selector), 1; case "google": case "fontshare": case "custom": return e.file ? (await Dz({ family: e.family.name, url: e.file, weight: e.weight, style: e.style }, document), this.loadedSelectors.add(e.selector), 1) : Promise.reject(`Unable to load font: ${e.selector}`); default: xe(t) } } async loadFontsFromSelectors(e) { if (!this.enabled) return []; let t = e.some(i => i.startsWith(Ou)), n = e.some(i => i.startsWith(Mu)); if (t || n) { try { await this.importFontshareFonts() } catch (i) { za("Failed to load Fontshare fonts:", i) } try { await this.importGoogleFonts() } catch (i) { za("Failed to load Google fonts:", i) } } let r = e.map(i => this.bySelector.get(i)).filter(i => !!i); return Promise.allSettled(r.map(i => this.loadFont(i))) } async loadFonts(e) { return { newlyLoadedFontCount: (await this.loadFontsFromSelectors(e)).filter(r => r.status === "fulfilled" && r.value === 1).length } } async loadMissingFonts(e, t) { let n = e.filter(i => !Du.isSelectorLoaded(i)); if (n.length === 0) return; await Du.loadWebFontsFromSelectors(n), n.every(i => Du.isSelectorLoaded(i)) && t && t() } async loadWebFontsFromSelectors(e) { return this.loadFontsFromSelectors(e) } get defaultFont() { let e = this.getFontBySelector("Inter"); return $(e, "Can\u2019t find Inter font"), e } }, Du = new Az; Promise.allSettled = Promise.allSettled || (e => Promise.all(e.map(t => t.then(n => ({ status: "fulfilled", value: n })).catch(n => ({ status: "rejected", reason: n }))))); var dT = (e => (e.Padding = "--framer-input-padding", e.BorderRadiusTopLeft = "--framer-input-border-radius-top-left", e.BorderRadiusTopRight = "--framer-input-border-radius-top-right", e.BorderRadiusBottomRight = "--framer-input-border-radius-bottom-right", e.BorderRadiusBottomLeft = "--framer-input-border-radius-bottom-left", e.BorderColor = "--framer-input-border-color", e.BorderTopWidth = "--framer-input-border-top-width", e.BorderRightWidth = "--framer-input-border-right-width", e.BorderBottomWidth = "--framer-input-border-bottom-width", e.BorderLeftWidth = "--framer-input-border-left-width", e.BorderStyle = "--framer-input-border-style", e.Background = "--framer-input-background", e.FontFamily = "--framer-input-font-family", e.FontWeight = "--framer-input-font-weight", e.FontSize = "--framer-input-font-size", e.FontColor = "--framer-input-font-color", e.FontStyle = "--framer-input-font-style", e.FontLetterSpacing = "--framer-input-font-letter-spacing", e.FontTextAlignment = "--framer-input-font-text-alignment", e.FontLineHeight = "--framer-input-font-line-height", e.PlaceholderColor = "--framer-input-placeholder-color", e.BoxShadow = "--framer-input-box-shadow", e.FocusedBorderColor = "--framer-input-focused-border-color", e.FocusedBorderWidth = "--framer-input-focused-border-width", e.FocusedBorderStyle = "--framer-input-focused-border-style", e.FocusedBackground = "--framer-input-focused-background", e.FocusedBoxShadow = "--framer-input-focused-box-shadow", e.FocusedTransition = "--framer-input-focused-transition", e.BooleanCheckedBackground = "--framer-input-boolean-checked-background", e.BooleanCheckedBorderColor = "--framer-input-boolean-checked-border-color", e.BooleanCheckedBorderWidth = "--framer-input-boolean-checked-border-width", e.BooleanCheckedBorderStyle = "--framer-input-boolean-checked-border-style", e.BooleanCheckedBoxShadow = "--framer-input-boolean-checked-box-shadow", e.BooleanCheckedTransition = "--framer-input-boolean-checked-transition", e.InvalidTextColor = "--framer-input-invalid-text-color", e.IconBackgroundImage = "--framer-input-icon-image", e.IconMaskImage = "--framer-input-icon-mask-image", e.IconColor = "--framer-input-icon-color", e.WrapperHeight = "--framer-input-wrapper-height", e))(dT || {}), Ce = dT, ik = "framer-form-input", Vz = "framer-form-input-wrapper"; function Bz(e) { return typeof e == "number" ? e : e.startsWith("--") ? xt.variable(e) : e === "" ? '""' : e } function xt(e, t) { let n = " "; for (let r in t) { let i = t[r]; n += `${r.replace(/([A-Z])/gu, "-$1").toLowerCase()}: ${Bz(i)}; ` } return e + " {" + n + "}" } (e => { function t(...n) { let r = n[n.length - 1], i = r.startsWith("--") ? `var(${r})` : r; for (let o = n.length - 2; o >= 0; o--)i = `var(${n[o]}, ${i})`; return i } e.variable = t })(xt || (xt = {})); var ZW = [xt(`.${ik}`, { padding: xt.variable(Ce.Padding), background: "transparent", fontFamily: xt.variable(Ce.FontFamily), fontWeight: xt.variable(Ce.FontWeight), fontSize: xt.variable(Ce.FontSize), fontStyle: xt.variable(Ce.FontStyle), color: xt.variable(Ce.FontColor), border: "none", textOverflow: "ellipsis", whiteSpace: "nowrap", overflow: "hidden", width: "100%", height: xt.variable(Ce.WrapperHeight, "100%"), letterSpacing: xt.variable(Ce.FontLetterSpacing), textAlign: xt.variable(Ce.FontTextAlignment), lineHeight: xt.variable(Ce.FontLineHeight) }), xt(`.${ik}:focus-visible`, { outline: "none" })]; var JW = `var(${Ce.BorderTopWidth}) var(${Ce.BorderRightWidth}) var(${Ce.BorderBottomWidth}) var(${Ce.BorderLeftWidth})`, eU = [`.${Vz}:after {
        content: "";
        pointer-events: none;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top-left-radius: var(${Ce.BorderRadiusTopLeft});
        border-top-right-radius: var(${Ce.BorderRadiusTopRight});
        border-bottom-right-radius: var(${Ce.BorderRadiusBottomRight});
        border-bottom-left-radius: var(${Ce.BorderRadiusBottomLeft});
        border-color: var(${Ce.BorderColor});
        border-top-width: var(${Ce.BorderTopWidth});
        border-right-width: var(${Ce.BorderRightWidth});
        border-bottom-width: var(${Ce.BorderBottomWidth});
        border-left-width: var(${Ce.BorderLeftWidth});
        border-style: var(${Ce.BorderStyle});
        transition: var(${Ce.FocusedTransition});
        transition-property: border-color, border-width, border-style, border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius;
    }`]; var Pm = 16, tU = { content: "", display: "block", position: "absolute", right: 0, top: 0, bottom: 0, width: `${Pm}px`, boxSizing: "content-box", padding: xt.variable(Ce.Padding), border: "none", pointerEvents: "none", backgroundRepeat: "no-repeat", backgroundSize: `${Pm}px`, maskRepeat: "no-repeat", maskSize: `${Pm}px`, backgroundColor: xt.variable(Ce.IconColor) }; var uU = x.forwardRef(function (t, n) { let { background: r, children: i, alt: o, ...s } = t, a = { ...s.style }; r && delete a.background; let l = nl(t.as); return ue(l, { ...s, style: a, ref: n, children: [r && k(Xk, { image: r, alt: o }), i] }) }); function zz(e, t) { return e.length === t.length && e.every((n, r) => n === t[r]) } var $z = /[^\p{Letter}\p{Number}()]+/gu, Nz = /^-+|-+$/gu; function Hz(e) { return e.toLowerCase().replace($z, "-").replace(Nz, "") } var jz = /[&<>'"]/g, Wz = e => e.replace(jz, t => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" })[t] || t), Uz = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi; function Gz(e, t, n, r) { return e.replace(Uz, (i, o, s, a, l, c, u) => { var f, d; if (s.toLowerCase() !== "a") return i; let p = l || c, y = vg(p.replace(/&amp;/g, "&")); if (!y || !y.target) return i; let g = t(y.target); if (!iS(g) || !iS(n)) return i; let b = g.path, h = n.path; if (!b || !h) return i; let m = ` data-framer-page-link-target="${y.target}"`, v = Zu(g, y.element ?? void 0); v && (m += ` data-framer-page-link-element="${y.element}"`); let w = Wu(p); if (!w || ce(w)) return i; OC(n, w, r) && (m += " data-framer-page-link-current"); let C = b, S = Object.assign({}, r, (f = y.collectionItem) == null ? void 0 : f.pathVariables); if (Object.keys(S).length > 0 && (C = C.replace(LC, (R, E) => "" + S[E])), (d = y.collectionItem) != null && d.pathVariables) { let R = new URLSearchParams(y.collectionItem.pathVariables); m += ` data-framer-page-link-path-variables="${R}"` } return C = vk(h, C), o + a + `"${Wz(C + (v ? `#${v}` : ""))}"` + m + u }) } var qz = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, hT = /[&<>"']/gu, Xz = (() => new RegExp(hT.source))(); function ok(e) { return e && Xz.test(e) ? e.replace(hT, t => qz[t] ?? "") : e || "" } var sk = "{{ text-placeholder }}", Yz = "rich-text-wrapper", Kz = Oe(function (t, n) { let { id: r, name: i, html: o, htmlFromDesign: s, text: a, textFromDesign: l, fonts: c = [], width: u, height: f, left: d, right: p, top: y, bottom: g, center: b, className: h, stylesPresetsClassName: m, visible: v = !0, opacity: w, rotation: C = 0, verticalAlignment: S = "top", isEditable: R = !1, willChangeTransform: E, environment: L = le.current, withExternalLayout: F = !1, positionSticky: N, positionStickyTop: A, positionStickyRight: K, positionStickyBottom: U, positionStickyLeft: H, __htmlStructure: W, __fromCanvasComponent: ee = !1, _forwardedOverrideId: te, _forwardedOverrides: q, _usesDOMRect: ne, children: be, ...re } = t, pe = Ja(), ie = rl(t), ht = D(null), Fe = n ?? ht, { navigate: Lt, getRoute: Se } = cs(), Zt = Qa(); uO(t.preload ?? []), rf(t, Fe); let Pn = V(us), _n = ll(), me = a, Gn = te ?? r; if (Gn && q) { let Xe = q[Gn]; typeof Xe == "string" && (me = Xe) } let ot = ""; if (me) { let Xe = ok(me); ot = W ? W.replace(sk, Xe) : `<p>${Xe}</p>` } else if (o) ot = o; else if (l) { let Xe = ok(l); ot = W ? W.replace(sk, Xe) : `<p>${Xe}</p>` } else s && (ot = s); let hn = MC(), cl = ae(() => _n || !Se || !Zt ? ot : Gz(ot, Se, Zt, hn), [_n, ot, Se, Zt, hn]); if (z(() => { let Xe = Fe.current; if (Xe === null) return; function mr(Jt) { let Ci = gg(Jt.target, Fe.current); if (Jt.metaKey || !Lt || !Ci || Ci.getAttribute("target") === "_blank") return; R5(Lt, Ci, hn) && Jt.preventDefault() } return Xe.addEventListener("click", mr), () => { Xe.removeEventListener("click", mr) } }, [Lt, hn]), mT(c, ee, Fe), st(() => { el() }, []), !v) return null; let P = R && L() === le.canvas, _ = { outline: "none", display: "flex", flexDirection: "column", justifyContent: pT(S), opacity: P ? 0 : w, flexShrink: 0 }, O = le.hasRestrictions(), j = $a(t, pe || 0, !1), ge = ne && (u === "auto" || f === "auto"), pt = !!t.transformTemplate || !j || !O || ee || ge ? t.transformTemplate ?? tf(b) : void 0; if (!F) { if (j && O && !ge) { let Xe = it.getNumber(C).toFixed(4); _.transform = `translate(${j.x}px, ${j.y}px) rotate(${Xe}deg)`, _.width = j.width, _.minWidth = j.width, _.height = j.height } else _.left = d, _.right = p, _.top = y, _.bottom = g, _.width = u, _.height = f, _.rotate = C; N ? (!_n || Pn) && (_.position = "sticky", _.willChange = "transform", _.zIndex = 1, _.top = A, _.right = K, _.bottom = U, _.left = H) : _n && (t.positionFixed || t.positionAbsolute) && (_.position = "absolute") } return pg(t, _), lC(t, _), E && fg(_), Object.assign(_, t.style), k(vn.div, { id: r, ref: Fe, ...re, style: _, layoutId: ie, "data-framer-name": i, "data-framer-component-type": "DeprecatedRichText", "data-center": b, className: $u(h, m, Yz), transformTemplate: pt, dangerouslySetInnerHTML: { __html: cl } }) }); function pT(e) { switch (e) { case "top": return "flex-start"; case "center": return "center"; case "bottom": return "flex-end" } } function mT(e, t, n) { let r = D([]); zz(r.current, e) || (r.current = e, Du.loadFonts(e).then(({ newlyLoadedFontCount: i }) => { !t || !n.current || le.current() !== le.canvas || i > 0 && NA(n.current) })) } var gT = { opacity: 1, y: 0, x: 0, scale: 1, rotate: 0, rotateX: 0, rotateY: 0, skewX: 0, skewY: 0, filter: "none" }; function Qz(e) { return e in gT } function Zz(e) { let t = {}; for (let n in e) !Qz(n) || Je(e[n]) || (t[n] = [e[n], gT[n]]); return t } var Jz = /\p{Regional_Indicator}{2}|\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?(?:\u{200d}\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?)*|./gu; function e$(e, t = "character", n, r) { switch (t) { case "character": case "line": { let i = e.split(" "), o = i.length - 1; return i.map((s, a) => { var l; let c = a === o, u = s.length <= 12; return ue(He, { children: [k("span", { style: { whiteSpace: u ? "nowrap" : "unset" }, children: (l = s.match(Jz)) == null ? void 0 : l.map((f, d) => { let p = oo(); return n.add(p), k("span", { ref: p, style: r, children: f }, f + d) }) }, s + a), c ? null : " "] }) }) } case "word": { let i = e.split(" "), o = i.length - 1; return i.map((s, a) => { let l = a === o, c = oo(); return n.add(c), ue(He, { children: [k("span", { ref: c, style: r, children: s }, s + a), l ? null : " "] }) }) } case "element": default: return e } } function t$(e) { let t = e.type; switch (t) { case "appear": return e.tokenization ?? "character"; default: xe(t) } } function ak(e) { let t = []; return Ve(e.x) && t.push(`translateX(${e.x}px)`), Ve(e.y) && t.push(`translateY(${e.y}px)`), Ve(e.scale) && t.push(`scale(${e.scale})`), Ve(e.rotate) && t.push(`rotate(${e.rotate}deg)`), Ve(e.rotateX) && t.push(`rotateX(${e.rotateX}deg)`), Ve(e.rotateY) && t.push(`rotateY(${e.rotateY}deg)`), Ve(e.skewX) && t.push(`skewX(${e.skewX}deg)`), Ve(e.skewY) && t.push(`skewY(${e.skewY}deg)`), t.join(" ") } function n$(e, t, n) { if (!n || !n.effect) return; let r = n.type; switch (r) { case "appear": switch (n.tokenization) { case "element": return !e || !t ? void 0 : { opacity: n.effect.opacity, filter: n.effect.filter, transform: ak(n.effect) }; case "line": case "word": case "character": default: return !e || !t ? { display: "inline-block" } : { display: "inline-block", opacity: n.effect.opacity, filter: n.effect.filter, transform: ak(n.effect) } }default: xe(r) } } function r$(e, t, n) { let r = Qt(() => new Set), i = ll(), o = n || !i, s = D({ hasMounted: !1, hasAnimatedOnce: !1, isAnimating: !1, effect: e }); s.current.effect = e; let a = e?.trigger ?? "onMount", l = e?.target, c = e?.threshold; z(() => { if (!o || n) return; s.current.hasMounted = !0; function d() { let { effect: p } = s.current; if (!o || !p || p?.repeat !== !0 && s.current.hasAnimatedOnce || p?.type === "appear" && s.current.isAnimating) return; Object.assign(s.current, { hasAnimatedOnce: !0, isAnimating: !0 }); let y = p.type; switch (y) { case "appear": { let { transition: g, startDelay: b, repeat: h, tokenization: m } = p; return lk(m, p.effect, r, g, b, h, () => { Object.assign(s.current, { isAnimating: !1 }) }) } default: xe(y) } } switch (a) { case "onMount": d(); return; case "onInView": { let p = t?.current; return p ? ql(p, d, { amount: c ?? 0 }) : void 0 } case "onScrollTarget": { let p = l?.ref.current; return p ? ql(p, d, { amount: c ?? 0, root: document, margin: l?.offset ? `${l.offset}px 0px 0px 0px` : void 0 }) : void 0 } default: xe(a) } }, [o, r, n, t, l, c, a]); let u = !!e, f = e ? t$(e) : void 0; return ae(() => ({ getTokenizer: () => { if (r.clear(), !u) return; let { hasMounted: d, hasAnimatedOnce: p, effect: y } = s.current, g = n$(o, n || i$(d, p, y), s.current.effect); return { text: b => e$(b, f, r, g), props: b => { if (y?.tokenization !== "element") return; let h = oo(); return r.add(h), { ref: h, style: { ...b, ...g } } } } }, play: () => { let { effect: d } = s.current; if (!d) return; let p = d.type; switch (p) { case "appear": { let { transition: y, startDelay: g } = d; lk(f, d.effect, r, y, g); break } default: xe(p) } } }), [o, u, r, n, f]) } function i$(e, t, n) { return !(e && n?.trigger === "onMount" || t && !n?.repeat && (n?.trigger === "onInView" || n?.trigger === "onScrollTarget")) } function lk(e = "character", t, n, r, i = 0, o = !1, s) { let a = Zz(t); switch (e) { case "character": case "element": case "word": { let l = o$(n); return l.length === 0 || (nr(l, a, { ...r, restDelta: .001, delay: qd(r?.delay ?? 0, { startDelay: i }) }).then(() => s?.()), !o) ? void 0 : () => void nr(l, t, { ...r, restDelta: .001, delay: qd(r?.delay ?? 0, { startDelay: i }) }) } case "line": { let l; return Y.read(() => { l = s$(n), l.length !== 0 && Y.update(() => { let c = l.map((u, f) => nr(u, a, { ...r, restDelta: .001, delay: i + f * (r?.delay ?? 0) })); Promise.all(c).then(() => s?.()) }) }), o ? () => { l.length !== 0 && l.forEach((c, u) => { nr(c, t, { ...r, restDelta: .001, delay: i + u * (r?.delay ?? 0) }) }) } : void 0 } default: xe(e) } } function o$(e) { let t = []; for (let n of e) n.current && t.push(n.current); return t } function s$(e) { let t = [], n = [], r = null; for (let i of e) { if (!i.current) continue; let o = i.current.offsetTop, s = i.current.offsetHeight; !s || r === null || o === r ? n.push(i.current) : (t.push(n), n = [i.current]), s && (r = o) } return t.push(n), t } var ck = Oe(({ viewBoxScale: e, viewBox: t, children: n, ...r }, i) => k(vn.svg, { ref: i, ...r, viewBox: t, children: k(vn.foreignObject, { width: "100%", height: "100%", className: "framer-fit-text", transform: `scale(${e})`, style: { overflow: "visible", transformOrigin: "center center" }, children: n }) })), a$ = Oe((e, t) => { let { __fromCanvasComponent: n = !1, _forwardedOverrideId: r, _forwardedOverrides: i, _usesDOMRect: o, anchorLinkOffsetY: s, as: a, bottom: l, center: c, children: u, environment: f = le.current, fonts: d = [], height: p, isEditable: y = !1, left: g, name: b, opacity: h, positionSticky: m, positionStickyBottom: v, positionStickyLeft: w, positionStickyRight: C, positionStickyTop: S, right: R, rotation: E = 0, style: L, _initialStyle: F, stylesPresetsClassNames: N, text: A, top: K, verticalAlignment: U = "top", visible: H = !0, width: W, willChangeTransform: ee, withExternalLayout: te = !1, viewBox: q, viewBoxScale: ne = 1, effect: be, ...re } = e, pe = Ja(), ie = ll(), ht = V(us), Fe = rl(e), Lt = D(null), Se = t ?? Lt; rf(e, Se), mT(d, n, Se), st(() => { el() }, []); let Zt = r$(be, Se), Pn = ae(() => { if (u) return vT(u, N, A, s, void 0, Zt.getTokenizer()) }, [u, N, A, s, Zt]); if (!H) return null; let _n = y && f() === le.canvas, me = { outline: "none", display: "flex", flexDirection: "column", justifyContent: pT(U), opacity: _n ? 0 : h, flexShrink: 0 }, Gn = le.hasRestrictions(), ot = $a(e, pe || 0, !1), hn = o && (W === "auto" || p === "auto"), P = !!e.transformTemplate || !ot || !Gn || n || hn ? e.transformTemplate ?? tf(c) : void 0; te || (ot && Gn && !hn ? (me.x = ot.x, me.y = ot.y, me.rotate = it.getNumber(E), me.width = ot.width, me.minWidth = ot.width, me.height = ot.height) : (me.left = g, me.right = R, me.top = K, me.bottom = l, me.width = W, me.height = p, me.rotate = E), m ? (!ie || ht) && (me.position = "sticky", me.willChange = "transform", me.zIndex = 1, me.top = S, me.right = C, me.bottom = v, me.left = w) : ie && (e.positionFixed || e.positionAbsolute) && (me.position = "absolute")), pg(e, me), lC(e, me), ee && fg(me), Object.assign(me, F, L), Fe && (re.layout = "preserve-aspect"); let _ = nl(e.as); return ce(e.viewBox) ? e.as !== void 0 ? k(_, { ...re, ref: Se, style: me, layoutId: Fe, transformTemplate: P, "data-framer-name": b, "data-framer-component-type": "RichTextContainer", children: k(ck, { viewBox: q, viewBoxScale: ne, style: { width: "100%", height: "100%" }, children: Pn }) }) : k(ck, { ...re, ref: Se, style: me, layoutId: Fe, viewBox: q, viewBoxScale: ne, transformTemplate: P, "data-framer-name": b, "data-framer-component-type": "RichTextContainer", children: Pn }) : k(_, { ...re, ref: Se, style: me, layoutId: Fe, transformTemplate: P, "data-framer-name": b, "data-framer-component-type": "RichTextContainer", children: Pn }) }); function l$(e) { return e.type === gr } function c$(e) { return e.type === "br" } function vT(e, t, n, r, i = {}, o, s = l$(e) ? -1 : 0) { let a = qn.toArray(e.props.children); ce(n) && (a = a.slice(0, 1)); let l = !0; a = a.map(f => { if ((!Ht(f) || !c$(f)) && (l = !1), Ht(f)) return vT(f, t, n, r, i, o, s + 1); let d = ce(n) ? n : f; return ce(d) && o ? o.text(d) : d }); let { ["data-preset-tag"]: c, ...u } = e.props; if (ce(e.type) || Ud(e.type)) { let f = pb(e.type) || e.type, d = c || f, p = ce(d) ? t?.[d] : void 0; u.className = $u("framer-text", u.className, p), o && s === 0 && !l && Object.assign(u, o.props(u.style)); let y = f === "h1" || f === "h2" || f === "h3" || f === "h4" || f === "h5" || f === "h6", g = t?.anchor; if (y && g) { let b = u$(a, i); u.id = b; let h = $u("framer-text", g), m = k("a", { href: `#${b}`, className: h, children: a }); u.style = { ...u.style ?? {}, scrollMarginTop: r }, a = [m] } } return vr(e, u, ...a) } function u$(e, t) { let n = e.map(Zm).join(""), r = Hz(n), i = t[r] ?? 0; return i > 0 && (r += `-${i}`), t[r] = i + 1, r } function Zm(e) { return ce(e) || Ve(e) ? e.toString() : Ht(e) ? Zm(e.props.children) : Array.isArray(e) ? e.map(Zm).join("") : "" } var gU = Oe(({ children: e, html: t, htmlFromDesign: n, ...r }, i) => { let o = t || e || n; if (ce(o)) { !r.stylesPresetsClassName && Te(r.stylesPresetsClassNames) && (r.stylesPresetsClassName = Object.values(r.stylesPresetsClassNames).join(" ")); let s = { [ce(t) ? "html" : "htmlFromDesign"]: o }; return k(Kz, { ...r, ...s, ref: i }) } if (!r.stylesPresetsClassNames && ce(r.stylesPresetsClassName)) { let [s, a, l, c, u] = r.stylesPresetsClassName.split(" "); s === void 0 || a === void 0 || l === void 0 || c === void 0 || u === void 0 ? console.warn(`Encountered invalid stylesPresetsClassNames: ${r.stylesPresetsClassNames}`) : r.stylesPresetsClassNames = { h1: s, h2: a, h3: l, p: c, a: u } } return k(a$, { ...r, ref: i, children: Ht(o) ? o : void 0 }) }); function f$(e) { var t, n; let r = e * Math.PI / 180, i = { x: -Math.sin(r) * 100, y: Math.cos(r) * 100 }, o = dn(i.x, i.y), s = En(dn(.5, .5), o), a = Z.points({ x: 0, y: 0, width: 1, height: 1 }), l = a.map(g => ({ point: g, distance: dn.distance(o, g) })).sort((g, b) => g.distance - b.distance), c = (t = l[0]) == null ? void 0 : t.point, u = (n = l[1]) == null ? void 0 : n.point; $(c && u, "linearGradientLine: Must have 2 closest points."); let [f, d] = a.filter(g => !dn.isEqual(g, c) && !dn.isEqual(g, u)); $(f && d, "linearGradientLine: Must have 2 opposing points."); let p = En.intersection(s, En(c, u)), y = En.intersection(s, En(f, d)); return $(p && y, "linearGradientLine: Must have a start and end point."), En(p, y) } function d$(e, t) { var n, r; let i = f$(e.angle), o = il(e), s = ((n = o[0]) == null ? void 0 : n.position) ?? 0, a = ((r = o[o.length - 1]) == null ? void 0 : r.position) ?? 1, l = En.pointAtPercentDistance(i, s), c = En.pointAtPercentDistance(i, a), u = xo([s, a], [0, 1]); return { id: `id${t}g${Ha.hash(e)}`, x1: l.x, y1: l.y, x2: c.x, y2: c.y, stops: o.map(f => ({ color: f.value, alpha: dg.getAlpha(f.value) * e.alpha, position: u(f.position) })) } } function h$(e, t) { return { id: `id${t}g${ja.hash(e)}`, widthFactor: e.widthFactor, heightFactor: e.heightFactor, centerAnchorX: e.centerAnchorX, centerAnchorY: e.centerAnchorY, stops: il(e).map(n => ({ color: n.value, alpha: dg.getAlpha(n.value) * e.alpha, position: n.position })) } } function yT(e) { if (!ce(e) || e.charAt(e.length - 1) !== "%") return !1; let n = e.slice(0, -1), r = parseFloat(n); return Ve(r) } function bT(e) { let t = e.slice(0, -1), n = parseFloat(t); return Ve(n) ? n : 50 } function uk(e) { return yT(e) ? bT(e) / 100 : e === "left" ? 0 : e === "right" ? 1 : .5 } function fk(e) { return yT(e) ? bT(e) / 100 : e === "top" ? 0 : e === "bottom" ? 1 : .5 } function p$(e, t, n, r) { if (e = it.get(e, "#09F"), !Ki.isImageObject(e) || !e.pixelWidth || !e.pixelHeight) return; let i = e.pixelWidth, o = e.pixelHeight, s, { fit: a } = e, l = 1, c = 1, u = 0, f = 0; if (a === "fill" || a === "fit" || a === "tile" || !a) { let p = 1, y = 1, g = i / o, b = t.height * g, h = t.width / g, m = b / t.width, v = h / t.height; if (a === "tile") { e.backgroundSize ?? (e.backgroundSize = 1), l = Math.round(e.backgroundSize * (i / 2)), c = Math.round(e.backgroundSize * (o / 2)); let w = t.x ?? 0, C = t.y ?? 0, S = 0, R = 0; r && (S = w, R = C), u = (t.width - l) * uk(e.positionX) + S, f = (t.height - c) * fk(e.positionY) + R, s = `translate(${u + w}, ${f + C})` } else (a === "fill" || !a ? v > m : v < m) ? (y = v, f = (1 - v) * fk(e.positionY)) : (p = m, u = (1 - m) * uk(e.positionX)), s = `translate(${u}, ${f}) scale(${p}, ${y})` } return { id: `id${n}g-fillImage`, path: e.src ?? "", transform: s, width: l, height: c, offsetX: u, offsetY: f } } var m$ = "framer/asset-reference,"; function g$(e) { return e.startsWith(`data:${m$}`) } function v$(e, t) { if (/^\w+:/.test(e) && !g$(e)) return e; typeof t != "number" ? t = void 0 : t <= 512 ? t = 512 : t <= 1024 ? t = 1024 : t <= 2048 ? t = 2048 : t = 4096; let n = le.current() === le.export; return ut.assetResolver(e, { pixelSize: t, isExport: n }) ?? "" } var y$ = ({ id: e, path: t, transform: n, repeat: r, width: i, height: o, offsetX: s, offsetY: a }) => { let l = v$(t); return k("pattern", { id: e, width: r ? i : "100%", height: r ? o : "100%", patternContentUnits: r ? void 0 : "objectBoundingBox", patternUnits: r ? "userSpaceOnUse" : void 0, x: r ? s : void 0, y: r ? a : void 0, children: k("image", { width: r ? i : 1, height: r ? o : 1, href: l, preserveAspectRatio: "none", transform: r ? void 0 : n, x: r ? 0 : void 0, y: r ? 0 : void 0 }, l) }) }; var _m, b$ = (() => !FA() && typeof Document < "u" && typeof Document.parseHTMLUnsafe == "function")(); function x$(e, t) { return b$ && !t ? Document.parseHTMLUnsafe(e) : (_m ?? (_m = new DOMParser), _m.parseFromString(e, t ?? "text/html")) } var dk = ki(), w$ = class { constructor(e, t, n, r, i = 0) { this.id = e, this.svg = t, this.innerHTML = n, this.viewBox = r, this.count = i } }, hk = "position: absolute; overflow: hidden; bottom: 0; left: 0; width: 0; height: 0; z-index: 0; contain: strict", S$ = class {
    constructor() { T(this, "entries", new Map) } debugGetEntries() { return this.entries } subscribe(e, t, n) { if (!e || e === "") return ""; let r = this.entries.get(e); if (!r) { n || (n = `svg${String(nC(e))}_${String(e.length)}`); let i = e, o, s = k$(e); s && (t && C$(s, n), s.id = n, o = P$(s), s.removeAttribute("xmlns"), s.removeAttribute("xlink"), s.removeAttribute("xmlns:xlink"), i = s.outerHTML), r = this.createDOMElementFor(i, n, o), this.entries.set(e, r) } return r.count += 1, r.innerHTML } getViewBox(e) { if (!e || e === "") return; let t = this.entries.get(e); return t?.viewBox } unsubscribe(e) { if (!e || e === "") return; let t = this.entries.get(e); t && (t.count -= 1, !(t.count > 0) && setTimeout(() => this.maybeRemoveEntry(e), 5e3)) } maybeRemoveEntry(e) { let t = this.entries.get(e); t && (t.count > 0 || (this.entries.delete(e), this.removeDOMElement(t))) } removeDOMElement(e) { if (dk) { let t = document?.getElementById(e.id); t?.remove() } } createDOMElementFor(e, t, n) { if (dk) { let s = document.getElementById("svg-templates"); if (s || (s = document.createElement("div"), s.id = "svg-templates", s.style.cssText = hk, document.body.appendChild(s)), !document.getElementById(t)) { let a = document.createElement("div"); a.innerHTML = e; let l = a.firstElementChild; l && (l.id = t, s.appendChild(l)) } } let r = n ? `0 0 ${n.width} ${n.height}` : void 0, o = `<svg style="width:100%;height:100%"${r ? ` viewBox="${r}"` : ""}><use href="#${t}"/></svg>`; return new w$(t, e, o, r) } clear() { this.entries.clear() } generateTemplates() {
        let e = []; return e.push(`<div id="svg-templates" style="${hk}">`), this.entries.forEach(t => e.push(t.svg)), e.push("</div>"), e.join(`
`)
    }
}, Jo = new S$; function k$(e) { try { let n = x$(e).getElementsByTagName("svg")[0]; if (!n) throw Error("no svg element found"); return n } catch { return } } function C$(e, t) { let n = T$(t); xT(e, n) } function T$(e) { return e.replace(/[^\w\-:.]|^[^a-z]+/gi, "") } function xT(e, t) { E$(e, t), Array.from(e.children).forEach(r => { xT(r, t) }) } function E$(e, t) { e.getAttributeNames().forEach(r => { let i = e.getAttribute(r); if (!i) return; if (r === "id" && e.setAttribute(r, `${t}_${i}`), r === "href" || r === "xlink:href") { let [s, a] = i.split("#"); if (s) return; e.setAttribute(r, `#${t}_${a}`); return } let o = "url(#"; if (i.includes(o)) { let s = i.replace(o, `${o}${t}_`); e.setAttribute(r, s) } }) } var R$ = (() => ({ cm: 96 / 2.54, mm: 96 / 2.54 / 10, Q: 96 / 2.54 / 40, in: 96, pc: 96 / 6, pt: 96 / 72, px: 1, em: 16, ex: 8, ch: 8, rem: 16 }))(); function pk(e) { var t; if (!e) return; let n = /(-?[\d.]+)([a-z%]*)/u.exec(e); if (!(n?.[1] === void 0 || n?.[2] === void 0) && !((t = n[2]) != null && t.startsWith("%"))) return Math.round(parseFloat(n[1]) * (R$[n[2]] || 1)) } function P$(e) { let t = pk(e.getAttribute("width")), n = pk(e.getAttribute("height")); if (!(typeof t != "number" || typeof n != "number") && !(t <= 0 || n <= 0)) return { width: t, height: n } } function xU(e) { let t = Ja(), n = rl(e), r = x.useRef(null), i = mz(); return rf(e, r), k(O$, { ...e, innerRef: r, parentSize: t, layoutId: n, providedWindow: i }) } var _$ = 5e4; function F$(e) { return e.indexOf("image") >= 0 } function I$(e) { return e.indexOf("var(--") >= 0 } function L$(e) { return !!(e.borderRadius || e.borderBottomLeftRadius || e.borderBottomRightRadius || e.borderTopLeftRadius || e.borderTopRightRadius) } function mk(e, t) { var n, r; let i = e.current; if (!i) return; let o = t.providedWindow ?? ft, s = i.firstElementChild; if (!s || !(s instanceof o.SVGSVGElement)) return; if (!s.getAttribute("viewBox")) { let p = Jo.getViewBox(t.svg); p && s.setAttribute("viewBox", p) } let { withExternalLayout: a, parentSize: l } = t; if (!a && Za(t) && l !== 1 && l !== 2) return; let { intrinsicWidth: u, intrinsicHeight: f, _constraints: d } = t; ((n = s.viewBox.baseVal) == null ? void 0 : n.width) === 0 && ((r = s.viewBox.baseVal) == null ? void 0 : r.height) === 0 && J(u) && J(f) && s.setAttribute("viewBox", `0 0 ${u} ${f}`), d && d.aspectRatio ? s.setAttribute("preserveAspectRatio", "") : s.setAttribute("preserveAspectRatio", "none"), s.setAttribute("width", "100%"), s.setAttribute("height", "100%") } function M$() { return x.useInsertionEffect(() => { el() }, []), null } var O$ = (() => { var e; return e = class extends Ru { constructor() { super(...arguments), T(this, "container", x.createRef()), T(this, "svgElement", null), T(this, "setSVGElement", t => { this.svgElement = t, this.setLayerElement(t) }), T(this, "previouslyRenderedSVG", ""), T(this, "unmountedSVG", "") } static frame(t) { return $a(t, t.parentSize || 0) } get frame() { return $a(this.props, this.props.parentSize || 0) } componentDidMount() { if (this.unmountedSVG) { let { svgContentId: t } = this.props, n = t ? `svg${t}` : null; Jo.subscribe(this.unmountedSVG, !t, n), this.previouslyRenderedSVG = this.unmountedSVG } this.props.svgContentId || mk(this.container, this.props) } componentWillUnmount() { Jo.unsubscribe(this.previouslyRenderedSVG), this.unmountedSVG = this.previouslyRenderedSVG, this.previouslyRenderedSVG = "" } componentDidUpdate(t) { if (super.componentDidUpdate(t), this.props.svgContentId) return; let { fill: n } = this.props; Ki.isImageObject(n) && Ki.isImageObject(t.fill) && n.src !== t.fill.src && tC(this.svgElement, "fill", null, !1), mk(this.container, this.props) } collectLayout(t, n) { if (this.props.withExternalLayout) { n.width = "100%", n.height = "100%", n.aspectRatio = "inherit"; return } let r = this.frame, { rotation: i, intrinsicWidth: o, intrinsicHeight: s, width: a, height: l } = this.props, c = it.getNumber(i); if (t.opacity = J(this.props.opacity) ? this.props.opacity : 1, le.hasRestrictions() && r) { Object.assign(t, { transform: `translate(${r.x}px, ${r.y}px) rotate(${c.toFixed(4)}deg)`, width: `${r.width}px`, height: `${r.height}px` }), Za(this.props) && (t.position = "absolute"); let y = r.width / (o || 1), g = r.height / (s || 1); n.transformOrigin = "top left"; let { zoom: b, target: h } = Vu; if (h === le.export) { let m = b > 1 ? b : 1; n.transform = `scale(${y * m}, ${g * m})`, n.zoom = 1 / m } else n.transform = `scale(${y}, ${g})`; o && s && (n.width = o, n.height = s); return } let { left: u, right: f, top: d, bottom: p } = this.props; Object.assign(t, { left: u, right: f, top: d, bottom: p, width: a, height: l, rotate: c }), Object.assign(n, { left: 0, top: 0, bottom: 0, right: 0, position: "absolute" }) } render() { let { id: t, visible: n, style: r, fill: i, svg: o, intrinsicHeight: s, intrinsicWidth: a, title: l, description: c, layoutId: u, className: f, variants: d, withExternalLayout: p, innerRef: y, svgContentId: g, height: b, opacity: h, width: m, ...v } = this.props; if (!p && (!n || !t)) return null; let w = t ?? u ?? "svg", C = this.frame, S = C || { width: a || 100, height: s || 100 }, R = { ...r, imageRendering: "pixelated", flexShrink: 0 }, E = {}; this.collectLayout(R, E), DV(this.props, R), pg(this.props, R), Ru.applyWillChange(this.props, R, !1); let L = null; if (typeof i == "string" || G.isColorObject(i)) { let q = G.isColorObject(i) ? i.initialValue || G.toRgbString(i) : i; R.fill = q, R.color = q } else if (Ha.isLinearGradient(i)) { let q = i, ne = `${encodeURI(t || "")}g${Ha.hash(q)}`; R.fill = `url(#${ne})`; let { stops: be, x1: re, x2: pe, y1: ie, y2: ht } = d$(q, w); L = k("svg", { ref: this.setSVGElement, width: "100%", height: "100%", style: { position: "absolute" }, children: k("linearGradient", { id: ne, x1: re, x2: pe, y1: ie, y2: ht, children: be.map((Fe, Lt) => k("stop", { offset: Fe.position, stopColor: Fe.color, stopOpacity: Fe.alpha }, Lt)) }) }) } else if (ja.isRadialGradient(i)) { let q = i, ne = `${encodeURI(t || "")}g${ja.hash(q)}`; R.fill = `url(#${ne})`; let be = h$(q, w); L = k("svg", { ref: this.setSVGElement, width: "100%", height: "100%", style: { position: "absolute" }, children: k("radialGradient", { id: ne, cy: q.centerAnchorY, cx: q.centerAnchorX, r: q.widthFactor, children: be.stops.map((re, pe) => k("stop", { offset: re.position, stopColor: re.color, stopOpacity: re.alpha }, pe)) }) }) } else if (Ki.isImageObject(i)) { let q = p$(i, S, w); q && (R.fill = `url(#${q.id})`, L = k("svg", { ref: this.setSVGElement, width: "100%", height: "100%", style: { position: "absolute" }, children: k("defs", { children: k(y$, { ...q }) }) })) } let F = { "data-framer-component-type": "SVG" }, N = !C; N && Object.assign(F, Yk(this.props.center)); let A = !L && !R.fill && !R.background && !R.backgroundImage && o.length < _$ && !F$(o) && !I$(o), K = null; if (A) R.backgroundSize = "100% 100%", R.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(o)}')`, Jo.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = ""; else { let q = g ? `svg${g}` : null, ne = Jo.subscribe(o, !g, q); Jo.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = o, L$(R) && (R.overflow = "hidden"), K = ue(He, { children: [L, k("div", { className: "svgContainer", style: E, ref: this.container, dangerouslySetInnerHTML: { __html: ne } }, Ki.isImageObject(i) ? i.src : "")] }) } let U = nl(this.props.as), { href: H, target: W, rel: ee, onClick: te } = this.props; return ue(U, { ...F, ...v, layoutId: u, transformTemplate: N ? tf(this.props.center) : void 0, id: t, ref: y, style: R, className: f, variants: d, tabIndex: this.props.tabIndex, role: l || c ? "img" : void 0, "aria-label": l, "aria-description": c, href: H, target: W, rel: ee, onClick: te, children: [K, k(M$, {})] }) } }, T(e, "supportsConstraints", !0), T(e, "defaultSVGProps", { left: void 0, right: void 0, top: void 0, bottom: void 0, style: void 0, _constraints: { enabled: !0, aspectRatio: null }, parentSize: 0, rotation: 0, visible: !0, svg: "", shadows: [] }), T(e, "defaultProps", { ...Ru.defaultProps, ...e.defaultSVGProps }), e })(); function FU(e, t, n) { let r = wT(t); !n?.supportsExplicitInterCodegen && !r.some(i => i.explicitInter === !1) && r.push({ explicitInter: !1, fonts: [] }), Object.assign(e, { fonts: r }) } function IU(e) { return e.fonts ?? [] } function LU(e) { return e.length === 0 ? [{ explicitInter: !1, fonts: [] }] : wT(e) } function wT(e) { let t = { explicitInter: !1, fonts: [] }, n = []; for (let r of e) A$(r) ? n.push(r) : t.fonts.push(V$(r)); return t.fonts.length > 0 && n.push(t), n } var D$ = "explicitInter"; function A$(e) { return D$ in e } function V$(e) { let t; return e.url.startsWith("https://fonts.gstatic.com/s/") ? t = "google" : e.url.startsWith("https://framerusercontent.com/third-party-assets/fontshare/") ? t = "fontshare" : t = "custom", { ...e, source: t } } function MU(e, t) { let n = `${e}-start`; performance.mark(n), t(); let r = `${e}-end`; performance.mark(r), performance.measure(e, n, r) } Vs.prototype.addChild = function ({ transformer: e = t => t }) { let t = Ue(e(this.get())); return this.onChange(n => t.set(e(n))), t };/**
 * @license Emotion v11.0.0
 * MIT License
 *
 * Copyright (c) Emotion team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *//*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/export { x as a, qn as b, gr as c, ms as d, vr as e, ml as f, oo as g, Oe as h, KT as i, QT as j, yr as k, se as l, V as m, z as n, Ti as o, st as p, ae as q, D as r, Ye as s, Ct as t, He as u, k as v, ue as w, Zn as x, De as y, Y as z, vn as A, nb as B, tr as C, At as D, jF as E, ab as F, cb as G, lI as H, M1 as I, GL as J, eM as K, iH as L, lH as M, fH as N, dH as O, pH as P, cs as Q, rg as R, Lk as S, RH as T, IH as U, le as V, zH as W, nD as X, WH as Y, tA as Z, UH as _, Mj as $, $u as aa, s5 as ba, P8 as ca, O8 as da, D8 as ea, c5 as fa, N8 as ga, p5 as ha, TC as ia, q8 as ja, S5 as ka, J8 as la, V5 as ma, rW as na, cW as oa, hW as pa, mW as qa, HB as ra, yW as sa, KB as ta, bW as ua, xW as va, SW as wa, TW as xa, EW as ya, LW as za, AW as Aa, VW as Ba, $W as Ca, Du as Da, uU as Ea, gU as Fa, Jo as Ga, xU as Ha, FU as Ia, IU as Ja, LU as Ka, MU as La };
//# sourceMappingURL=chunk-U7QGETIO.mjs.map